<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IOF Library: Using the iof library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="page_iof_usage">Using the iof library</a></h1>[This page is under construction.<p>
The old documentation is still available as part of the distribution. Sorry for the inconvenience. -- OS]<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>TOC</dd></dl>
Notes on the documentation:<p>
<ul>
<li>There are basically two "syntaxes" for using the IOF library:<ul>
<li>Operator syntax, i.e. using classes and operators only; e.g. <div class="fragment"><pre class="fragment">        std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%s\n"</span>) &lt;&lt; 123;
</pre></div></li><li>Function syntax; e.g. <div class="fragment"><pre class="fragment">        iof::coutf(<span class="stringliteral">"%s\n"</span>, 123);
</pre></div> Some people prefer the latter, but the operator syntax can be more versatile in some rare cases. The documentation explains everything using operator syntax, while a separate section documents the differences when using functions. Refer to that section to translate the documentation for function syntax.</li></ul>
</li></ul>
<p>
<ul>
<li>Also, most of the concepts that pertain to output also apply to input. Therefore, the documentation focusses on output, just bear in mind that any iof concept discussed in terms of output can be applied to input, except for the differences mentioned in the section on formatted input. Most often all you need to do is change the operator used.</li></ul>
<h2><a class="anchor" name="sec_iof_use_intro">
Introduction to usage</a></h2>
Most likely, 90% of what you do with IOF will look like this:<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"Message: %s and %f.1s\n"</span>) &lt;&lt; <span class="keyword">true</span> &lt;&lt; 1.234;
</pre></div><p>
i.e. you "output" a formatter -- an instance of <code><a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a></code> -- to an STL stream, followed by the objects to be output. The <a class="el" href="page_iof_usage.html#sec_format_string">Format string</a> given to the formatter constructor allows the stream to be "formatted" for each object.<p>
Since iof simply wraps the STL I/O operators, any object appearing after the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> must have an<p>
<div class="fragment"><pre class="fragment">std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, T);
</pre></div><p>
defined for it, where 'T' is the type of the object (int, a class, etc) or a const reference of the object's type. All fundamental types (int etc) already have this, so you only need to do this for your classes. E.g.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Time {
    Time(<span class="keywordtype">int</span> hr, <span class="keywordtype">int</span> min, <span class="keywordtype">int</span> sec)
        : hr(hr), min(min), sec(sec) {}
    <span class="keywordtype">int</span> hr, min, sec;
    <span class="keyword">friend</span> std::ostream&amp; 
        operator&lt;&lt;(std::ostream&amp;, <span class="keyword">const</span> Time&amp;);
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, <span class="keyword">const</span> Time&amp; t) {
    <span class="keywordflow">return</span> out &lt;&lt; t.hr &lt;&lt; t.min &lt;&lt; t.sec;
}
<span class="keywordtype">int</span> main() {
    std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%02s"</span>) &lt;&lt; Time(1,34,36);
}
</pre></div><p>
would print "01:34:36" to std::cout.<h3><a class="anchor" name="sec_fmt_restore">
Q: What happens to the format state of the stream after a formatted output?</a></h3>
<dl compact><dt><b></b></dt><dd><b>A:</b> It is restored to the format state from just before the formatted output. </dd></dl>
<dl compact><dt><b></b></dt><dd>Indeed, STL streams have a format state. So if you say you want fixed point output to use two digits of precision, then <em>all</em> output of floating point numbers, anywhere in your code, will use two digits of precision, for <em>the remainder of your program</em>, or until it is changed somewhere else in your code. With iof, you never again need to worry about such effect: <div class="fragment"><pre class="fragment">cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%.2f "</span>) &lt;&lt; 1.2345678;
cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%f\n"</span>) &lt;&lt; 1.2345678;
</pre></div> will properly produce "1.23 1.234568" as opposed to "1.23 1.23" with regular STL stream commands.</dd></dl>
<h2><a class="anchor" name="sec_format_string">
Format string</a></h2>
The format string consists of text interspersed with <a class="el" href="page_iof_usage.html#sec_format_markers">Format markers</a> : <div class="fragment"><pre class="fragment"><span class="stringliteral">"Message: %s and %f.1s\n"</span>
</pre></div> is an example of format string, containing two format markers.<h3><a class="anchor" name="ssec_fs_toomany">
Q: What if there are more format markers than objects?</a></h3>
<dl compact><dt><b></b></dt><dd><b>A:</b> For <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>, this is always considered an error: in a debug build an assertion will fail, in release build an exception will get thrown. This exception is necessary since the format string can be created at run-time. </dd></dl>
<dl compact><dt><b></b></dt><dd>For <a class="el" href="classiof_1_1stringizer.html">iof::stringizer</a>, this is not considered an error, until you attempt to convert the stringizer to a string, in which case the same policy is used as for <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>. </dd></dl>
<dl compact><dt><b></b></dt><dd>You can change this behavior with compiler "defines": <code>EXTRA_MARKERS_NO_ASSERT</code> will <em>not</em> assert, and <code>EXTRA_MARKERS_NO_THROW</code> will <em>not</em> throw an <a class="el" href="classiof_1_1too__many__markers.html">iof::too_many_markers</a> exception (which derives from std::exception).</dd></dl>
<h3><a class="anchor" name="ssec_fs_toofew">
Q: What if there are more objects than format markers?</a></h3>
<dl compact><dt><b></b></dt><dd><b>A:</b> The object is output unformatted, since this is a plausible operation. E.g. <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"Hi "</span>) &lt;&lt; name &lt;&lt; <span class="charliteral">'#'</span> &lt;&lt; 1;
</pre></div> will just print "Hi yourName#1".</dd></dl>
<h3><a class="anchor" name="ssec_fs_flush">
Q: How do I get effect of std::endl or std::flush?</a></h3>
<dl compact><dt><b></b></dt><dd><b>A:</b> The '', normally a form feed character, is overloaded such that when it appears in a format string, it causes flush() to be called on the stream. To output a 'form feed' character to a stream, take it out of the format string: <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"header: %s\n\f"</span>) &lt;&lt; <span class="charliteral">'\f'</span>;
</pre></div> will output the form-feed character, followed by a std::endl.</dd></dl>
<h2><a class="anchor" name="sec_format_markers">
Format markers</a></h2>
Format markers indicate where the objects following the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> will be "placed" in the stream, for that reason they are sometimes called "placeholders".<p>
Format markers start with '' and end with 's' or 'S'. Anything in between is a <a class="el" href="page_iof_usage.html#sec_format_specification">format specification (FSC)</a> and controls <em>how</em> the associated object will be output. You end a marker with capital 'S' when you want its format specification to "persist" into other markers.<h3><a class="anchor" name="ssec_fm_esc">
Q: What if you want to print a percentage sign?</a></h3>
<dl compact><dt><b></b></dt><dd><b>A:</b> The usual: To print a "%" sign as part of your format string, double it: "%%" will not be interpreted as a format marker.</dd></dl>
<h3><a class="anchor" name="ssec_fm_sall">
Q: Why do format markers end with 's' regardless of the type being output?</a></h3>
<dl compact><dt><b></b></dt><dd><b>A:</b> Because the compiler knows the type better than you do :) So why should you have to worry about it? That's a nice aspect of C++ typing. Since every object, regarless of type, ends up output as a string or input from a string, so all markers end with 's'. You can concentrate on the formatting itself, not on type. </dd></dl>
<dl compact><dt><b></b></dt><dd>But how do you output, say, an int as a float? Send <code>float(yourInt)</code> to the stream, instead of just <code>yourInt</code> .</dd></dl>
<h2><a class="anchor" name="sec_format_specification">
Format specification characters (FSC)</a></h2>
A format specification is one or more characters appearing "inside" a sec_format_marker, each of which specifies how the stream should be manipulated before outputting the corresponding object (appearing after the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>). Most format specification characters have a single direct associated STL manipulator. E.g. 'f' is std::fixed.<p>
Any character not recognized (see below for a list) will be used as fill if a field width was specified, and if appropriate, but will be ignored otherwise.<h3><a class="anchor" name="sec_fmt_spec_sum_o">
Summary of output format specification characters</a></h3>
Here is the set of all output format specification characters: <div class="fragment"><pre class="fragment">! 0 1 2 3 4 5 6 7 8 9 . a b d o x X f F e E g G = - &lt; &gt; _ ^ # + 
</pre></div><h3><a class="anchor" name="sec_fmt_spec_sum_i">
Summary of input format specification characters</a></h3>
Here is the set of all input format specification characters: <div class="fragment"><pre class="fragment">! 0 1 2 3 4 5 6 7 8 9 . a b d o x X ~&gt; 
</pre></div><h3><a class="anchor" name="sec_fmt_spec_escape">
Escape character for format specifications</a></h3>
The '!' is the "escape" character, that allows a format specification character to be used as a fill character. So "%10f.2s" is a format marker that will print a floating point number in "fixed point" notation in a field of 10 chars wide, whereas "%10!f.2s" will print the same number in "general notation" with two significant digits, and pad it with 'f' instead of spaces.<h3><a class="anchor" name="sec_fmt_spec_meaning">
Meaning of FSC: C vs C++</a></h3>
Most are identical in meaning to those used by C's printf() and scanf() (see e.g. <a href="http://www.cplusplus.com/ref/cstdio/printf.html">http://www.cplusplus.com/ref/cstdio/printf.html</a>), but are extended to apply to objects and not just fundamental types. E.g. '-' does left alignment of the object: if the object is an integer, this is like printf() would do, but if the object is a struct or class with an operator&lt;&lt;, the object will first be output to a temporary stream, the resulting string extracted, and sent to the real stream, then padded with the appropriate number of blanks.<h3><a class="anchor" name="sec_fmt_spec_vs_type">
Q: How is the format specification affected by object type?</a></h3>
<dl compact><dt><b></b></dt><dd><b>A:</b> The format specification characters for a given marker only affect the object being output or input if the specification makes sense for the type of object deduced by the compiler. E.g. giving "%f.2s" as format marker for an integer will do nothing except print the integer, since "fixed decimal" and "precision" apply only to floating point types in STL. This behavior is not specific to iof, it is a consequence of the STL.</dd></dl>
<h3><a class="anchor" name="ssec_fsc_S">
Q: How do you apply a format specification to several format markers?</a></h3>
<dl compact><dt><b></b></dt><dd><b>A:</b> You use <a class="el" href="page_iof_usage.html#ssec_fmt_persist">persistent formatting</a>, ie end a marker with 'S' instead of 's'.</dd></dl>
<h2><a class="anchor" name="sec_fmt_state_changes">
Format state management</a></h2>
Let's call the format that the stream had when the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> was created the "startup format state", SFS for short. Then, <em>any</em> text in the <em>format</em> <em>string</em> is always output using the <em>SFS</em>, and the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> <em>always</em> restores the stream state to the SFS when the format string has been executed or when an exception gets thrown.<p>
If you never use 'S' to end a format marker, it's pretty simple: whenever a format marker is encountered, the stream's format is set to the SFS, and the format specification modifies the stream's state. Then the object is output, and the stream's state is again set to the SFS.<p>
When you use 'S', you tell <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> to "persist" the format specification for the remainder of the objects, ie you are using persistent formatting.<h3><a class="anchor" name="ssec_fmt_persist">
Persistent formatting</a></h3>
Persistent formatting gives you a way to accumulate format specifications, or "factor out" specifications. E.g. compare <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%f.2s %f.2s %f.2s %f.2s\n"</span>) &lt;&lt; ...;
</pre></div> which outputs four numbers with the same format, to the equivalent command that uses persistent formatting: <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%f.2S %s %s %s\n"</span>) &lt;&lt; ...;
</pre></div> The output will be the same for both cases, but you need maintain far less format characters with the second option.<p>
Specifically, the format state for a marker accumulates the effect of all previous persistent format specifications, in the order they appear in the format string. So persistent format can be undone. E.g. <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%f.2S %s %s %.4S %s %s\n"</span>) &lt;&lt; ...;
</pre></div> will print all six numbers in fixed point notation, but the first three will have two digits precision, the next group of three (note the 'f' was not given, but is 'inherited' from the first marker) will have 4 digits precision.<h2><a class="anchor" name="sec_iof_fns_instead">
Input/Output using functions instead of classes/operators</a></h2>
This section documents how to use the iof functions for I/O (the "function" syntax), instead of the "equivalent" classes and operators (the "operator" syntax).<p>
There are two aspects:<p>
<ul>
<li>which functions vs which classes</li><li>which header files to include</li></ul>
<h3><a class="anchor" name="ssec_iof_fns_which">
What functions to use, when</a></h3>
The I/O functions in the iof namespace are the following:<p>
<ul>
<li><code>iof::coutf()</code>, <code>iof::cerrf()</code>, <code>iof::cinf()</code>: it should be pretty obvious what each one does, and how to use them. The "f" on the end is a reminder that they are the "function" equivalent of the associated stream. E.g. <div class="fragment"><pre class="fragment">  iof::coutf(<span class="stringliteral">"%s\n"</span>, 123);
</pre></div> sends "123\n" to <code>std::cout</code>. All three functions in fact merely translate the function syntax to operator syntax by the use of <code><a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a></code>.</li></ul>
<p>
<ul>
<li><code>iof::prints()</code>, <code>iof::scans()</code>: they are the IOF equivalent of C's vprintf() and vscanf(), but for streams instead of files, so they are named prints() and scans() instead. They are pretty easy to use too: <div class="fragment"><pre class="fragment">  std::ofstream aStream(<span class="stringliteral">"tmp.txt"</span>, <span class="stringliteral">"w"</span>);
  iof::prints(aStream, <span class="stringliteral">"%s\n"</span>, 123);
</pre></div> sends "123\n" to the stream given as first arg. Both functions have the exact same syntax. Note that the <code>iof::c*f</code>() functions are just wrappers calling the <code>prints/scans</code>() functions with the appropriate <code>std::c*</code> stream.</li></ul>
<p>
<ul>
<li><code>tostr()</code>: same as iof::prints(), but internally uses a std::ostringstream. It just makes it really easy to get a string from a formatted output operation. It's operator equivalent is the <code><a class="el" href="classiof_1_1stringizer.html">iof::stringizer</a></code> class.</li></ul>
<h3><a class="anchor" name="ssec_iof_fns_headers">
Header files to use, when</a></h3>
Whichever syntax you prefer, you can get away 99% of the time with<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="output_8hpp.html">iof/output.hpp</a>"</span>
<span class="comment">// and/or</span>
<span class="preprocessor">#include "<a class="code" href="input_8hpp.html">iof/input.hpp</a>"</span>
</pre></div><p>
But those headers include pretty much every other header, so if you want to import a smaller section of the iof namespace, you can get away with<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="fmtr_8hpp.html">iof/fmtr.hpp</a>"</span>
<span class="comment">// and/or</span>
<span class="preprocessor">#include "<a class="code" href="stringizer_8hpp.html">iof/stringizer.hpp</a>"</span>
</pre></div><p>
99% of the time for the operator syntax, or, for function syntax, the following:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="coutf_8hpp.html">iof/coutf.hpp</a>"</span>  <span class="comment">// for output to std::cout</span>
<span class="comment">// and/or</span>
<span class="preprocessor">#include "<a class="code" href="cerrf_8hpp.html">iof/cerrf.hpp</a>"</span>  <span class="comment">// for output to std::cerr</span>
<span class="comment">// and/or</span>
<span class="preprocessor">#include "<a class="code" href="prints_8hpp.html">iof/prints.hpp</a>"</span> <span class="comment">// for output to any STL stream</span>
<span class="comment">// and/or</span>
<span class="preprocessor">#include "<a class="code" href="tostr_8hpp.html">iof/tostr.hpp</a>"</span>  <span class="comment">// for creating a string from formatted output</span>
<span class="comment">// and/or</span>
<span class="preprocessor">#include "<a class="code" href="cinf_8hpp.html">iof/cinf.hpp</a>"</span>   <span class="comment">// for input from std::cin</span>
<span class="comment">// and/or</span>
<span class="preprocessor">#include "<a class="code" href="scans_8hpp.html">iof/scans.hpp</a>"</span>  <span class="comment">// for input from any STL stream</span>
</pre></div><h3><a class="anchor" name="ssec_iof_fns_limits">
Limitations when using function syntax</a></h3>
There are two notable limitations of using the function syntax instead of the operator syntax:<p>
<ul>
<li>Only up to 10 objects can be sent to a stream in one function call. In practice this is very rarely a limitation. If it is, it is trivial to create a function of N arguments manually, just look at the <a class="el" href="prints_8hpp.html">prints.hpp</a> and/or <a class="el" href="scans_8hpp.html">scans.hpp</a> headers.</li><li>Some manipulators that require implicit template instantiation can't be given as parameter to the functions; why you would want to do that anyways is unclear, but it is a limitation. In this case you could use IOF classes/operators, or create an explicit template instantiation of the manipulator and give this as a parameter instead. </li></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun Oct 15 20:32:35 2006 for IOF Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
