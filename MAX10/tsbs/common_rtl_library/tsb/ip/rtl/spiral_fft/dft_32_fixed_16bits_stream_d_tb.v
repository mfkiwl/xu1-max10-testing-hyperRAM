/*
 * This source file contains a Verilog description of an IP core
 * automatically generated by the SPIRAL HDL Generator.
 *
 * This product includes a hardware design developed by Carnegie Mellon University.
 *
 * Copyright (c) 2005-2011 by Peter A. Milder for the SPIRAL Project,
 * Carnegie Mellon University
 *
 * For more information, see the SPIRAL project website at:
 *   http://www.spiral.net
 *
 * This design is provided for internal, non-commercial research use only
 * and is not for redistribution, with or without modifications.
 * 
 * You may not use the name "Carnegie Mellon University" or derivations
 * thereof to endorse or promote products derived from this software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS OR BE ERROR-FREE AND ANY
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * TITLE, OR NON-INFRINGEMENT.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * BE LIABLE FOR ANY DAMAGES, INCLUDING BUT NOT LIMITED TO DIRECT, INDIRECT,
 * SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN
 * ANY WAY CONNECTED WITH THIS SOFTWARE (WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT OR OTHERWISE).
 *
 */

//   Input/output stream: 4 complex words per cycle
//   Throughput: one transform every 8 cycles
//   Latency: 119 cycles

//   Resources required:
//     24 multipliers (16 x 16 bit)
//     52 adders (16 x 16 bit)
//     8 RAMs (8 words, 32 bits per word)
//     24 RAMs (16 words, 32 bits per word)
//     4 ROMs (8 words, 16 bits per word)

// Generated on Mon Jul 29 15:01:17 EDT 2019

// Latency: 119 clock cycles
// Throughput: 1 transform every 8 cycles


// We use an interleaved complex data format.  X0 represents the
// real portion of the first input, and X1 represents the imaginary
// portion.  The X variables are system inputs and the Y variables
// are system outputs.

// The design uses a system of flag signals to indicate the
// beginning of the input and output data streams.  The 'next'
// input (asserted high), is used to instruct the system that the
// input stream will begin on the following cycle.

// This system has a 'gap' of 8 cycles.  This means that
// 8 cycles must elapse between the beginning of the input
// vectors.

// The output signal 'next_out' (also asserted high) indicates
// that the output vector will begin streaming out of the system
 // on the following cycle.

// The system has a latency of 119 cycles.  This means that
// the 'next_out' will be asserted 119 cycles after the user
// asserts 'next'.

// The simple testbench below will demonstrate the timing for loading
// and unloading data vectors.
// The system reset signal is asserted high.

// Please note: when simulating floating point code, you must include
// Xilinx's DSP slice simulation module.


module dft_testbench();
   reg clk, reset, next;
   wire next_out;
   integer i, j, k, l, m;
   reg [15:0] counter;
   reg [15:0] in [7:0];
   wire [15:0] X0;
   wire [15:0] Y0;
   wire [15:0] X1;
   wire [15:0] Y1;
   wire [15:0] X2;
   wire [15:0] Y2;
   wire [15:0] X3;
   wire [15:0] Y3;
   wire [15:0] X4;
   wire [15:0] Y4;
   wire [15:0] X5;
   wire [15:0] Y5;
   wire [15:0] X6;
   wire [15:0] Y6;
   wire [15:0] X7;
   wire [15:0] Y7;
   reg clrCnt;
   assign X0 = in[0];
   assign X1 = in[1];
   assign X2 = in[2];
   assign X3 = in[3];
   assign X4 = in[4];
   assign X5 = in[5];
   assign X6 = in[6];
   assign X7 = in[7];

   initial clk = 0;

   always #10000 clk = ~clk;


   // Instantiate top-level module of core 'X' signals are system inputs
   // and 'Y' signals are system outputs
   dft_top dft_top_instance (.clk(clk), .reset(reset), .next(next), .next_out(next_out),
    .X0(X0), .Y0(Y0),
    .X1(X1), .Y1(Y1),
    .X2(X2), .Y2(Y2),
    .X3(X3), .Y3(Y3),
    .X4(X4), .Y4(Y4),
    .X5(X5), .Y5(Y5),
    .X6(X6), .Y6(Y6),
    .X7(X7), .Y7(Y7));

   // You can use this counter to verify that the gap and latency are as expected.
   always @(posedge clk) begin
      if (clrCnt) counter <= 0;
      else counter <= counter+1;
   end


   initial begin
      @(posedge clk);
      @(posedge clk);

      // On the next cycle, begin loading input vector.
      next <= 1;
      clrCnt <= 1;
      @(posedge clk);
      clrCnt <= 0;
      next <= 0;

      // The 32 complex data points enter the system over 8 cycles
      for (j=0; j < 7; j = j+1) begin
          // Input: 4 complex words per cycle
         for (k=0; k < 8; k = k+1) begin
            in[k] <= j*8 + k;
         end
         @(posedge clk);
      end
      j = 7;
      for (k=0; k < 8; k = k+1) begin
         in[k] <= j*8 + k;
      end


      @(posedge clk);
      // Wait until the next data vector can be entered
      while (counter < 6)
        @(posedge clk);

      // On the next cycle, we will start the next data vector
      next <= 1;
      clrCnt <= 1;
      @(posedge clk);
      clrCnt <= 0;
      next <= 0;

      // Start entering next input vector
      for (j=0; j < 7; j = j+1) begin
         // Input 8 words per cycle
         for (k=0; k < 8; k = k+1) begin
            in[k] <= 64 + j*8 + k;
          end
          @(posedge clk);
       end
       j = 7;
       for (k=0; k < 8; k = k+1) begin
          in[k] <= 64 + j*8 + k;
       end
   end


   initial begin
      // set initial values
      in[0] <= 0;
      in[1] <= 0;
      in[2] <= 0;
      in[3] <= 0;
      in[4] <= 0;
      in[5] <= 0;
      in[6] <= 0;
      in[7] <= 0;
      next <= 0;
      reset <= 0;

      @(posedge clk);
      reset <= 1;
      @(posedge clk);
      reset <= 0;
      @(posedge clk);
      @(posedge clk);
      // Wait until next_out goes high, then wait one clock cycle and begin receiving data
      @(posedge next_out);
      @(posedge clk); #1;
      $display("--- begin output 1---");

      for (m=0; m < 7; m=m+1) begin
         $display("%x", Y0);
         $display("%x", Y1);
         $display("%x", Y2);
         $display("%x", Y3);
         $display("%x", Y4);
         $display("%x", Y5);
         $display("%x", Y6);
         $display("%x", Y7);
         @(posedge clk); #1;
      end
      $display("%x", Y0);
      $display("%x", Y1);
      $display("%x", Y2);
      $display("%x", Y3);
      $display("%x", Y4);
      $display("%x", Y5);
      $display("%x", Y6);
      $display("%x", Y7);
      // Wait until next_out goes high, then wait one clock cycle and begin receiving data
      @(posedge next_out);
      @(posedge clk); #1;
      $display("--- begin output 2---");

      for (m=0; m < 7; m=m+1) begin
         $display("%x", Y0);
         $display("%x", Y1);
         $display("%x", Y2);
         $display("%x", Y3);
         $display("%x", Y4);
         $display("%x", Y5);
         $display("%x", Y6);
         $display("%x", Y7);
         @(posedge clk); #1;
      end
      $display("%x", Y0);
      $display("%x", Y1);
      $display("%x", Y2);
      $display("%x", Y3);
      $display("%x", Y4);
      $display("%x", Y5);
      $display("%x", Y6);
      $display("%x", Y7);
      $finish;
   end
endmodule

// Latency: 119
// Gap: 8
// module_name_is:dft_top
module dft_top(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3,
   X4, Y4,
   X5, Y5,
   X6, Y6,
   X7, Y7);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   wire [15:0] t0_0;
   wire [15:0] t0_1;
   wire [15:0] t0_2;
   wire [15:0] t0_3;
   wire [15:0] t0_4;
   wire [15:0] t0_5;
   wire [15:0] t0_6;
   wire [15:0] t0_7;
   wire next_0;
   wire [15:0] t1_0;
   wire [15:0] t1_1;
   wire [15:0] t1_2;
   wire [15:0] t1_3;
   wire [15:0] t1_4;
   wire [15:0] t1_5;
   wire [15:0] t1_6;
   wire [15:0] t1_7;
   wire next_1;
   wire [15:0] t2_0;
   wire [15:0] t2_1;
   wire [15:0] t2_2;
   wire [15:0] t2_3;
   wire [15:0] t2_4;
   wire [15:0] t2_5;
   wire [15:0] t2_6;
   wire [15:0] t2_7;
   wire next_2;
   wire [15:0] t3_0;
   wire [15:0] t3_1;
   wire [15:0] t3_2;
   wire [15:0] t3_3;
   wire [15:0] t3_4;
   wire [15:0] t3_5;
   wire [15:0] t3_6;
   wire [15:0] t3_7;
   wire next_3;
   wire [15:0] t4_0;
   wire [15:0] t4_1;
   wire [15:0] t4_2;
   wire [15:0] t4_3;
   wire [15:0] t4_4;
   wire [15:0] t4_5;
   wire [15:0] t4_6;
   wire [15:0] t4_7;
   wire next_4;
   wire [15:0] t5_0;
   wire [15:0] t5_1;
   wire [15:0] t5_2;
   wire [15:0] t5_3;
   wire [15:0] t5_4;
   wire [15:0] t5_5;
   wire [15:0] t5_6;
   wire [15:0] t5_7;
   wire next_5;
   wire [15:0] t6_0;
   wire [15:0] t6_1;
   wire [15:0] t6_2;
   wire [15:0] t6_3;
   wire [15:0] t6_4;
   wire [15:0] t6_5;
   wire [15:0] t6_6;
   wire [15:0] t6_7;
   wire next_6;
   wire [15:0] t7_0;
   wire [15:0] t7_1;
   wire [15:0] t7_2;
   wire [15:0] t7_3;
   wire [15:0] t7_4;
   wire [15:0] t7_5;
   wire [15:0] t7_6;
   wire [15:0] t7_7;
   wire next_7;
   wire [15:0] t8_0;
   wire [15:0] t8_1;
   wire [15:0] t8_2;
   wire [15:0] t8_3;
   wire [15:0] t8_4;
   wire [15:0] t8_5;
   wire [15:0] t8_6;
   wire [15:0] t8_7;
   wire next_8;
   wire [15:0] t9_0;
   wire [15:0] t9_1;
   wire [15:0] t9_2;
   wire [15:0] t9_3;
   wire [15:0] t9_4;
   wire [15:0] t9_5;
   wire [15:0] t9_6;
   wire [15:0] t9_7;
   wire next_9;
   wire [15:0] t10_0;
   wire [15:0] t10_1;
   wire [15:0] t10_2;
   wire [15:0] t10_3;
   wire [15:0] t10_4;
   wire [15:0] t10_5;
   wire [15:0] t10_6;
   wire [15:0] t10_7;
   wire next_10;
   wire [15:0] t11_0;
   wire [15:0] t11_1;
   wire [15:0] t11_2;
   wire [15:0] t11_3;
   wire [15:0] t11_4;
   wire [15:0] t11_5;
   wire [15:0] t11_6;
   wire [15:0] t11_7;
   wire next_11;
   wire [15:0] t12_0;
   wire [15:0] t12_1;
   wire [15:0] t12_2;
   wire [15:0] t12_3;
   wire [15:0] t12_4;
   wire [15:0] t12_5;
   wire [15:0] t12_6;
   wire [15:0] t12_7;
   wire next_12;
   wire [15:0] t13_0;
   wire [15:0] t13_1;
   wire [15:0] t13_2;
   wire [15:0] t13_3;
   wire [15:0] t13_4;
   wire [15:0] t13_5;
   wire [15:0] t13_6;
   wire [15:0] t13_7;
   wire next_13;
   assign t0_0 = X0;
   assign Y0 = t13_0;
   assign t0_1 = X1;
   assign Y1 = t13_1;
   assign t0_2 = X2;
   assign Y2 = t13_2;
   assign t0_3 = X3;
   assign Y3 = t13_3;
   assign t0_4 = X4;
   assign Y4 = t13_4;
   assign t0_5 = X5;
   assign Y5 = t13_5;
   assign t0_6 = X6;
   assign Y6 = t13_6;
   assign t0_7 = X7;
   assign Y7 = t13_7;
   assign next_0 = next;
   assign next_out = next_13;

// latency=21, gap=8
   rc77645 stage0(.clk(clk), .reset(reset), .next(next_0), .next_out(next_1),
    .X0(t0_0), .Y0(t1_0),
    .X1(t0_1), .Y1(t1_1),
    .X2(t0_2), .Y2(t1_2),
    .X3(t0_3), .Y3(t1_3),
    .X4(t0_4), .Y4(t1_4),
    .X5(t0_5), .Y5(t1_5),
    .X6(t0_6), .Y6(t1_6),
    .X7(t0_7), .Y7(t1_7));


// latency=2, gap=8
   codeBlock77647 stage1(.clk(clk), .reset(reset), .next_in(next_1), .next_out(next_2),
       .X0_in(t1_0), .Y0(t2_0),
       .X1_in(t1_1), .Y1(t2_1),
       .X2_in(t1_2), .Y2(t2_2),
       .X3_in(t1_3), .Y3(t2_3),
       .X4_in(t1_4), .Y4(t2_4),
       .X5_in(t1_5), .Y5(t2_5),
       .X6_in(t1_6), .Y6(t2_6),
       .X7_in(t1_7), .Y7(t2_7));


// latency=2, gap=8
   codeBlock77802 stage2(.clk(clk), .reset(reset), .next_in(next_2), .next_out(next_3),
       .X0_in(t2_0), .Y0(t3_0),
       .X1_in(t2_1), .Y1(t3_1),
       .X2_in(t2_2), .Y2(t3_2),
       .X3_in(t2_3), .Y3(t3_3),
       .X4_in(t2_4), .Y4(t3_4),
       .X5_in(t2_5), .Y5(t3_5),
       .X6_in(t2_6), .Y6(t3_6),
       .X7_in(t2_7), .Y7(t3_7));


// latency=9, gap=8
   rc77960 stage3(.clk(clk), .reset(reset), .next(next_3), .next_out(next_4),
    .X0(t3_0), .Y0(t4_0),
    .X1(t3_1), .Y1(t4_1),
    .X2(t3_2), .Y2(t4_2),
    .X3(t3_3), .Y3(t4_3),
    .X4(t3_4), .Y4(t4_4),
    .X5(t3_5), .Y5(t4_5),
    .X6(t3_6), .Y6(t4_6),
    .X7(t3_7), .Y7(t4_7));


// latency=8, gap=8
   DirSum_78317 stage4(.next(next_4), .clk(clk), .reset(reset), .next_out(next_5),
       .X0(t4_0), .Y0(t5_0),
       .X1(t4_1), .Y1(t5_1),
       .X2(t4_2), .Y2(t5_2),
       .X3(t4_3), .Y3(t5_3),
       .X4(t4_4), .Y4(t5_4),
       .X5(t4_5), .Y5(t5_5),
       .X6(t4_6), .Y6(t5_6),
       .X7(t4_7), .Y7(t5_7));


// latency=2, gap=8
   codeBlock78320 stage5(.clk(clk), .reset(reset), .next_in(next_5), .next_out(next_6),
       .X0_in(t5_0), .Y0(t6_0),
       .X1_in(t5_1), .Y1(t6_1),
       .X2_in(t5_2), .Y2(t6_2),
       .X3_in(t5_3), .Y3(t6_3),
       .X4_in(t5_4), .Y4(t6_4),
       .X5_in(t5_5), .Y5(t6_5),
       .X6_in(t5_6), .Y6(t6_6),
       .X7_in(t5_7), .Y7(t6_7));


// latency=13, gap=8
   rc78478 stage6(.clk(clk), .reset(reset), .next(next_6), .next_out(next_7),
    .X0(t6_0), .Y0(t7_0),
    .X1(t6_1), .Y1(t7_1),
    .X2(t6_2), .Y2(t7_2),
    .X3(t6_3), .Y3(t7_3),
    .X4(t6_4), .Y4(t7_4),
    .X5(t6_5), .Y5(t7_5),
    .X6(t6_6), .Y6(t7_6),
    .X7(t6_7), .Y7(t7_7));


// latency=8, gap=8
   DirSum_78851 stage7(.next(next_7), .clk(clk), .reset(reset), .next_out(next_8),
       .X0(t7_0), .Y0(t8_0),
       .X1(t7_1), .Y1(t8_1),
       .X2(t7_2), .Y2(t8_2),
       .X3(t7_3), .Y3(t8_3),
       .X4(t7_4), .Y4(t8_4),
       .X5(t7_5), .Y5(t8_5),
       .X6(t7_6), .Y6(t8_6),
       .X7(t7_7), .Y7(t8_7));


// latency=2, gap=8
   codeBlock78854 stage8(.clk(clk), .reset(reset), .next_in(next_8), .next_out(next_9),
       .X0_in(t8_0), .Y0(t9_0),
       .X1_in(t8_1), .Y1(t9_1),
       .X2_in(t8_2), .Y2(t9_2),
       .X3_in(t8_3), .Y3(t9_3),
       .X4_in(t8_4), .Y4(t9_4),
       .X5_in(t8_5), .Y5(t9_5),
       .X6_in(t8_6), .Y6(t9_6),
       .X7_in(t8_7), .Y7(t9_7));


// latency=21, gap=8
   rc79012 stage9(.clk(clk), .reset(reset), .next(next_9), .next_out(next_10),
    .X0(t9_0), .Y0(t10_0),
    .X1(t9_1), .Y1(t10_1),
    .X2(t9_2), .Y2(t10_2),
    .X3(t9_3), .Y3(t10_3),
    .X4(t9_4), .Y4(t10_4),
    .X5(t9_5), .Y5(t10_5),
    .X6(t9_6), .Y6(t10_6),
    .X7(t9_7), .Y7(t10_7));


// latency=8, gap=8
   DirSum_79416 stage10(.next(next_10), .clk(clk), .reset(reset), .next_out(next_11),
       .X0(t10_0), .Y0(t11_0),
       .X1(t10_1), .Y1(t11_1),
       .X2(t10_2), .Y2(t11_2),
       .X3(t10_3), .Y3(t11_3),
       .X4(t10_4), .Y4(t11_4),
       .X5(t10_5), .Y5(t11_5),
       .X6(t10_6), .Y6(t11_6),
       .X7(t10_7), .Y7(t11_7));


// latency=2, gap=8
   codeBlock79419 stage11(.clk(clk), .reset(reset), .next_in(next_11), .next_out(next_12),
       .X0_in(t11_0), .Y0(t12_0),
       .X1_in(t11_1), .Y1(t12_1),
       .X2_in(t11_2), .Y2(t12_2),
       .X3_in(t11_3), .Y3(t12_3),
       .X4_in(t11_4), .Y4(t12_4),
       .X5_in(t11_5), .Y5(t12_5),
       .X6_in(t11_6), .Y6(t12_6),
       .X7_in(t11_7), .Y7(t12_7));


// latency=21, gap=8
   rc79577 stage12(.clk(clk), .reset(reset), .next(next_12), .next_out(next_13),
    .X0(t12_0), .Y0(t13_0),
    .X1(t12_1), .Y1(t13_1),
    .X2(t12_2), .Y2(t13_2),
    .X3(t12_3), .Y3(t13_3),
    .X4(t12_4), .Y4(t13_4),
    .X5(t12_5), .Y5(t13_5),
    .X6(t12_6), .Y6(t13_6),
    .X7(t12_7), .Y7(t13_7));


endmodule

// Latency: 21
// Gap: 8
module rc77645(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3,
   X4, Y4,
   X5, Y5,
   X6, Y6,
   X7, Y7);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   wire [31:0] t2;
   wire [31:0] s2;
   assign t2 = {X4, X5};
   wire [31:0] t3;
   wire [31:0] s3;
   assign t3 = {X6, X7};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];
   assign Y4 = s2[31:16];
   assign Y5 = s2[15:0];
   assign Y6 = s3[31:16];
   assign Y7 = s3[15:0];

   perm77643 instPerm80821(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
    .x2(t2), .y2(s2),
    .x3(t3), .y3(s3),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet77643(itr, clk, ct
,       x0, y0
,       x1, y1
,       x2, y2
,       x3, y3
);

    parameter width = 32;

    input [2:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    input [width-1:0] x2;
    output reg [width-1:0] y2;
    input [width-1:0] x3;
    output reg [width-1:0] y3;
    wire [width-1:0] t0_0, t0_1, t0_2, t0_3;
    wire [width-1:0] t1_0, t1_1, t1_2, t1_3;
    wire [width-1:0] t2_0, t2_1, t2_2, t2_3;
    reg [width-1:0] t3_0, t3_1, t3_2, t3_3;
    wire [width-1:0] t4_0, t4_1, t4_2, t4_3;
    reg [width-1:0] t5_0, t5_1, t5_2, t5_3;

    reg [3:0] control;

    always @(posedge clk) begin
      case(ct)
        3'd0: control <= 4'b1111;
        3'd1: control <= 4'b1111;
        3'd2: control <= 4'b0011;
        3'd3: control <= 4'b0011;
        3'd4: control <= 4'b1100;
        3'd5: control <= 4'b1100;
        3'd6: control <= 4'b0000;
        3'd7: control <= 4'b0000;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [3:0] control0;
   reg [3:0] control1;
    always @(posedge clk) begin
       control0 <= control;
        control1 <= control0;
    end
    assign t0_0 = x0;
    assign t0_1 = x2;
    assign t0_2 = x1;
    assign t0_3 = x3;
     assign t1_0 = t0_0;
     assign t1_1 = t0_1;
     assign t1_2 = t0_2;
     assign t1_3 = t0_3;
    assign t2_0 = t1_0;
    assign t2_1 = t1_2;
    assign t2_2 = t1_1;
    assign t2_3 = t1_3;
   always @(posedge clk) begin
         t3_0 <= (control0[3] == 0) ? t2_0 : t2_1;
         t3_1 <= (control0[3] == 0) ? t2_1 : t2_0;
         t3_2 <= (control0[2] == 0) ? t2_2 : t2_3;
         t3_3 <= (control0[2] == 0) ? t2_3 : t2_2;
   end
    assign t4_0 = t3_0;
    assign t4_1 = t3_2;
    assign t4_2 = t3_1;
    assign t4_3 = t3_3;
   always @(posedge clk) begin
         t5_0 <= (control1[1] == 0) ? t4_0 : t4_1;
         t5_1 <= (control1[1] == 0) ? t4_1 : t4_0;
         t5_2 <= (control1[0] == 0) ? t4_2 : t4_3;
         t5_3 <= (control1[0] == 0) ? t4_3 : t4_2;
   end
    always @(posedge clk) begin
        y0 <= t5_0;
        y1 <= t5_2;
        y2 <= t5_1;
        y3 <= t5_3;
    end
endmodule

// Latency: 21
// Gap: 8
module perm77643(clk, next, reset, next_out,
   x0, y0,
   x1, y1,
   x2, y2,
   x3, y3);
   parameter width = 32;

   parameter depth = 8;

   parameter addrbits = 3;

   parameter muxbits = 2;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input [width-1:0]  x2;
   output [width-1:0]  y2;
   wire [width-1:0]  t2;
   wire [width-1:0]  s2;
   input [width-1:0]  x3;
   output [width-1:0]  y3;
   wire [width-1:0]  t3;
   wire [width-1:0]  s3;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg [addrbits-1:0] s1rd2, s2wr2, s2rd2;
   reg [addrbits-1:0] s1rd3, s2wr3, s2rd3;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm0;
   assign tm0 = 0;

shiftRegFIFO #(4, 1) shiftFIFO_80826(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80827(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem2(x2, t2, {inFlip0, s1wr0}, {outFlip0, s1rd2}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem3(x3, t3, {inFlip0, s1wr0}, {outFlip0, s1rd3}, s1wr_en, clk);

shiftRegFIFO #(7, 1) shiftFIFO_80836(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(5, 1) shiftFIFO_80837(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(8, 1) shiftFIFO_80838(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80839(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(7, 1) shiftFIFO_80842(.X(tm0), .Y(tm0_d), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_80845(.X(tm0_d), .Y(tm0_dd), .clk(clk));
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(4, 3) shiftFIFO_80850(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(5, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem2(s2, y2, {inFlip1, s2wr2}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem3(s3, y3, {inFlip1, s2wr3}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
	 s1wr0 <= 0;
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm0_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd0 <= 6;
	     {1'd0,  3'd1}: s1rd0 <= 7;
	     {1'd0,  3'd2}: s1rd0 <= 2;
	     {1'd0,  3'd3}: s1rd0 <= 3;
	     {1'd0,  3'd4}: s1rd0 <= 4;
	     {1'd0,  3'd5}: s1rd0 <= 5;
	     {1'd0,  3'd6}: s1rd0 <= 0;
	     {1'd0,  3'd7}: s1rd0 <= 1;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "distributed"
   always @(posedge clk) begin
      case({tm0_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd1 <= 2;
	     {1'd0,  3'd1}: s1rd1 <= 3;
	     {1'd0,  3'd2}: s1rd1 <= 6;
	     {1'd0,  3'd3}: s1rd1 <= 7;
	     {1'd0,  3'd4}: s1rd1 <= 0;
	     {1'd0,  3'd5}: s1rd1 <= 1;
	     {1'd0,  3'd6}: s1rd1 <= 4;
	     {1'd0,  3'd7}: s1rd1 <= 5;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "distributed"
   always @(posedge clk) begin
      case({tm0_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd2 <= 4;
	     {1'd0,  3'd1}: s1rd2 <= 5;
	     {1'd0,  3'd2}: s1rd2 <= 0;
	     {1'd0,  3'd3}: s1rd2 <= 1;
	     {1'd0,  3'd4}: s1rd2 <= 6;
	     {1'd0,  3'd5}: s1rd2 <= 7;
	     {1'd0,  3'd6}: s1rd2 <= 2;
	     {1'd0,  3'd7}: s1rd2 <= 3;
      endcase      
   end

// synthesis attribute rom_style of s1rd2 is "distributed"
   always @(posedge clk) begin
      case({tm0_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd3 <= 0;
	     {1'd0,  3'd1}: s1rd3 <= 1;
	     {1'd0,  3'd2}: s1rd3 <= 4;
	     {1'd0,  3'd3}: s1rd3 <= 5;
	     {1'd0,  3'd4}: s1rd3 <= 2;
	     {1'd0,  3'd5}: s1rd3 <= 3;
	     {1'd0,  3'd6}: s1rd3 <= 6;
	     {1'd0,  3'd7}: s1rd3 <= 7;
      endcase      
   end

// synthesis attribute rom_style of s1rd3 is "distributed"
    swNet77643 sw(tm0_d, clk, muxCycle, t0, s0, t1, s1, t2, s2, t3, s3);

   always @(posedge clk) begin
      case({tm0_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr0 <= 6;
	      {1'd0, 3'd1}: s2wr0 <= 7;
	      {1'd0, 3'd2}: s2wr0 <= 2;
	      {1'd0, 3'd3}: s2wr0 <= 3;
	      {1'd0, 3'd4}: s2wr0 <= 4;
	      {1'd0, 3'd5}: s2wr0 <= 5;
	      {1'd0, 3'd6}: s2wr0 <= 0;
	      {1'd0, 3'd7}: s2wr0 <= 1;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "distributed"
   always @(posedge clk) begin
      case({tm0_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr1 <= 2;
	      {1'd0, 3'd1}: s2wr1 <= 3;
	      {1'd0, 3'd2}: s2wr1 <= 6;
	      {1'd0, 3'd3}: s2wr1 <= 7;
	      {1'd0, 3'd4}: s2wr1 <= 0;
	      {1'd0, 3'd5}: s2wr1 <= 1;
	      {1'd0, 3'd6}: s2wr1 <= 4;
	      {1'd0, 3'd7}: s2wr1 <= 5;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "distributed"
   always @(posedge clk) begin
      case({tm0_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr2 <= 4;
	      {1'd0, 3'd1}: s2wr2 <= 5;
	      {1'd0, 3'd2}: s2wr2 <= 0;
	      {1'd0, 3'd3}: s2wr2 <= 1;
	      {1'd0, 3'd4}: s2wr2 <= 6;
	      {1'd0, 3'd5}: s2wr2 <= 7;
	      {1'd0, 3'd6}: s2wr2 <= 2;
	      {1'd0, 3'd7}: s2wr2 <= 3;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr2 is "distributed"
   always @(posedge clk) begin
      case({tm0_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr3 <= 0;
	      {1'd0, 3'd1}: s2wr3 <= 1;
	      {1'd0, 3'd2}: s2wr3 <= 4;
	      {1'd0, 3'd3}: s2wr3 <= 5;
	      {1'd0, 3'd4}: s2wr3 <= 2;
	      {1'd0, 3'd5}: s2wr3 <= 3;
	      {1'd0, 3'd6}: s2wr3 <= 6;
	      {1'd0, 3'd7}: s2wr3 <= 7;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr3 is "distributed"
endmodule




module memMod(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is block

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 



module memMod_dist(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is distributed

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 

module shiftRegFIFO(X, Y, clk);
   parameter depth=1, width=1;

   output [width-1:0] Y;
   input  [width-1:0] X;
   input              clk;

   reg [width-1:0]    mem [depth-1:0];
   integer            index;

   assign Y = mem[depth-1];

   always @ (posedge clk) begin
      for(index=1;index<depth;index=index+1) begin
         mem[index] <= mem[index-1];
      end
      mem[0]<=X;
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock77647(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3,
   X4_in, Y4,
   X5_in, Y5,
   X6_in, Y6,
   X7_in, Y7);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   shiftRegFIFO #(1, 1) shiftFIFO_80853(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a410;
   wire signed [15:0] a411;
   wire signed [15:0] a412;
   wire signed [15:0] a413;
   wire signed [15:0] a418;
   wire signed [15:0] a419;
   wire signed [15:0] a420;
   wire signed [15:0] a421;
   wire signed [16:0] tm166;
   wire signed [16:0] tm167;
   wire signed [16:0] tm168;
   wire signed [16:0] tm169;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   wire signed [16:0] tm170;
   wire signed [16:0] tm171;
   wire signed [16:0] tm172;
   wire signed [16:0] tm173;
   wire signed [15:0] Y4;
   wire signed [15:0] Y5;
   wire signed [15:0] Y6;
   wire signed [15:0] Y7;
   wire signed [15:0] t281;
   wire signed [15:0] t282;
   wire signed [15:0] t283;
   wire signed [15:0] t284;
   wire signed [15:0] t285;
   wire signed [15:0] t286;
   wire signed [15:0] t287;
   wire signed [15:0] t288;


   assign a410 = X0;
   assign a411 = X2;
   assign a412 = X1;
   assign a413 = X3;
   assign a418 = X4;
   assign a419 = X6;
   assign a420 = X5;
   assign a421 = X7;
   assign Y0 = t281;
   assign Y1 = t282;
   assign Y2 = t283;
   assign Y3 = t284;
   assign Y4 = t285;
   assign Y5 = t286;
   assign Y6 = t287;
   assign Y7 = t288;
   assign t281 = tm166[16:1];
   assign t282 = tm167[16:1];
   assign t283 = tm168[16:1];
   assign t284 = tm169[16:1];
   assign t285 = tm170[16:1];
   assign t286 = tm171[16:1];
   assign t287 = tm172[16:1];
   assign t288 = tm173[16:1];

    addfxp #(17, 1) add77659(.a({{1{a410[15]}}, a410}), .b({{1{a411[15]}}, a411}), .clk(clk), .q(tm166));    // 0
    addfxp #(17, 1) add77674(.a({{1{a412[15]}}, a412}), .b({{1{a413[15]}}, a413}), .clk(clk), .q(tm167));    // 0
    subfxp #(17, 1) sub77689(.a({{1{a410[15]}}, a410}), .b({{1{a411[15]}}, a411}), .clk(clk), .q(tm168));    // 0
    subfxp #(17, 1) sub77704(.a({{1{a412[15]}}, a412}), .b({{1{a413[15]}}, a413}), .clk(clk), .q(tm169));    // 0
    addfxp #(17, 1) add77735(.a({{1{a418[15]}}, a418}), .b({{1{a419[15]}}, a419}), .clk(clk), .q(tm170));    // 0
    addfxp #(17, 1) add77750(.a({{1{a420[15]}}, a420}), .b({{1{a421[15]}}, a421}), .clk(clk), .q(tm171));    // 0
    subfxp #(17, 1) sub77765(.a({{1{a418[15]}}, a418}), .b({{1{a419[15]}}, a419}), .clk(clk), .q(tm172));    // 0
    subfxp #(17, 1) sub77780(.a({{1{a420[15]}}, a420}), .b({{1{a421[15]}}, a421}), .clk(clk), .q(tm173));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         X4 <= X4_in;
         X5 <= X5_in;
         X6 <= X6_in;
         X7 <= X7_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock77802(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3,
   X4_in, Y4,
   X5_in, Y5,
   X6_in, Y6,
   X7_in, Y7);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   shiftRegFIFO #(1, 1) shiftFIFO_80856(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a377;
   wire signed [15:0] a378;
   wire signed [15:0] a379;
   wire signed [15:0] a380;
   wire signed [15:0] a385;
   wire signed [15:0] a387;
   wire signed [15:0] a388;
   wire signed [15:0] a389;
   wire signed [16:0] tm174;
   wire signed [16:0] tm175;
   wire signed [16:0] tm176;
   wire signed [16:0] tm177;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   wire signed [16:0] tm178;
   wire signed [16:0] tm179;
   wire signed [16:0] tm180;
   wire signed [16:0] tm181;
   wire signed [15:0] Y4;
   wire signed [15:0] Y5;
   wire signed [15:0] Y6;
   wire signed [15:0] Y7;
   wire signed [15:0] t225;
   wire signed [15:0] t226;
   wire signed [15:0] t227;
   wire signed [15:0] t228;
   wire signed [15:0] t229;
   wire signed [15:0] t230;
   wire signed [15:0] t231;
   wire signed [15:0] t232;


   assign a377 = X0;
   assign a378 = X4;
   assign a379 = X1;
   assign a380 = X5;
   assign a385 = X2;
   assign a387 = X7;
   assign a388 = X3;
   assign a389 = X6;
   assign Y0 = t225;
   assign Y1 = t226;
   assign Y2 = t227;
   assign Y3 = t228;
   assign Y4 = t229;
   assign Y5 = t230;
   assign Y6 = t231;
   assign Y7 = t232;
   assign t225 = tm174[16:1];
   assign t226 = tm175[16:1];
   assign t227 = tm176[16:1];
   assign t228 = tm177[16:1];
   assign t229 = tm178[16:1];
   assign t230 = tm179[16:1];
   assign t231 = tm180[16:1];
   assign t232 = tm181[16:1];

    addfxp #(17, 1) add77814(.a({{1{a377[15]}}, a377}), .b({{1{a378[15]}}, a378}), .clk(clk), .q(tm174));    // 0
    addfxp #(17, 1) add77829(.a({{1{a379[15]}}, a379}), .b({{1{a380[15]}}, a380}), .clk(clk), .q(tm175));    // 0
    subfxp #(17, 1) sub77844(.a({{1{a377[15]}}, a377}), .b({{1{a378[15]}}, a378}), .clk(clk), .q(tm176));    // 0
    subfxp #(17, 1) sub77859(.a({{1{a379[15]}}, a379}), .b({{1{a380[15]}}, a380}), .clk(clk), .q(tm177));    // 0
    addfxp #(17, 1) add77890(.a({{1{a385[15]}}, a385}), .b({{1{a387[15]}}, a387}), .clk(clk), .q(tm178));    // 0
    subfxp #(17, 1) sub77905(.a({{1{a388[15]}}, a388}), .b({{1{a389[15]}}, a389}), .clk(clk), .q(tm179));    // 0
    subfxp #(17, 1) sub77920(.a({{1{a385[15]}}, a385}), .b({{1{a387[15]}}, a387}), .clk(clk), .q(tm180));    // 0
    addfxp #(17, 1) add77935(.a({{1{a388[15]}}, a388}), .b({{1{a389[15]}}, a389}), .clk(clk), .q(tm181));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         X4 <= X4_in;
         X5 <= X5_in;
         X6 <= X6_in;
         X7 <= X7_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 9
// Gap: 2
module rc77960(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3,
   X4, Y4,
   X5, Y5,
   X6, Y6,
   X7, Y7);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   wire [31:0] t2;
   wire [31:0] s2;
   assign t2 = {X4, X5};
   wire [31:0] t3;
   wire [31:0] s3;
   assign t3 = {X6, X7};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];
   assign Y4 = s2[31:16];
   assign Y5 = s2[15:0];
   assign Y6 = s3[31:16];
   assign Y7 = s3[15:0];

   perm77958 instPerm80857(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
    .x2(t2), .y2(s2),
    .x3(t3), .y3(s3),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet77958(itr, clk, ct
,       x0, y0
,       x1, y1
,       x2, y2
,       x3, y3
);

    parameter width = 32;

    input [0:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    input [width-1:0] x2;
    output reg [width-1:0] y2;
    input [width-1:0] x3;
    output reg [width-1:0] y3;
    wire [width-1:0] t0_0, t0_1, t0_2, t0_3;
    wire [width-1:0] t1_0, t1_1, t1_2, t1_3;
    wire [width-1:0] t2_0, t2_1, t2_2, t2_3;
    reg [width-1:0] t3_0, t3_1, t3_2, t3_3;
    wire [width-1:0] t4_0, t4_1, t4_2, t4_3;
    reg [width-1:0] t5_0, t5_1, t5_2, t5_3;

    reg [1:0] control;

    always @(posedge clk) begin
      case(ct)
        1'd0: control <= 2'b11;
        1'd1: control <= 2'b00;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [1:0] control0;
   reg [1:0] control1;
    always @(posedge clk) begin
       control0 <= control;
        control1 <= control0;
    end
    assign t0_0 = x0;
    assign t0_1 = x2;
    assign t0_2 = x1;
    assign t0_3 = x3;
     assign t1_0 = t0_0;
     assign t1_1 = t0_1;
     assign t1_2 = t0_2;
     assign t1_3 = t0_3;
    assign t2_0 = t1_0;
    assign t2_1 = t1_2;
    assign t2_2 = t1_1;
    assign t2_3 = t1_3;
   always @(posedge clk) begin
         t3_0 <= (control0[1] == 0) ? t2_0 : t2_1;
         t3_1 <= (control0[1] == 0) ? t2_1 : t2_0;
         t3_2 <= (control0[0] == 0) ? t2_2 : t2_3;
         t3_3 <= (control0[0] == 0) ? t2_3 : t2_2;
   end
    assign t4_0 = t3_0;
    assign t4_1 = t3_2;
    assign t4_2 = t3_1;
    assign t4_3 = t3_3;
   always @(posedge clk) begin
         t5_0 <= t4_0;
         t5_1 <= t4_1;
         t5_2 <= t4_2;
         t5_3 <= t4_3;
   end
    always @(posedge clk) begin
        y0 <= t5_0;
        y1 <= t5_2;
        y2 <= t5_1;
        y3 <= t5_3;
    end
endmodule

// Latency: 9
// Gap: 2
module perm77958(clk, next, reset, next_out,
   x0, y0,
   x1, y1,
   x2, y2,
   x3, y3);
   parameter width = 32;

   parameter depth = 2;

   parameter addrbits = 1;

   parameter muxbits = 2;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input [width-1:0]  x2;
   output [width-1:0]  y2;
   wire [width-1:0]  t2;
   wire [width-1:0]  s2;
   input [width-1:0]  x3;
   output [width-1:0]  y3;
   wire [width-1:0]  t3;
   wire [width-1:0]  s3;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg [addrbits-1:0] s1rd2, s2wr2, s2rd2;
   reg [addrbits-1:0] s1rd3, s2wr3, s2rd3;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm1;
   assign tm1 = 0;

shiftRegFIFO #(4, 1) shiftFIFO_80862(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80863(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem2(x2, t2, {inFlip0, s1wr0}, {outFlip0, s1rd2}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem3(x3, t3, {inFlip0, s1wr0}, {outFlip0, s1rd3}, s1wr_en, clk);

shiftRegFIFO #(1, 1) shiftFIFO_80872(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(5, 1) shiftFIFO_80873(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(2, 1) shiftFIFO_80874(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80875(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80878(.X(tm1), .Y(tm1_d), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_80881(.X(tm1_d), .Y(tm1_dd), .clk(clk));
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(4, 1) shiftFIFO_80886(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(5, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem2(s2, y2, {inFlip1, s2wr2}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem3(s3, y3, {inFlip1, s2wr3}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
	 s1wr0 <= 0;
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm1_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd0 <= 1;
	     {1'd0,  1'd1}: s1rd0 <= 0;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "distributed"
   always @(posedge clk) begin
      case({tm1_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd1 <= 0;
	     {1'd0,  1'd1}: s1rd1 <= 1;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "distributed"
   always @(posedge clk) begin
      case({tm1_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd2 <= 1;
	     {1'd0,  1'd1}: s1rd2 <= 0;
      endcase      
   end

// synthesis attribute rom_style of s1rd2 is "distributed"
   always @(posedge clk) begin
      case({tm1_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd3 <= 0;
	     {1'd0,  1'd1}: s1rd3 <= 1;
      endcase      
   end

// synthesis attribute rom_style of s1rd3 is "distributed"
    swNet77958 sw(tm1_d, clk, muxCycle, t0, s0, t1, s1, t2, s2, t3, s3);

   always @(posedge clk) begin
      case({tm1_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr0 <= 1;
	      {1'd0, 1'd1}: s2wr0 <= 0;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "distributed"
   always @(posedge clk) begin
      case({tm1_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr1 <= 0;
	      {1'd0, 1'd1}: s2wr1 <= 1;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "distributed"
   always @(posedge clk) begin
      case({tm1_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr2 <= 1;
	      {1'd0, 1'd1}: s2wr2 <= 0;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr2 is "distributed"
   always @(posedge clk) begin
      case({tm1_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr3 <= 0;
	      {1'd0, 1'd1}: s2wr3 <= 1;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr3 is "distributed"
endmodule


// Latency: 8
// Gap: 2
module DirSum_78317(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3,
      X4, Y4,
      X5, Y5,
      X6, Y6,
      X7, Y7);

   output next_out;
   input clk, reset, next;

   reg [0:0] i3;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   always @(posedge clk) begin
      if (reset == 1) begin
         i3 <= 0;
      end
      else begin
         if (next == 1)
            i3 <= 0;
         else if (i3 == 1)
            i3 <= 0;
         else
            i3 <= i3 + 1;
      end
   end

   codeBlock77963 codeBlockIsnt80887(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i3_in(i3),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3),
       .X4_in(X4), .Y4(Y4),
       .X5_in(X5), .Y5(Y5),
       .X6_in(X6), .Y6(Y6),
       .X7_in(X7), .Y7(Y7));

endmodule

module D18_78291(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h4000;
      1: out3 <= 16'h0;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



module D20_78299(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h2d41;
      1: out3 <= 16'hd2bf;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



module D22_78307(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h0;
      1: out3 <= 16'hc000;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



// Latency: 8
// Gap: 1
module codeBlock77963(clk, reset, next_in, next_out,
   i3_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3,
   X4_in, Y4,
   X5_in, Y5,
   X6_in, Y6,
   X7_in, Y7);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [0:0] i3_in;
   reg [0:0] i3;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   shiftRegFIFO #(7, 1) shiftFIFO_80890(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a341;
   reg signed [15:0] tm9;
   reg signed [15:0] tm42;
   wire signed [15:0] a345;
   wire signed [15:0] a322;
   wire signed [15:0] a348;
   wire signed [15:0] a326;
   wire signed [15:0] a349;
   wire signed [15:0] a350;
   wire signed [15:0] a353;
   wire signed [15:0] a334;
   wire signed [15:0] a356;
   wire signed [15:0] a338;
   wire signed [15:0] a357;
   wire signed [15:0] a358;
   reg signed [15:0] tm206;
   reg signed [15:0] tm210;
   reg signed [15:0] tm222;
   reg signed [15:0] tm230;
   reg signed [15:0] tm238;
   reg signed [15:0] tm245;
   reg signed [15:0] tm252;
   reg signed [15:0] tm259;
   wire signed [15:0] a342;
   wire signed [15:0] a343;
   reg signed [15:0] tm207;
   reg signed [15:0] tm211;
   reg signed [15:0] tm223;
   reg signed [15:0] tm231;
   reg signed [15:0] tm239;
   reg signed [15:0] tm246;
   reg signed [15:0] tm253;
   reg signed [15:0] tm260;
   wire signed [15:0] tm4;
   wire signed [15:0] a327;
   wire signed [15:0] tm5;
   wire signed [15:0] a329;
   wire signed [15:0] tm8;
   wire signed [15:0] a339;
   reg signed [15:0] tm208;
   reg signed [15:0] tm212;
   reg signed [15:0] tm224;
   reg signed [15:0] tm226;
   reg signed [15:0] tm232;
   reg signed [15:0] tm234;
   reg signed [15:0] tm240;
   reg signed [15:0] tm247;
   reg signed [15:0] tm254;
   reg signed [15:0] tm261;
   reg signed [15:0] tm33;
   reg signed [15:0] tm34;
   reg signed [15:0] tm41;
   reg signed [15:0] tm209;
   reg signed [15:0] tm213;
   reg signed [15:0] tm225;
   reg signed [15:0] tm227;
   reg signed [15:0] tm233;
   reg signed [15:0] tm235;
   reg signed [15:0] tm241;
   reg signed [15:0] tm248;
   reg signed [15:0] tm255;
   reg signed [15:0] tm262;
   reg signed [15:0] tm228;
   reg signed [15:0] tm236;
   reg signed [15:0] tm242;
   reg signed [15:0] tm249;
   reg signed [15:0] tm256;
   reg signed [15:0] tm263;
   wire signed [15:0] a328;
   wire signed [15:0] a330;
   wire signed [15:0] a331;
   wire signed [15:0] a332;
   wire signed [15:0] a340;
   wire signed [15:0] a344;
   reg signed [15:0] tm229;
   reg signed [15:0] tm237;
   reg signed [15:0] tm243;
   reg signed [15:0] tm250;
   reg signed [15:0] tm257;
   reg signed [15:0] tm264;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   wire signed [15:0] Y4;
   wire signed [15:0] Y5;
   wire signed [15:0] Y6;
   wire signed [15:0] Y7;
   reg signed [15:0] tm244;
   reg signed [15:0] tm251;
   reg signed [15:0] tm258;
   reg signed [15:0] tm265;

   wire signed [15:0] tm105;
   assign tm105 = 16'hd2bf;

   assign a341 = tm9;
   assign a345 = X0;
   assign a322 = a345;
   assign a348 = X1;
   assign a326 = a348;
   assign a349 = X2;
   assign a350 = X3;
   assign a353 = X4;
   assign a334 = a353;
   assign a356 = X5;
   assign a338 = a356;
   assign a357 = X6;
   assign a358 = X7;
   assign a327 = tm4;
   assign a329 = tm5;
   assign a339 = tm8;
   assign Y0 = tm244;
   assign Y1 = tm251;
   assign Y4 = tm258;
   assign Y5 = tm265;

   D18_78291 instD18inst0_78291(.addr(i3[0:0]), .out(tm4), .clk(clk));

   D20_78299 instD20inst0_78299(.addr(i3[0:0]), .out(tm8), .clk(clk));

   D22_78307 instD22inst0_78307(.addr(i3[0:0]), .out(tm5), .clk(clk));

    multfix #(16, 2) m78244(.a(tm42), .b(a358), .clk(clk), .q_sc(a342), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78262(.a(tm42), .b(a357), .clk(clk), .q_sc(a343), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78062(.a(tm33), .b(tm209), .clk(clk), .q_sc(a328), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78084(.a(tm34), .b(tm213), .clk(clk), .q_sc(a330), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78102(.a(tm34), .b(tm209), .clk(clk), .q_sc(a331), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78113(.a(tm33), .b(tm213), .clk(clk), .q_sc(a332), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78222(.a(tm41), .b(tm225), .clk(clk), .q_sc(a340), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78273(.a(tm41), .b(tm233), .clk(clk), .q_sc(a344), .q_unsc(), .rst(reset));
    subfxp #(16, 1) sub78091(.a(a328), .b(a330), .clk(clk), .q(Y2));    // 6
    addfxp #(16, 1) add78120(.a(a331), .b(a332), .clk(clk), .q(Y3));    // 6
    subfxp #(16, 1) sub78251(.a(a340), .b(tm229), .clk(clk), .q(Y6));    // 6
    addfxp #(16, 1) add78280(.a(tm237), .b(a344), .clk(clk), .q(Y7));    // 6


   always @(posedge clk) begin
      if (reset == 1) begin
         tm42 <= 0;
         tm42 <= 0;
         tm33 <= 0;
         tm209 <= 0;
         tm34 <= 0;
         tm213 <= 0;
         tm34 <= 0;
         tm209 <= 0;
         tm33 <= 0;
         tm213 <= 0;
         tm41 <= 0;
         tm225 <= 0;
         tm41 <= 0;
         tm233 <= 0;
      end
      else begin
         i3 <= i3_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         X4 <= X4_in;
         X5 <= X5_in;
         X6 <= X6_in;
         X7 <= X7_in;
         next <= next_in;
         tm9 <= tm105;
         tm42 <= a341;
         tm206 <= a349;
         tm210 <= a350;
         tm222 <= a357;
         tm230 <= a358;
         tm238 <= a322;
         tm245 <= a326;
         tm252 <= a334;
         tm259 <= a338;
         tm207 <= tm206;
         tm211 <= tm210;
         tm223 <= tm222;
         tm231 <= tm230;
         tm239 <= tm238;
         tm246 <= tm245;
         tm253 <= tm252;
         tm260 <= tm259;
         tm208 <= tm207;
         tm212 <= tm211;
         tm224 <= tm223;
         tm226 <= a342;
         tm232 <= tm231;
         tm234 <= a343;
         tm240 <= tm239;
         tm247 <= tm246;
         tm254 <= tm253;
         tm261 <= tm260;
         tm33 <= a327;
         tm34 <= a329;
         tm41 <= a339;
         tm209 <= tm208;
         tm213 <= tm212;
         tm225 <= tm224;
         tm227 <= tm226;
         tm233 <= tm232;
         tm235 <= tm234;
         tm241 <= tm240;
         tm248 <= tm247;
         tm255 <= tm254;
         tm262 <= tm261;
         tm228 <= tm227;
         tm236 <= tm235;
         tm242 <= tm241;
         tm249 <= tm248;
         tm256 <= tm255;
         tm263 <= tm262;
         tm229 <= tm228;
         tm237 <= tm236;
         tm243 <= tm242;
         tm250 <= tm249;
         tm257 <= tm256;
         tm264 <= tm263;
         tm244 <= tm243;
         tm251 <= tm250;
         tm258 <= tm257;
         tm265 <= tm264;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock78320(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3,
   X4_in, Y4,
   X5_in, Y5,
   X6_in, Y6,
   X7_in, Y7);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   shiftRegFIFO #(1, 1) shiftFIFO_80893(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a257;
   wire signed [15:0] a258;
   wire signed [15:0] a259;
   wire signed [15:0] a260;
   wire signed [15:0] a265;
   wire signed [15:0] a266;
   wire signed [15:0] a267;
   wire signed [15:0] a268;
   wire signed [16:0] tm182;
   wire signed [16:0] tm183;
   wire signed [16:0] tm184;
   wire signed [16:0] tm185;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   wire signed [16:0] tm186;
   wire signed [16:0] tm187;
   wire signed [16:0] tm188;
   wire signed [16:0] tm189;
   wire signed [15:0] Y4;
   wire signed [15:0] Y5;
   wire signed [15:0] Y6;
   wire signed [15:0] Y7;
   wire signed [15:0] t161;
   wire signed [15:0] t162;
   wire signed [15:0] t163;
   wire signed [15:0] t164;
   wire signed [15:0] t165;
   wire signed [15:0] t166;
   wire signed [15:0] t167;
   wire signed [15:0] t168;


   assign a257 = X0;
   assign a258 = X2;
   assign a259 = X1;
   assign a260 = X3;
   assign a265 = X4;
   assign a266 = X6;
   assign a267 = X5;
   assign a268 = X7;
   assign Y0 = t161;
   assign Y1 = t162;
   assign Y2 = t163;
   assign Y3 = t164;
   assign Y4 = t165;
   assign Y5 = t166;
   assign Y6 = t167;
   assign Y7 = t168;
   assign t161 = tm182[16:1];
   assign t162 = tm183[16:1];
   assign t163 = tm184[16:1];
   assign t164 = tm185[16:1];
   assign t165 = tm186[16:1];
   assign t166 = tm187[16:1];
   assign t167 = tm188[16:1];
   assign t168 = tm189[16:1];

    addfxp #(17, 1) add78332(.a({{1{a257[15]}}, a257}), .b({{1{a258[15]}}, a258}), .clk(clk), .q(tm182));    // 0
    addfxp #(17, 1) add78347(.a({{1{a259[15]}}, a259}), .b({{1{a260[15]}}, a260}), .clk(clk), .q(tm183));    // 0
    subfxp #(17, 1) sub78362(.a({{1{a257[15]}}, a257}), .b({{1{a258[15]}}, a258}), .clk(clk), .q(tm184));    // 0
    subfxp #(17, 1) sub78377(.a({{1{a259[15]}}, a259}), .b({{1{a260[15]}}, a260}), .clk(clk), .q(tm185));    // 0
    addfxp #(17, 1) add78408(.a({{1{a265[15]}}, a265}), .b({{1{a266[15]}}, a266}), .clk(clk), .q(tm186));    // 0
    addfxp #(17, 1) add78423(.a({{1{a267[15]}}, a267}), .b({{1{a268[15]}}, a268}), .clk(clk), .q(tm187));    // 0
    subfxp #(17, 1) sub78438(.a({{1{a265[15]}}, a265}), .b({{1{a266[15]}}, a266}), .clk(clk), .q(tm188));    // 0
    subfxp #(17, 1) sub78453(.a({{1{a267[15]}}, a267}), .b({{1{a268[15]}}, a268}), .clk(clk), .q(tm189));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         X4 <= X4_in;
         X5 <= X5_in;
         X6 <= X6_in;
         X7 <= X7_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 13
// Gap: 4
module rc78478(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3,
   X4, Y4,
   X5, Y5,
   X6, Y6,
   X7, Y7);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   wire [31:0] t2;
   wire [31:0] s2;
   assign t2 = {X4, X5};
   wire [31:0] t3;
   wire [31:0] s3;
   assign t3 = {X6, X7};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];
   assign Y4 = s2[31:16];
   assign Y5 = s2[15:0];
   assign Y6 = s3[31:16];
   assign Y7 = s3[15:0];

   perm78476 instPerm80894(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
    .x2(t2), .y2(s2),
    .x3(t3), .y3(s3),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet78476(itr, clk, ct
,       x0, y0
,       x1, y1
,       x2, y2
,       x3, y3
);

    parameter width = 32;

    input [1:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    input [width-1:0] x2;
    output reg [width-1:0] y2;
    input [width-1:0] x3;
    output reg [width-1:0] y3;
    wire [width-1:0] t0_0, t0_1, t0_2, t0_3;
    wire [width-1:0] t1_0, t1_1, t1_2, t1_3;
    wire [width-1:0] t2_0, t2_1, t2_2, t2_3;
    reg [width-1:0] t3_0, t3_1, t3_2, t3_3;
    wire [width-1:0] t4_0, t4_1, t4_2, t4_3;
    reg [width-1:0] t5_0, t5_1, t5_2, t5_3;

    reg [1:0] control;

    always @(posedge clk) begin
      case(ct)
        2'd0: control <= 2'b11;
        2'd1: control <= 2'b11;
        2'd2: control <= 2'b00;
        2'd3: control <= 2'b00;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [1:0] control0;
   reg [1:0] control1;
    always @(posedge clk) begin
       control0 <= control;
        control1 <= control0;
    end
    assign t0_0 = x0;
    assign t0_1 = x2;
    assign t0_2 = x1;
    assign t0_3 = x3;
     assign t1_0 = t0_0;
     assign t1_1 = t0_1;
     assign t1_2 = t0_2;
     assign t1_3 = t0_3;
    assign t2_0 = t1_0;
    assign t2_1 = t1_2;
    assign t2_2 = t1_1;
    assign t2_3 = t1_3;
   always @(posedge clk) begin
         t3_0 <= (control0[1] == 0) ? t2_0 : t2_1;
         t3_1 <= (control0[1] == 0) ? t2_1 : t2_0;
         t3_2 <= (control0[0] == 0) ? t2_2 : t2_3;
         t3_3 <= (control0[0] == 0) ? t2_3 : t2_2;
   end
    assign t4_0 = t3_0;
    assign t4_1 = t3_2;
    assign t4_2 = t3_1;
    assign t4_3 = t3_3;
   always @(posedge clk) begin
         t5_0 <= t4_0;
         t5_1 <= t4_1;
         t5_2 <= t4_2;
         t5_3 <= t4_3;
   end
    always @(posedge clk) begin
        y0 <= t5_0;
        y1 <= t5_2;
        y2 <= t5_1;
        y3 <= t5_3;
    end
endmodule

// Latency: 13
// Gap: 4
module perm78476(clk, next, reset, next_out,
   x0, y0,
   x1, y1,
   x2, y2,
   x3, y3);
   parameter width = 32;

   parameter depth = 4;

   parameter addrbits = 2;

   parameter muxbits = 2;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input [width-1:0]  x2;
   output [width-1:0]  y2;
   wire [width-1:0]  t2;
   wire [width-1:0]  s2;
   input [width-1:0]  x3;
   output [width-1:0]  y3;
   wire [width-1:0]  t3;
   wire [width-1:0]  s3;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg [addrbits-1:0] s1rd2, s2wr2, s2rd2;
   reg [addrbits-1:0] s1rd3, s2wr3, s2rd3;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm10;
   assign tm10 = 0;

shiftRegFIFO #(4, 1) shiftFIFO_80899(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80900(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem2(x2, t2, {inFlip0, s1wr0}, {outFlip0, s1rd2}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem3(x3, t3, {inFlip0, s1wr0}, {outFlip0, s1rd3}, s1wr_en, clk);

shiftRegFIFO #(3, 1) shiftFIFO_80909(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(5, 1) shiftFIFO_80910(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_80911(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80912(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_80915(.X(tm10), .Y(tm10_d), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_80918(.X(tm10_d), .Y(tm10_dd), .clk(clk));
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(4, 2) shiftFIFO_80923(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(5, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem2(s2, y2, {inFlip1, s2wr2}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem3(s3, y3, {inFlip1, s2wr3}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
	 s1wr0 <= 0;
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm10_d, s1rdloc})
	     {1'd0,  2'd0}: s1rd0 <= 2;
	     {1'd0,  2'd1}: s1rd0 <= 3;
	     {1'd0,  2'd2}: s1rd0 <= 0;
	     {1'd0,  2'd3}: s1rd0 <= 1;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "distributed"
   always @(posedge clk) begin
      case({tm10_d, s1rdloc})
	     {1'd0,  2'd0}: s1rd1 <= 0;
	     {1'd0,  2'd1}: s1rd1 <= 1;
	     {1'd0,  2'd2}: s1rd1 <= 2;
	     {1'd0,  2'd3}: s1rd1 <= 3;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "distributed"
   always @(posedge clk) begin
      case({tm10_d, s1rdloc})
	     {1'd0,  2'd0}: s1rd2 <= 2;
	     {1'd0,  2'd1}: s1rd2 <= 3;
	     {1'd0,  2'd2}: s1rd2 <= 0;
	     {1'd0,  2'd3}: s1rd2 <= 1;
      endcase      
   end

// synthesis attribute rom_style of s1rd2 is "distributed"
   always @(posedge clk) begin
      case({tm10_d, s1rdloc})
	     {1'd0,  2'd0}: s1rd3 <= 0;
	     {1'd0,  2'd1}: s1rd3 <= 1;
	     {1'd0,  2'd2}: s1rd3 <= 2;
	     {1'd0,  2'd3}: s1rd3 <= 3;
      endcase      
   end

// synthesis attribute rom_style of s1rd3 is "distributed"
    swNet78476 sw(tm10_d, clk, muxCycle, t0, s0, t1, s1, t2, s2, t3, s3);

   always @(posedge clk) begin
      case({tm10_dd, writeCycle})
	      {1'd0, 2'd0}: s2wr0 <= 2;
	      {1'd0, 2'd1}: s2wr0 <= 3;
	      {1'd0, 2'd2}: s2wr0 <= 0;
	      {1'd0, 2'd3}: s2wr0 <= 1;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "distributed"
   always @(posedge clk) begin
      case({tm10_dd, writeCycle})
	      {1'd0, 2'd0}: s2wr1 <= 0;
	      {1'd0, 2'd1}: s2wr1 <= 1;
	      {1'd0, 2'd2}: s2wr1 <= 2;
	      {1'd0, 2'd3}: s2wr1 <= 3;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "distributed"
   always @(posedge clk) begin
      case({tm10_dd, writeCycle})
	      {1'd0, 2'd0}: s2wr2 <= 2;
	      {1'd0, 2'd1}: s2wr2 <= 3;
	      {1'd0, 2'd2}: s2wr2 <= 0;
	      {1'd0, 2'd3}: s2wr2 <= 1;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr2 is "distributed"
   always @(posedge clk) begin
      case({tm10_dd, writeCycle})
	      {1'd0, 2'd0}: s2wr3 <= 0;
	      {1'd0, 2'd1}: s2wr3 <= 1;
	      {1'd0, 2'd2}: s2wr3 <= 2;
	      {1'd0, 2'd3}: s2wr3 <= 3;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr3 is "distributed"
endmodule


// Latency: 8
// Gap: 4
module DirSum_78851(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3,
      X4, Y4,
      X5, Y5,
      X6, Y6,
      X7, Y7);

   output next_out;
   input clk, reset, next;

   reg [1:0] i2;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   always @(posedge clk) begin
      if (reset == 1) begin
         i2 <= 0;
      end
      else begin
         if (next == 1)
            i2 <= 0;
         else if (i2 == 3)
            i2 <= 0;
         else
            i2 <= i2 + 1;
      end
   end

   codeBlock78481 codeBlockIsnt80924(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i2_in(i2),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3),
       .X4_in(X4), .Y4(Y4),
       .X5_in(X5), .Y5(Y5),
       .X6_in(X6), .Y6(Y6),
       .X7_in(X7), .Y7(Y7));

endmodule

module D10_78813(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [1:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h4000;
      1: out3 <= 16'h2d41;
      2: out3 <= 16'h0;
      3: out3 <= 16'hd2bf;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



module D12_78825(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [1:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h3b21;
      1: out3 <= 16'h187e;
      2: out3 <= 16'he782;
      3: out3 <= 16'hc4df;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



module D14_78837(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [1:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h0;
      1: out3 <= 16'hd2bf;
      2: out3 <= 16'hc000;
      3: out3 <= 16'hd2bf;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



module D16_78849(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [1:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'he782;
      1: out3 <= 16'hc4df;
      2: out3 <= 16'hc4df;
      3: out3 <= 16'he782;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



// Latency: 8
// Gap: 1
module codeBlock78481(clk, reset, next_in, next_out,
   i2_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3,
   X4_in, Y4,
   X5_in, Y5,
   X6_in, Y6,
   X7_in, Y7);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [1:0] i2_in;
   reg [1:0] i2;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   shiftRegFIFO #(7, 1) shiftFIFO_80927(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a225;
   wire signed [15:0] a202;
   wire signed [15:0] a228;
   wire signed [15:0] a206;
   wire signed [15:0] a229;
   wire signed [15:0] a230;
   wire signed [15:0] a233;
   wire signed [15:0] a214;
   wire signed [15:0] a236;
   wire signed [15:0] a218;
   wire signed [15:0] a237;
   wire signed [15:0] a238;
   reg signed [15:0] tm266;
   reg signed [15:0] tm270;
   reg signed [15:0] tm282;
   reg signed [15:0] tm286;
   reg signed [15:0] tm298;
   reg signed [15:0] tm305;
   reg signed [15:0] tm312;
   reg signed [15:0] tm319;
   reg signed [15:0] tm267;
   reg signed [15:0] tm271;
   reg signed [15:0] tm283;
   reg signed [15:0] tm287;
   reg signed [15:0] tm299;
   reg signed [15:0] tm306;
   reg signed [15:0] tm313;
   reg signed [15:0] tm320;
   wire signed [15:0] tm13;
   wire signed [15:0] a207;
   wire signed [15:0] tm14;
   wire signed [15:0] a209;
   wire signed [15:0] tm17;
   wire signed [15:0] a219;
   wire signed [15:0] tm18;
   wire signed [15:0] a221;
   reg signed [15:0] tm268;
   reg signed [15:0] tm272;
   reg signed [15:0] tm284;
   reg signed [15:0] tm288;
   reg signed [15:0] tm300;
   reg signed [15:0] tm307;
   reg signed [15:0] tm314;
   reg signed [15:0] tm321;
   reg signed [15:0] tm49;
   reg signed [15:0] tm50;
   reg signed [15:0] tm57;
   reg signed [15:0] tm58;
   reg signed [15:0] tm269;
   reg signed [15:0] tm273;
   reg signed [15:0] tm285;
   reg signed [15:0] tm289;
   reg signed [15:0] tm301;
   reg signed [15:0] tm308;
   reg signed [15:0] tm315;
   reg signed [15:0] tm322;
   reg signed [15:0] tm302;
   reg signed [15:0] tm309;
   reg signed [15:0] tm316;
   reg signed [15:0] tm323;
   wire signed [15:0] a208;
   wire signed [15:0] a210;
   wire signed [15:0] a211;
   wire signed [15:0] a212;
   wire signed [15:0] a220;
   wire signed [15:0] a222;
   wire signed [15:0] a223;
   wire signed [15:0] a224;
   reg signed [15:0] tm303;
   reg signed [15:0] tm310;
   reg signed [15:0] tm317;
   reg signed [15:0] tm324;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   wire signed [15:0] Y4;
   wire signed [15:0] Y5;
   wire signed [15:0] Y6;
   wire signed [15:0] Y7;
   reg signed [15:0] tm304;
   reg signed [15:0] tm311;
   reg signed [15:0] tm318;
   reg signed [15:0] tm325;


   assign a225 = X0;
   assign a202 = a225;
   assign a228 = X1;
   assign a206 = a228;
   assign a229 = X2;
   assign a230 = X3;
   assign a233 = X4;
   assign a214 = a233;
   assign a236 = X5;
   assign a218 = a236;
   assign a237 = X6;
   assign a238 = X7;
   assign a207 = tm13;
   assign a209 = tm14;
   assign a219 = tm17;
   assign a221 = tm18;
   assign Y0 = tm304;
   assign Y1 = tm311;
   assign Y4 = tm318;
   assign Y5 = tm325;

   D10_78813 instD10inst0_78813(.addr(i2[1:0]), .out(tm13), .clk(clk));

   D12_78825 instD12inst0_78825(.addr(i2[1:0]), .out(tm17), .clk(clk));

   D14_78837 instD14inst0_78837(.addr(i2[1:0]), .out(tm14), .clk(clk));

   D16_78849 instD16inst0_78849(.addr(i2[1:0]), .out(tm18), .clk(clk));

    multfix #(16, 2) m78580(.a(tm49), .b(tm269), .clk(clk), .q_sc(a208), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78602(.a(tm50), .b(tm273), .clk(clk), .q_sc(a210), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78620(.a(tm50), .b(tm269), .clk(clk), .q_sc(a211), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78631(.a(tm49), .b(tm273), .clk(clk), .q_sc(a212), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78740(.a(tm57), .b(tm285), .clk(clk), .q_sc(a220), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78762(.a(tm58), .b(tm289), .clk(clk), .q_sc(a222), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78780(.a(tm58), .b(tm285), .clk(clk), .q_sc(a223), .q_unsc(), .rst(reset));
    multfix #(16, 2) m78791(.a(tm57), .b(tm289), .clk(clk), .q_sc(a224), .q_unsc(), .rst(reset));
    subfxp #(16, 1) sub78609(.a(a208), .b(a210), .clk(clk), .q(Y2));    // 6
    addfxp #(16, 1) add78638(.a(a211), .b(a212), .clk(clk), .q(Y3));    // 6
    subfxp #(16, 1) sub78769(.a(a220), .b(a222), .clk(clk), .q(Y6));    // 6
    addfxp #(16, 1) add78798(.a(a223), .b(a224), .clk(clk), .q(Y7));    // 6


   always @(posedge clk) begin
      if (reset == 1) begin
         tm49 <= 0;
         tm269 <= 0;
         tm50 <= 0;
         tm273 <= 0;
         tm50 <= 0;
         tm269 <= 0;
         tm49 <= 0;
         tm273 <= 0;
         tm57 <= 0;
         tm285 <= 0;
         tm58 <= 0;
         tm289 <= 0;
         tm58 <= 0;
         tm285 <= 0;
         tm57 <= 0;
         tm289 <= 0;
      end
      else begin
         i2 <= i2_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         X4 <= X4_in;
         X5 <= X5_in;
         X6 <= X6_in;
         X7 <= X7_in;
         next <= next_in;
         tm266 <= a229;
         tm270 <= a230;
         tm282 <= a237;
         tm286 <= a238;
         tm298 <= a202;
         tm305 <= a206;
         tm312 <= a214;
         tm319 <= a218;
         tm267 <= tm266;
         tm271 <= tm270;
         tm283 <= tm282;
         tm287 <= tm286;
         tm299 <= tm298;
         tm306 <= tm305;
         tm313 <= tm312;
         tm320 <= tm319;
         tm268 <= tm267;
         tm272 <= tm271;
         tm284 <= tm283;
         tm288 <= tm287;
         tm300 <= tm299;
         tm307 <= tm306;
         tm314 <= tm313;
         tm321 <= tm320;
         tm49 <= a207;
         tm50 <= a209;
         tm57 <= a219;
         tm58 <= a221;
         tm269 <= tm268;
         tm273 <= tm272;
         tm285 <= tm284;
         tm289 <= tm288;
         tm301 <= tm300;
         tm308 <= tm307;
         tm315 <= tm314;
         tm322 <= tm321;
         tm302 <= tm301;
         tm309 <= tm308;
         tm316 <= tm315;
         tm323 <= tm322;
         tm303 <= tm302;
         tm310 <= tm309;
         tm317 <= tm316;
         tm324 <= tm323;
         tm304 <= tm303;
         tm311 <= tm310;
         tm318 <= tm317;
         tm325 <= tm324;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock78854(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3,
   X4_in, Y4,
   X5_in, Y5,
   X6_in, Y6,
   X7_in, Y7);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   shiftRegFIFO #(1, 1) shiftFIFO_80930(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a137;
   wire signed [15:0] a138;
   wire signed [15:0] a139;
   wire signed [15:0] a140;
   wire signed [15:0] a145;
   wire signed [15:0] a146;
   wire signed [15:0] a147;
   wire signed [15:0] a148;
   wire signed [16:0] tm190;
   wire signed [16:0] tm191;
   wire signed [16:0] tm192;
   wire signed [16:0] tm193;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   wire signed [16:0] tm194;
   wire signed [16:0] tm195;
   wire signed [16:0] tm196;
   wire signed [16:0] tm197;
   wire signed [15:0] Y4;
   wire signed [15:0] Y5;
   wire signed [15:0] Y6;
   wire signed [15:0] Y7;
   wire signed [15:0] t105;
   wire signed [15:0] t106;
   wire signed [15:0] t107;
   wire signed [15:0] t108;
   wire signed [15:0] t109;
   wire signed [15:0] t110;
   wire signed [15:0] t111;
   wire signed [15:0] t112;


   assign a137 = X0;
   assign a138 = X2;
   assign a139 = X1;
   assign a140 = X3;
   assign a145 = X4;
   assign a146 = X6;
   assign a147 = X5;
   assign a148 = X7;
   assign Y0 = t105;
   assign Y1 = t106;
   assign Y2 = t107;
   assign Y3 = t108;
   assign Y4 = t109;
   assign Y5 = t110;
   assign Y6 = t111;
   assign Y7 = t112;
   assign t105 = tm190[16:1];
   assign t106 = tm191[16:1];
   assign t107 = tm192[16:1];
   assign t108 = tm193[16:1];
   assign t109 = tm194[16:1];
   assign t110 = tm195[16:1];
   assign t111 = tm196[16:1];
   assign t112 = tm197[16:1];

    addfxp #(17, 1) add78866(.a({{1{a137[15]}}, a137}), .b({{1{a138[15]}}, a138}), .clk(clk), .q(tm190));    // 0
    addfxp #(17, 1) add78881(.a({{1{a139[15]}}, a139}), .b({{1{a140[15]}}, a140}), .clk(clk), .q(tm191));    // 0
    subfxp #(17, 1) sub78896(.a({{1{a137[15]}}, a137}), .b({{1{a138[15]}}, a138}), .clk(clk), .q(tm192));    // 0
    subfxp #(17, 1) sub78911(.a({{1{a139[15]}}, a139}), .b({{1{a140[15]}}, a140}), .clk(clk), .q(tm193));    // 0
    addfxp #(17, 1) add78942(.a({{1{a145[15]}}, a145}), .b({{1{a146[15]}}, a146}), .clk(clk), .q(tm194));    // 0
    addfxp #(17, 1) add78957(.a({{1{a147[15]}}, a147}), .b({{1{a148[15]}}, a148}), .clk(clk), .q(tm195));    // 0
    subfxp #(17, 1) sub78972(.a({{1{a145[15]}}, a145}), .b({{1{a146[15]}}, a146}), .clk(clk), .q(tm196));    // 0
    subfxp #(17, 1) sub78987(.a({{1{a147[15]}}, a147}), .b({{1{a148[15]}}, a148}), .clk(clk), .q(tm197));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         X4 <= X4_in;
         X5 <= X5_in;
         X6 <= X6_in;
         X7 <= X7_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 21
// Gap: 8
module rc79012(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3,
   X4, Y4,
   X5, Y5,
   X6, Y6,
   X7, Y7);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   wire [31:0] t2;
   wire [31:0] s2;
   assign t2 = {X4, X5};
   wire [31:0] t3;
   wire [31:0] s3;
   assign t3 = {X6, X7};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];
   assign Y4 = s2[31:16];
   assign Y5 = s2[15:0];
   assign Y6 = s3[31:16];
   assign Y7 = s3[15:0];

   perm79010 instPerm80931(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
    .x2(t2), .y2(s2),
    .x3(t3), .y3(s3),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet79010(itr, clk, ct
,       x0, y0
,       x1, y1
,       x2, y2
,       x3, y3
);

    parameter width = 32;

    input [2:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    input [width-1:0] x2;
    output reg [width-1:0] y2;
    input [width-1:0] x3;
    output reg [width-1:0] y3;
    wire [width-1:0] t0_0, t0_1, t0_2, t0_3;
    wire [width-1:0] t1_0, t1_1, t1_2, t1_3;
    wire [width-1:0] t2_0, t2_1, t2_2, t2_3;
    reg [width-1:0] t3_0, t3_1, t3_2, t3_3;
    wire [width-1:0] t4_0, t4_1, t4_2, t4_3;
    reg [width-1:0] t5_0, t5_1, t5_2, t5_3;

    reg [1:0] control;

    always @(posedge clk) begin
      case(ct)
        3'd0: control <= 2'b11;
        3'd1: control <= 2'b11;
        3'd2: control <= 2'b11;
        3'd3: control <= 2'b11;
        3'd4: control <= 2'b00;
        3'd5: control <= 2'b00;
        3'd6: control <= 2'b00;
        3'd7: control <= 2'b00;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [1:0] control0;
   reg [1:0] control1;
    always @(posedge clk) begin
       control0 <= control;
        control1 <= control0;
    end
    assign t0_0 = x0;
    assign t0_1 = x2;
    assign t0_2 = x1;
    assign t0_3 = x3;
     assign t1_0 = t0_0;
     assign t1_1 = t0_1;
     assign t1_2 = t0_2;
     assign t1_3 = t0_3;
    assign t2_0 = t1_0;
    assign t2_1 = t1_2;
    assign t2_2 = t1_1;
    assign t2_3 = t1_3;
   always @(posedge clk) begin
         t3_0 <= (control0[1] == 0) ? t2_0 : t2_1;
         t3_1 <= (control0[1] == 0) ? t2_1 : t2_0;
         t3_2 <= (control0[0] == 0) ? t2_2 : t2_3;
         t3_3 <= (control0[0] == 0) ? t2_3 : t2_2;
   end
    assign t4_0 = t3_0;
    assign t4_1 = t3_2;
    assign t4_2 = t3_1;
    assign t4_3 = t3_3;
   always @(posedge clk) begin
         t5_0 <= t4_0;
         t5_1 <= t4_1;
         t5_2 <= t4_2;
         t5_3 <= t4_3;
   end
    always @(posedge clk) begin
        y0 <= t5_0;
        y1 <= t5_2;
        y2 <= t5_1;
        y3 <= t5_3;
    end
endmodule

// Latency: 21
// Gap: 8
module perm79010(clk, next, reset, next_out,
   x0, y0,
   x1, y1,
   x2, y2,
   x3, y3);
   parameter width = 32;

   parameter depth = 8;

   parameter addrbits = 3;

   parameter muxbits = 2;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input [width-1:0]  x2;
   output [width-1:0]  y2;
   wire [width-1:0]  t2;
   wire [width-1:0]  s2;
   input [width-1:0]  x3;
   output [width-1:0]  y3;
   wire [width-1:0]  t3;
   wire [width-1:0]  s3;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg [addrbits-1:0] s1rd2, s2wr2, s2rd2;
   reg [addrbits-1:0] s1rd3, s2wr3, s2rd3;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm19;
   assign tm19 = 0;

shiftRegFIFO #(4, 1) shiftFIFO_80936(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80937(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem2(x2, t2, {inFlip0, s1wr0}, {outFlip0, s1rd2}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem3(x3, t3, {inFlip0, s1wr0}, {outFlip0, s1rd3}, s1wr_en, clk);

shiftRegFIFO #(7, 1) shiftFIFO_80946(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(5, 1) shiftFIFO_80947(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(8, 1) shiftFIFO_80948(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80949(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(7, 1) shiftFIFO_80952(.X(tm19), .Y(tm19_d), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_80955(.X(tm19_d), .Y(tm19_dd), .clk(clk));
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(4, 3) shiftFIFO_80960(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(5, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem2(s2, y2, {inFlip1, s2wr2}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem3(s3, y3, {inFlip1, s2wr3}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
	 s1wr0 <= 0;
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm19_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd0 <= 4;
	     {1'd0,  3'd1}: s1rd0 <= 5;
	     {1'd0,  3'd2}: s1rd0 <= 6;
	     {1'd0,  3'd3}: s1rd0 <= 7;
	     {1'd0,  3'd4}: s1rd0 <= 0;
	     {1'd0,  3'd5}: s1rd0 <= 1;
	     {1'd0,  3'd6}: s1rd0 <= 2;
	     {1'd0,  3'd7}: s1rd0 <= 3;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "distributed"
   always @(posedge clk) begin
      case({tm19_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd1 <= 0;
	     {1'd0,  3'd1}: s1rd1 <= 1;
	     {1'd0,  3'd2}: s1rd1 <= 2;
	     {1'd0,  3'd3}: s1rd1 <= 3;
	     {1'd0,  3'd4}: s1rd1 <= 4;
	     {1'd0,  3'd5}: s1rd1 <= 5;
	     {1'd0,  3'd6}: s1rd1 <= 6;
	     {1'd0,  3'd7}: s1rd1 <= 7;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "distributed"
   always @(posedge clk) begin
      case({tm19_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd2 <= 4;
	     {1'd0,  3'd1}: s1rd2 <= 5;
	     {1'd0,  3'd2}: s1rd2 <= 6;
	     {1'd0,  3'd3}: s1rd2 <= 7;
	     {1'd0,  3'd4}: s1rd2 <= 0;
	     {1'd0,  3'd5}: s1rd2 <= 1;
	     {1'd0,  3'd6}: s1rd2 <= 2;
	     {1'd0,  3'd7}: s1rd2 <= 3;
      endcase      
   end

// synthesis attribute rom_style of s1rd2 is "distributed"
   always @(posedge clk) begin
      case({tm19_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd3 <= 0;
	     {1'd0,  3'd1}: s1rd3 <= 1;
	     {1'd0,  3'd2}: s1rd3 <= 2;
	     {1'd0,  3'd3}: s1rd3 <= 3;
	     {1'd0,  3'd4}: s1rd3 <= 4;
	     {1'd0,  3'd5}: s1rd3 <= 5;
	     {1'd0,  3'd6}: s1rd3 <= 6;
	     {1'd0,  3'd7}: s1rd3 <= 7;
      endcase      
   end

// synthesis attribute rom_style of s1rd3 is "distributed"
    swNet79010 sw(tm19_d, clk, muxCycle, t0, s0, t1, s1, t2, s2, t3, s3);

   always @(posedge clk) begin
      case({tm19_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr0 <= 4;
	      {1'd0, 3'd1}: s2wr0 <= 5;
	      {1'd0, 3'd2}: s2wr0 <= 6;
	      {1'd0, 3'd3}: s2wr0 <= 7;
	      {1'd0, 3'd4}: s2wr0 <= 0;
	      {1'd0, 3'd5}: s2wr0 <= 1;
	      {1'd0, 3'd6}: s2wr0 <= 2;
	      {1'd0, 3'd7}: s2wr0 <= 3;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "distributed"
   always @(posedge clk) begin
      case({tm19_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr1 <= 0;
	      {1'd0, 3'd1}: s2wr1 <= 1;
	      {1'd0, 3'd2}: s2wr1 <= 2;
	      {1'd0, 3'd3}: s2wr1 <= 3;
	      {1'd0, 3'd4}: s2wr1 <= 4;
	      {1'd0, 3'd5}: s2wr1 <= 5;
	      {1'd0, 3'd6}: s2wr1 <= 6;
	      {1'd0, 3'd7}: s2wr1 <= 7;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "distributed"
   always @(posedge clk) begin
      case({tm19_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr2 <= 4;
	      {1'd0, 3'd1}: s2wr2 <= 5;
	      {1'd0, 3'd2}: s2wr2 <= 6;
	      {1'd0, 3'd3}: s2wr2 <= 7;
	      {1'd0, 3'd4}: s2wr2 <= 0;
	      {1'd0, 3'd5}: s2wr2 <= 1;
	      {1'd0, 3'd6}: s2wr2 <= 2;
	      {1'd0, 3'd7}: s2wr2 <= 3;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr2 is "distributed"
   always @(posedge clk) begin
      case({tm19_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr3 <= 0;
	      {1'd0, 3'd1}: s2wr3 <= 1;
	      {1'd0, 3'd2}: s2wr3 <= 2;
	      {1'd0, 3'd3}: s2wr3 <= 3;
	      {1'd0, 3'd4}: s2wr3 <= 4;
	      {1'd0, 3'd5}: s2wr3 <= 5;
	      {1'd0, 3'd6}: s2wr3 <= 6;
	      {1'd0, 3'd7}: s2wr3 <= 7;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr3 is "distributed"
endmodule


// Latency: 8
// Gap: 8
module DirSum_79416(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3,
      X4, Y4,
      X5, Y5,
      X6, Y6,
      X7, Y7);

   output next_out;
   input clk, reset, next;

   reg [2:0] i1;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   always @(posedge clk) begin
      if (reset == 1) begin
         i1 <= 0;
      end
      else begin
         if (next == 1)
            i1 <= 0;
         else if (i1 == 7)
            i1 <= 0;
         else
            i1 <= i1 + 1;
      end
   end

   codeBlock79014 codeBlockIsnt80961(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i1_in(i1),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3),
       .X4_in(X4), .Y4(Y4),
       .X5_in(X5), .Y5(Y5),
       .X6_in(X6), .Y6(Y6),
       .X7_in(X7), .Y7(Y7));

endmodule

module D2_79354(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [2:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h4000;
      1: out3 <= 16'h3b21;
      2: out3 <= 16'h2d41;
      3: out3 <= 16'h187e;
      4: out3 <= 16'h0;
      5: out3 <= 16'he782;
      6: out3 <= 16'hd2bf;
      7: out3 <= 16'hc4df;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



module D4_79374(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [2:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h3ec5;
      1: out3 <= 16'h3537;
      2: out3 <= 16'h238e;
      3: out3 <= 16'hc7c;
      4: out3 <= 16'hf384;
      5: out3 <= 16'hdc72;
      6: out3 <= 16'hcac9;
      7: out3 <= 16'hc13b;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



module D6_79394(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [2:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h0;
      1: out3 <= 16'he782;
      2: out3 <= 16'hd2bf;
      3: out3 <= 16'hc4df;
      4: out3 <= 16'hc000;
      5: out3 <= 16'hc4df;
      6: out3 <= 16'hd2bf;
      7: out3 <= 16'he782;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



module D8_79414(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [2:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'hf384;
      1: out3 <= 16'hdc72;
      2: out3 <= 16'hcac9;
      3: out3 <= 16'hc13b;
      4: out3 <= 16'hc13b;
      5: out3 <= 16'hcac9;
      6: out3 <= 16'hdc72;
      7: out3 <= 16'hf384;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



// Latency: 8
// Gap: 1
module codeBlock79014(clk, reset, next_in, next_out,
   i1_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3,
   X4_in, Y4,
   X5_in, Y5,
   X6_in, Y6,
   X7_in, Y7);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [2:0] i1_in;
   reg [2:0] i1;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   shiftRegFIFO #(7, 1) shiftFIFO_80964(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a105;
   wire signed [15:0] a82;
   wire signed [15:0] a108;
   wire signed [15:0] a86;
   wire signed [15:0] a109;
   wire signed [15:0] a110;
   wire signed [15:0] a113;
   wire signed [15:0] a94;
   wire signed [15:0] a116;
   wire signed [15:0] a98;
   wire signed [15:0] a117;
   wire signed [15:0] a118;
   reg signed [15:0] tm326;
   reg signed [15:0] tm330;
   reg signed [15:0] tm342;
   reg signed [15:0] tm346;
   reg signed [15:0] tm358;
   reg signed [15:0] tm365;
   reg signed [15:0] tm372;
   reg signed [15:0] tm379;
   reg signed [15:0] tm327;
   reg signed [15:0] tm331;
   reg signed [15:0] tm343;
   reg signed [15:0] tm347;
   reg signed [15:0] tm359;
   reg signed [15:0] tm366;
   reg signed [15:0] tm373;
   reg signed [15:0] tm380;
   wire signed [15:0] tm22;
   wire signed [15:0] a87;
   wire signed [15:0] tm23;
   wire signed [15:0] a89;
   wire signed [15:0] tm26;
   wire signed [15:0] a99;
   wire signed [15:0] tm27;
   wire signed [15:0] a101;
   reg signed [15:0] tm328;
   reg signed [15:0] tm332;
   reg signed [15:0] tm344;
   reg signed [15:0] tm348;
   reg signed [15:0] tm360;
   reg signed [15:0] tm367;
   reg signed [15:0] tm374;
   reg signed [15:0] tm381;
   reg signed [15:0] tm65;
   reg signed [15:0] tm66;
   reg signed [15:0] tm73;
   reg signed [15:0] tm74;
   reg signed [15:0] tm329;
   reg signed [15:0] tm333;
   reg signed [15:0] tm345;
   reg signed [15:0] tm349;
   reg signed [15:0] tm361;
   reg signed [15:0] tm368;
   reg signed [15:0] tm375;
   reg signed [15:0] tm382;
   reg signed [15:0] tm362;
   reg signed [15:0] tm369;
   reg signed [15:0] tm376;
   reg signed [15:0] tm383;
   wire signed [15:0] a88;
   wire signed [15:0] a90;
   wire signed [15:0] a91;
   wire signed [15:0] a92;
   wire signed [15:0] a100;
   wire signed [15:0] a102;
   wire signed [15:0] a103;
   wire signed [15:0] a104;
   reg signed [15:0] tm363;
   reg signed [15:0] tm370;
   reg signed [15:0] tm377;
   reg signed [15:0] tm384;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   wire signed [15:0] Y4;
   wire signed [15:0] Y5;
   wire signed [15:0] Y6;
   wire signed [15:0] Y7;
   reg signed [15:0] tm364;
   reg signed [15:0] tm371;
   reg signed [15:0] tm378;
   reg signed [15:0] tm385;


   assign a105 = X0;
   assign a82 = a105;
   assign a108 = X1;
   assign a86 = a108;
   assign a109 = X2;
   assign a110 = X3;
   assign a113 = X4;
   assign a94 = a113;
   assign a116 = X5;
   assign a98 = a116;
   assign a117 = X6;
   assign a118 = X7;
   assign a87 = tm22;
   assign a89 = tm23;
   assign a99 = tm26;
   assign a101 = tm27;
   assign Y0 = tm364;
   assign Y1 = tm371;
   assign Y4 = tm378;
   assign Y5 = tm385;

   D2_79354 instD2inst0_79354(.addr(i1[2:0]), .out(tm22), .clk(clk));

   D4_79374 instD4inst0_79374(.addr(i1[2:0]), .out(tm26), .clk(clk));

   D6_79394 instD6inst0_79394(.addr(i1[2:0]), .out(tm23), .clk(clk));

   D8_79414 instD8inst0_79414(.addr(i1[2:0]), .out(tm27), .clk(clk));

    multfix #(16, 2) m79113(.a(tm65), .b(tm329), .clk(clk), .q_sc(a88), .q_unsc(), .rst(reset));
    multfix #(16, 2) m79135(.a(tm66), .b(tm333), .clk(clk), .q_sc(a90), .q_unsc(), .rst(reset));
    multfix #(16, 2) m79153(.a(tm66), .b(tm329), .clk(clk), .q_sc(a91), .q_unsc(), .rst(reset));
    multfix #(16, 2) m79164(.a(tm65), .b(tm333), .clk(clk), .q_sc(a92), .q_unsc(), .rst(reset));
    multfix #(16, 2) m79273(.a(tm73), .b(tm345), .clk(clk), .q_sc(a100), .q_unsc(), .rst(reset));
    multfix #(16, 2) m79295(.a(tm74), .b(tm349), .clk(clk), .q_sc(a102), .q_unsc(), .rst(reset));
    multfix #(16, 2) m79313(.a(tm74), .b(tm345), .clk(clk), .q_sc(a103), .q_unsc(), .rst(reset));
    multfix #(16, 2) m79324(.a(tm73), .b(tm349), .clk(clk), .q_sc(a104), .q_unsc(), .rst(reset));
    subfxp #(16, 1) sub79142(.a(a88), .b(a90), .clk(clk), .q(Y2));    // 6
    addfxp #(16, 1) add79171(.a(a91), .b(a92), .clk(clk), .q(Y3));    // 6
    subfxp #(16, 1) sub79302(.a(a100), .b(a102), .clk(clk), .q(Y6));    // 6
    addfxp #(16, 1) add79331(.a(a103), .b(a104), .clk(clk), .q(Y7));    // 6


   always @(posedge clk) begin
      if (reset == 1) begin
         tm65 <= 0;
         tm329 <= 0;
         tm66 <= 0;
         tm333 <= 0;
         tm66 <= 0;
         tm329 <= 0;
         tm65 <= 0;
         tm333 <= 0;
         tm73 <= 0;
         tm345 <= 0;
         tm74 <= 0;
         tm349 <= 0;
         tm74 <= 0;
         tm345 <= 0;
         tm73 <= 0;
         tm349 <= 0;
      end
      else begin
         i1 <= i1_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         X4 <= X4_in;
         X5 <= X5_in;
         X6 <= X6_in;
         X7 <= X7_in;
         next <= next_in;
         tm326 <= a109;
         tm330 <= a110;
         tm342 <= a117;
         tm346 <= a118;
         tm358 <= a82;
         tm365 <= a86;
         tm372 <= a94;
         tm379 <= a98;
         tm327 <= tm326;
         tm331 <= tm330;
         tm343 <= tm342;
         tm347 <= tm346;
         tm359 <= tm358;
         tm366 <= tm365;
         tm373 <= tm372;
         tm380 <= tm379;
         tm328 <= tm327;
         tm332 <= tm331;
         tm344 <= tm343;
         tm348 <= tm347;
         tm360 <= tm359;
         tm367 <= tm366;
         tm374 <= tm373;
         tm381 <= tm380;
         tm65 <= a87;
         tm66 <= a89;
         tm73 <= a99;
         tm74 <= a101;
         tm329 <= tm328;
         tm333 <= tm332;
         tm345 <= tm344;
         tm349 <= tm348;
         tm361 <= tm360;
         tm368 <= tm367;
         tm375 <= tm374;
         tm382 <= tm381;
         tm362 <= tm361;
         tm369 <= tm368;
         tm376 <= tm375;
         tm383 <= tm382;
         tm363 <= tm362;
         tm370 <= tm369;
         tm377 <= tm376;
         tm384 <= tm383;
         tm364 <= tm363;
         tm371 <= tm370;
         tm378 <= tm377;
         tm385 <= tm384;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock79419(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3,
   X4_in, Y4,
   X5_in, Y5,
   X6_in, Y6,
   X7_in, Y7);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   shiftRegFIFO #(1, 1) shiftFIFO_80967(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a17;
   wire signed [15:0] a18;
   wire signed [15:0] a19;
   wire signed [15:0] a20;
   wire signed [15:0] a25;
   wire signed [15:0] a26;
   wire signed [15:0] a27;
   wire signed [15:0] a28;
   wire signed [16:0] tm198;
   wire signed [16:0] tm199;
   wire signed [16:0] tm200;
   wire signed [16:0] tm201;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   wire signed [16:0] tm202;
   wire signed [16:0] tm203;
   wire signed [16:0] tm204;
   wire signed [16:0] tm205;
   wire signed [15:0] Y4;
   wire signed [15:0] Y5;
   wire signed [15:0] Y6;
   wire signed [15:0] Y7;
   wire signed [15:0] t49;
   wire signed [15:0] t50;
   wire signed [15:0] t51;
   wire signed [15:0] t52;
   wire signed [15:0] t53;
   wire signed [15:0] t54;
   wire signed [15:0] t55;
   wire signed [15:0] t56;


   assign a17 = X0;
   assign a18 = X2;
   assign a19 = X1;
   assign a20 = X3;
   assign a25 = X4;
   assign a26 = X6;
   assign a27 = X5;
   assign a28 = X7;
   assign Y0 = t49;
   assign Y1 = t50;
   assign Y2 = t51;
   assign Y3 = t52;
   assign Y4 = t53;
   assign Y5 = t54;
   assign Y6 = t55;
   assign Y7 = t56;
   assign t49 = tm198[16:1];
   assign t50 = tm199[16:1];
   assign t51 = tm200[16:1];
   assign t52 = tm201[16:1];
   assign t53 = tm202[16:1];
   assign t54 = tm203[16:1];
   assign t55 = tm204[16:1];
   assign t56 = tm205[16:1];

    addfxp #(17, 1) add79431(.a({{1{a17[15]}}, a17}), .b({{1{a18[15]}}, a18}), .clk(clk), .q(tm198));    // 0
    addfxp #(17, 1) add79446(.a({{1{a19[15]}}, a19}), .b({{1{a20[15]}}, a20}), .clk(clk), .q(tm199));    // 0
    subfxp #(17, 1) sub79461(.a({{1{a17[15]}}, a17}), .b({{1{a18[15]}}, a18}), .clk(clk), .q(tm200));    // 0
    subfxp #(17, 1) sub79476(.a({{1{a19[15]}}, a19}), .b({{1{a20[15]}}, a20}), .clk(clk), .q(tm201));    // 0
    addfxp #(17, 1) add79507(.a({{1{a25[15]}}, a25}), .b({{1{a26[15]}}, a26}), .clk(clk), .q(tm202));    // 0
    addfxp #(17, 1) add79522(.a({{1{a27[15]}}, a27}), .b({{1{a28[15]}}, a28}), .clk(clk), .q(tm203));    // 0
    subfxp #(17, 1) sub79537(.a({{1{a25[15]}}, a25}), .b({{1{a26[15]}}, a26}), .clk(clk), .q(tm204));    // 0
    subfxp #(17, 1) sub79552(.a({{1{a27[15]}}, a27}), .b({{1{a28[15]}}, a28}), .clk(clk), .q(tm205));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         X4 <= X4_in;
         X5 <= X5_in;
         X6 <= X6_in;
         X7 <= X7_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 21
// Gap: 8
module rc79577(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3,
   X4, Y4,
   X5, Y5,
   X6, Y6,
   X7, Y7);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   wire [31:0] t2;
   wire [31:0] s2;
   assign t2 = {X4, X5};
   wire [31:0] t3;
   wire [31:0] s3;
   assign t3 = {X6, X7};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];
   assign Y4 = s2[31:16];
   assign Y5 = s2[15:0];
   assign Y6 = s3[31:16];
   assign Y7 = s3[15:0];

   perm79575 instPerm80968(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
    .x2(t2), .y2(s2),
    .x3(t3), .y3(s3),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet79575(itr, clk, ct
,       x0, y0
,       x1, y1
,       x2, y2
,       x3, y3
);

    parameter width = 32;

    input [2:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    input [width-1:0] x2;
    output reg [width-1:0] y2;
    input [width-1:0] x3;
    output reg [width-1:0] y3;
    wire [width-1:0] t0_0, t0_1, t0_2, t0_3;
    wire [width-1:0] t1_0, t1_1, t1_2, t1_3;
    wire [width-1:0] t2_0, t2_1, t2_2, t2_3;
    reg [width-1:0] t3_0, t3_1, t3_2, t3_3;
    wire [width-1:0] t4_0, t4_1, t4_2, t4_3;
    reg [width-1:0] t5_0, t5_1, t5_2, t5_3;

    reg [1:0] control;

    always @(posedge clk) begin
      case(ct)
        3'd0: control <= 2'b10;
        3'd1: control <= 2'b10;
        3'd2: control <= 2'b10;
        3'd3: control <= 2'b10;
        3'd4: control <= 2'b01;
        3'd5: control <= 2'b01;
        3'd6: control <= 2'b01;
        3'd7: control <= 2'b01;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [1:0] control0;
   reg [1:0] control1;
    always @(posedge clk) begin
       control0 <= control;
        control1 <= control0;
    end
    assign t0_0 = x0;
    assign t0_1 = x2;
    assign t0_2 = x1;
    assign t0_3 = x3;
     assign t1_0 = t0_0;
     assign t1_1 = t0_1;
     assign t1_2 = t0_3;
     assign t1_3 = t0_2;
    assign t2_0 = t1_0;
    assign t2_1 = t1_2;
    assign t2_2 = t1_1;
    assign t2_3 = t1_3;
   always @(posedge clk) begin
         t3_0 <= t2_0;
         t3_1 <= t2_1;
         t3_2 <= t2_3;
         t3_3 <= t2_2;
   end
    assign t4_0 = t3_0;
    assign t4_1 = t3_2;
    assign t4_2 = t3_1;
    assign t4_3 = t3_3;
   always @(posedge clk) begin
         t5_0 <= (control1[1] == 0) ? t4_0 : t4_1;
         t5_1 <= (control1[1] == 0) ? t4_1 : t4_0;
         t5_2 <= (control1[0] == 0) ? t4_2 : t4_3;
         t5_3 <= (control1[0] == 0) ? t4_3 : t4_2;
   end
    always @(posedge clk) begin
        y0 <= t5_0;
        y1 <= t5_2;
        y2 <= t5_1;
        y3 <= t5_3;
    end
endmodule

// Latency: 21
// Gap: 8
module perm79575(clk, next, reset, next_out,
   x0, y0,
   x1, y1,
   x2, y2,
   x3, y3);
   parameter width = 32;

   parameter depth = 8;

   parameter addrbits = 3;

   parameter muxbits = 2;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input [width-1:0]  x2;
   output [width-1:0]  y2;
   wire [width-1:0]  t2;
   wire [width-1:0]  s2;
   input [width-1:0]  x3;
   output [width-1:0]  y3;
   wire [width-1:0]  t3;
   wire [width-1:0]  s3;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg [addrbits-1:0] s1rd2, s2wr2, s2rd2;
   reg [addrbits-1:0] s1rd3, s2wr3, s2rd3;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm28;
   assign tm28 = 0;

shiftRegFIFO #(4, 1) shiftFIFO_80973(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80974(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem2(x2, t2, {inFlip0, s1wr0}, {outFlip0, s1rd2}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem3(x3, t3, {inFlip0, s1wr0}, {outFlip0, s1rd3}, s1wr_en, clk);

shiftRegFIFO #(7, 1) shiftFIFO_80983(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(5, 1) shiftFIFO_80984(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(8, 1) shiftFIFO_80985(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_80986(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(7, 1) shiftFIFO_80989(.X(tm28), .Y(tm28_d), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_80992(.X(tm28_d), .Y(tm28_dd), .clk(clk));
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(4, 3) shiftFIFO_80997(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(5, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem2(s2, y2, {inFlip1, s2wr2}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem3(s3, y3, {inFlip1, s2wr3}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
	 s1wr0 <= 0;
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm28_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd0 <= 1;
	     {1'd0,  3'd1}: s1rd0 <= 3;
	     {1'd0,  3'd2}: s1rd0 <= 5;
	     {1'd0,  3'd3}: s1rd0 <= 7;
	     {1'd0,  3'd4}: s1rd0 <= 0;
	     {1'd0,  3'd5}: s1rd0 <= 2;
	     {1'd0,  3'd6}: s1rd0 <= 4;
	     {1'd0,  3'd7}: s1rd0 <= 6;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "distributed"
   always @(posedge clk) begin
      case({tm28_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd1 <= 0;
	     {1'd0,  3'd1}: s1rd1 <= 2;
	     {1'd0,  3'd2}: s1rd1 <= 4;
	     {1'd0,  3'd3}: s1rd1 <= 6;
	     {1'd0,  3'd4}: s1rd1 <= 1;
	     {1'd0,  3'd5}: s1rd1 <= 3;
	     {1'd0,  3'd6}: s1rd1 <= 5;
	     {1'd0,  3'd7}: s1rd1 <= 7;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "distributed"
   always @(posedge clk) begin
      case({tm28_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd2 <= 1;
	     {1'd0,  3'd1}: s1rd2 <= 3;
	     {1'd0,  3'd2}: s1rd2 <= 5;
	     {1'd0,  3'd3}: s1rd2 <= 7;
	     {1'd0,  3'd4}: s1rd2 <= 0;
	     {1'd0,  3'd5}: s1rd2 <= 2;
	     {1'd0,  3'd6}: s1rd2 <= 4;
	     {1'd0,  3'd7}: s1rd2 <= 6;
      endcase      
   end

// synthesis attribute rom_style of s1rd2 is "distributed"
   always @(posedge clk) begin
      case({tm28_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd3 <= 0;
	     {1'd0,  3'd1}: s1rd3 <= 2;
	     {1'd0,  3'd2}: s1rd3 <= 4;
	     {1'd0,  3'd3}: s1rd3 <= 6;
	     {1'd0,  3'd4}: s1rd3 <= 1;
	     {1'd0,  3'd5}: s1rd3 <= 3;
	     {1'd0,  3'd6}: s1rd3 <= 5;
	     {1'd0,  3'd7}: s1rd3 <= 7;
      endcase      
   end

// synthesis attribute rom_style of s1rd3 is "distributed"
    swNet79575 sw(tm28_d, clk, muxCycle, t0, s0, t1, s1, t2, s2, t3, s3);

   always @(posedge clk) begin
      case({tm28_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr0 <= 4;
	      {1'd0, 3'd1}: s2wr0 <= 5;
	      {1'd0, 3'd2}: s2wr0 <= 6;
	      {1'd0, 3'd3}: s2wr0 <= 7;
	      {1'd0, 3'd4}: s2wr0 <= 0;
	      {1'd0, 3'd5}: s2wr0 <= 1;
	      {1'd0, 3'd6}: s2wr0 <= 2;
	      {1'd0, 3'd7}: s2wr0 <= 3;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "distributed"
   always @(posedge clk) begin
      case({tm28_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr1 <= 4;
	      {1'd0, 3'd1}: s2wr1 <= 5;
	      {1'd0, 3'd2}: s2wr1 <= 6;
	      {1'd0, 3'd3}: s2wr1 <= 7;
	      {1'd0, 3'd4}: s2wr1 <= 0;
	      {1'd0, 3'd5}: s2wr1 <= 1;
	      {1'd0, 3'd6}: s2wr1 <= 2;
	      {1'd0, 3'd7}: s2wr1 <= 3;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "distributed"
   always @(posedge clk) begin
      case({tm28_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr2 <= 0;
	      {1'd0, 3'd1}: s2wr2 <= 1;
	      {1'd0, 3'd2}: s2wr2 <= 2;
	      {1'd0, 3'd3}: s2wr2 <= 3;
	      {1'd0, 3'd4}: s2wr2 <= 4;
	      {1'd0, 3'd5}: s2wr2 <= 5;
	      {1'd0, 3'd6}: s2wr2 <= 6;
	      {1'd0, 3'd7}: s2wr2 <= 7;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr2 is "distributed"
   always @(posedge clk) begin
      case({tm28_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr3 <= 0;
	      {1'd0, 3'd1}: s2wr3 <= 1;
	      {1'd0, 3'd2}: s2wr3 <= 2;
	      {1'd0, 3'd3}: s2wr3 <= 3;
	      {1'd0, 3'd4}: s2wr3 <= 4;
	      {1'd0, 3'd5}: s2wr3 <= 5;
	      {1'd0, 3'd6}: s2wr3 <= 6;
	      {1'd0, 3'd7}: s2wr3 <= 7;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr3 is "distributed"
endmodule



						module multfix(clk, rst, a, b, q_sc, q_unsc);
						   parameter WIDTH=35, CYCLES=6;

						   input signed [WIDTH-1:0]    a,b;
						   output [WIDTH-1:0]          q_sc;
						   output [WIDTH-1:0]              q_unsc;

						   input                       clk, rst;
						   
						   reg signed [2*WIDTH-1:0]    q[CYCLES-1:0];
						   wire signed [2*WIDTH-1:0]   res;   
						   integer                     i;

						   assign                      res = q[CYCLES-1];   
						   
						   assign                      q_unsc = res[WIDTH-1:0];
						   assign                      q_sc = {res[2*WIDTH-1], res[2*WIDTH-4:WIDTH-2]};
						      
						   always @(posedge clk) begin
						      q[0] <= a * b;
						      for (i = 1; i < CYCLES; i=i+1) begin
						         q[i] <= q[i-1];
						      end
						   end
						                  
						endmodule 
module addfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a+b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
   
endmodule

module subfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a-b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
  
endmodule