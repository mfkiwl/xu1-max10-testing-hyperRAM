<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IOF Library: More about the IOF library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="main.html">main</a></div>
<h1><a class="anchor" name="page_generalities">More about the IOF library</a></h1><h2><a class="anchor" name="sec_why_fmtd_io">
Why formatted I/O, why IOF</a></h2>
The <em>iof</em> library combines the best of C and C++ worlds: the compactness of printf/scanf formatted input/output, with the robustness and object-oriented capabilities of STL's streams.<p>
Formatted I/O is more <em><b>compact</b> than</em> raw STL stream I/O: each formatting operation that normally requires STL stream manipulators has a one-character counterpart in <em>iof</em> format strings. Also, you get automatic restoration of stream format state if an exception occurs during input/output, group formatting requires one character (would require several lines of code), some formatting applies to whole object rather than setting state, etc.<p>
Compactness allows the "pattern" of the input or output to be clearer and easier to manage. In some ways, it segregates formatting from content and algorithm. So <em>iof</em> makes it easy to do in a few characters what would take many lines of code to do with "raw" STL streams. This should be appearent in <a class="el" href="main.html#sec_hello_world">Hello World</a>.<p>
Formatted I/O is more <em><b>memory-friendly</b> than</em> raw STL stream I/O: I find it much easier, for some reason, to remember that fixed point output is "f" and the number <em>n</em> of digits after period is ".n", than to remember the manipulator names or stream methods to call (e.g. std::ios::fixed and std::setprecision()). This means that you are inclined to format output much more than you would with raw STL streams.<p>
Formatted I/O with <em>iof</em> is more <em><b>robust</b> than</em> with printf/scanf: <em>iof</em> just uses STL streams behind the scenes, and streams are typesafe. This means you don't need to tell <em>iof</em> what type of object is being output/input, the C++ compiler already knows. You can concentrate on using simple format markers ("%s") to set the <em>state</em> of the stream, regardless of type, and use format specification characters as appropriate, without fear of crashes.<p>
Formatted I/O with <em>iof</em> is more <em><b>versatile</b> than</em> printf/scanf: you don't need to tell it the type of the object being output, the I/O is exception-aware, there are more operations available (e.g., centering, any character can be used as a filler, booleans can be input or output as words, etc), some operations apply to whole objects (this is even better than raw STL stream I/O), user-data-types can be output as well (instead of just plain old data types like int, float char etc).<p>
Formatted I/O with <em>iof</em> is even more <em><b>versatile</b> than</em> raw STL stream I/O: <em>iof</em> manages formatting so it doesn't "leak" past the format operation, i.e. your formatting only affects the stream format state for the line on which it is used; the format state is exception safe; some formatting applies to whole objects rather than just set state; input has better error handling available and individual characters can be checked for input; etc.<h2><a class="anchor" name="sec_capabilities">
Capabilities</a></h2>
<ul>
<li>All STL stream manipulations: alignment, number and boolean representation, padding/field width</li><li>All printf/scanf formatting, except "%n" (STL streams don't either), using same codes</li><li>Can use same marker syntax for all types (float, int, UDT, etc)</li><li>Don't need to tell the type of object being output, works on stream format state entirely</li><li>Centering (STL streams don't)</li><li>Use any character as fill</li><li>Apply formatting to several format markers</li><li>Restore stream format state after format completed</li><li>Restore stream format even if aborted by exception (esp. useful for input)</li><li>Easy-to-use "stringizer" to create strings from formatted output</li><li>Can use function calls instead of operators, if desired</li><li>Doesn't require temporary instances of streams (except for some operations not supported by streams "out of the box", like centering)</li><li>More information available about where/type of error, for formatted input</li><li>Dynamic format specification</li><li>Validates input characters specified in format string</li><li>Stream character skipping as per the "ignore()" methods, uses similar syntax as printf/scanf</li><li>Format guard available for cases where some non-iof format changes are required, but need to be "undone"</li></ul>
<h2><a class="anchor" name="sec_limitations">
Limitations</a></h2>
<ul>
<li>no support for printf()'s "%n" or "%*"</li><li>no support (yet) for wchar</li><li>For the I/O <em>functions</em> (not the classes/operators), no more than 10 (ten) objects can be output/input in one function call (though adding more is trivial) </li></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun Oct 15 23:55:35 2006 for IOF Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
