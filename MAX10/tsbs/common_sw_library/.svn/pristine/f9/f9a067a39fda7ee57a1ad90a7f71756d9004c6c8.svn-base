<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IOF Library: Formatted Output: General</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="page_fmtd_o_general">Formatted Output: General</a></h1>[This page is under construction.<p>
The old documentation is still available as part of the distribution. Sorry for the inconvenience. -- OS]<p>
The documentation is structured as a series of questions/answers which contain examples of code and associated output, plus a reference section that the answers refer to for more details.<p>
<ul>
<li><a class="el" href="page_fmtd_o_general.html#sec_o_wifo">Q: What do you mean by "formatted output"?</a></li><li><a class="el" href="page_fmtd_o_general.html#sec_o_how">Q: How do you format output?</a></li></ul>
<h2><a class="anchor" name="sec_o_wifo">
Q: What do you mean by "formatted output"?</a></h2>
<dl compact><dt><b></b></dt><dd><b>A:</b> The same thing that C's printf() does. Normally, When you output objects to a stream in C++, you modify how the object gets printed via "manipulators". For instance, you can say that floating point values get printed in "fixed point" format with N digits of precision, whereas booleans get printed as text rather than as 0 or 1, etc. So a typical output using streams involves a sequence of manipulators, text strings and objects, like <div class="fragment"><pre class="fragment">aStream &lt;&lt; <span class="stringliteral">"text1:"</span> &lt;&lt; manip1 &lt;&lt; manip2 &lt;&lt; obj1 
        &lt;&lt; <span class="stringliteral">", text2 "</span> &lt;&lt; obj2 
        &lt;&lt; <span class="stringliteral">", text3 "</span> &lt;&lt; manip3 &lt;&lt; obj3 &lt;&lt; ...;
</pre></div></dd></dl>
<dl compact><dt><b></b></dt><dd><em>Formatted Output</em> refers to having the text string and the manipulators separated into a "format string" that contains character literals and format markers, and all that's left is the objects: <div class="fragment"><pre class="fragment">aStream &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"text1:%mms, text2 %s, text3 %ms..."</span>) 
        &lt;&lt; obj1 &lt;&lt; obj2 &lt;&lt; obj3;
</pre></div> The <em>format markers</em> start with a '%' and end with an 's', and any characters in between the two, called <em>format specifiers</em>, identify which manipulations to perform. Format markers and specifiers are explained in further detail later. Note that for the sake of simplicity, each manipulator in the first example is expressed by one 'm' in the above "formatted output" equivalent, but some manipulators require two or more characters (e.g, precision).</dd></dl>
<h2><a class="anchor" name="sec_o_how">
Q: How do you format output?</a></h2>
<dl compact><dt><b></b></dt><dd><b>A:</b> You send an <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> object to the output stream, with the text of your message as argument: <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">""</span>)
</pre></div> You represent each object you will be "inserting" into this message by a format marker, 's': <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%s: received %sk, sent %sk"</span>)
          &lt;&lt; timestamp &lt;&lt; sizeReceived &lt;&lt; sizeSent;
</pre></div> Then you customize the format of each object: <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%02s: received %.1fsk, sent %.1fsk"</span>)
          &lt;&lt; timestamp &lt;&lt; sizeReceived &lt;&lt; sizeSent;
</pre></div> You will also find it convenient to note if the same formatting is used throughout your format string (for a given type of object), and use persistent formatting by changing 's' to 'S' where appropriate: <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%02s: received %.1fSk, sent %sk"</span>) 
          &lt;&lt; timestamp &lt;&lt; sizeReceived &lt;&lt; sizeSent;
</pre></div> Note that persistent formatting can be very powerful way of simplifying your format string, but as any such tool, abuse can obfuscate your code.</dd></dl>
<h2><a class="anchor" name="sec_o_types">
Q: What types of objects can be output?</a></h2>
<dl compact><dt><b></b></dt><dd><b>A:</b> The objects that follow <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> or given to the iof:: output functions can be of <em>any</em> fundamental type (int, bool, etc), or <em>any</em> instance of a class for which an <code>operator&lt;&lt; </code> is defined. The following example <div class="fragment"><pre class="fragment"><span class="keyword">class </span>Time {
    Time(<span class="keywordtype">int</span> hr, <span class="keywordtype">int</span> min, <span class="keywordtype">int</span> sec): hr(hr), min(min), sec(sec) {}
    <span class="keywordtype">int</span> hr, min, sec;
    <span class="keyword">friend</span> ostream&amp; operator&lt;&lt;(ostream&amp;, <span class="keyword">const</span> Time&amp;);
}

ostream&amp; operator&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> Time&amp; t) {
    <span class="keywordflow">return</span> out &lt;&lt; t.hr &lt;&lt; t.min &lt;&lt; t.sec;
}
<span class="keywordtype">int</span> main() {
    cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%02s"</span>) &lt;&lt; Time(1,34,36);
}
</pre></div> would print "01:34:36" to cout.</dd></dl>
<h2><a class="anchor" name="sec_o_limit">
Q: Is there any limit to the number of objects that</a></h2>
can be output via the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>?<p>
<dl compact><dt><b></b></dt><dd><b>A:</b> No. N can be as large as you want, the same as for "normal" (ie not using iof) output.</dd></dl>
<h2><a class="anchor" name="sec_o_restore">
Q: What happens to the format state of the stream</a></h2>
after a formatted output?<p>
<dl compact><dt><b></b></dt><dd><b>A:</b> It is restored to the format state from just before the formatted output.</dd></dl>
<dl compact><dt><b></b></dt><dd>Indeed, STL streams have a format state. So if you say you want fixed point output to use two digits of precision, then <em>all</em> output of floating point numbers, anywhere in your code, will use two digits of precision, for <em>the remainder of your program</em>, or until it is changed somewhere else in your code. With iof, you never again need to worry about such effect: <div class="fragment"><pre class="fragment">cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%.2f "</span>) &lt;&lt; 1.2345678;
cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%f\n"</span>) &lt;&lt; 1.2345678;
</pre></div> will properly produce "1.23 1.234568" as opposed to "1.23 1.23" with regular STL stream commands.</dd></dl>
<h2><a class="anchor" name="sec_o_stl">
Q: Does IOF replace STL streams or manipulators with</a></h2>
its own (behind the scene)?<p>
<dl compact><dt><b></b></dt><dd><b>A:</b> Absolutely NOT! The formatted output classes and functions in IOF are just <em>wrappers</em> around the STL streams and manipulators. The format string is akin to a "binary encoding" of the output. When you write <div class="fragment"><pre class="fragment">aStream &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"blabla %.2f blibli"</span>) &lt;&lt; aFloat;
</pre></div> the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> will<ol type=1>
<li>save the format state of the stream,</li><li>send "blabla " to the stream,</li><li>call some methods on the stream to do the appropriate manipulations (to say that floating point values should be output as fixed point numbers with 2 digits precision),</li><li>send " blibli" to the stream,</li><li>restore the format state of the stream to what was saved.</li></ol>
</dd></dl>
<h2><a class="anchor" name="sec_o_manip">
Q: Do I need STL manipulators like std::fixed or std::endl?</a></h2>
<dl compact><dt><b></b></dt><dd><b>A:</b> No, that's the whole idea, you should never have to use manipulators, except for custom manipulators (provided by you or a third-party library) that don't have an equivalent in iof. You should only have to use the iof formatter objects &amp; functions.</dd></dl>
<h2><a class="anchor" name="sec_o_fn">
Q: I don't like to use the output operator &lt;&lt;, can I</a></h2>
use functions instead?<p>
<dl compact><dt><b></b></dt><dd><b>A:</b> YES! The example given in <a class="el" href="page_fmtd_o_general.html#sec_o_how">Q: How do you format output?</a> would be <div class="fragment"><pre class="fragment">iof::coutf(<span class="stringliteral">"..."</span>, obj1, obj2, ..., objN);
</pre></div></dd></dl>
<h2><a class="anchor" name="sec_o_fn_lim">
Q: Any limits on number of parameters when using the</a></h2>
iof functions instead of the operators?<p>
<dl compact><dt><b></b></dt><dd><b>A:</b> Yes. N &lt;= 10.</dd></dl>
<h2><a class="anchor" name="sec_o_format_str">
Concept: Format Strings</a></h2>
<h2><a class="anchor" name="sec_qa_fs_1">
sec_qa_fs_1</a></h2>
, where the "c" denotes a character that represents the manipulator. E.g. the character that is used to represent the "boolalpha" manipulator is "a", so if manip1 was boolalpha then c would be a.<h2><a class="anchor" name="sec_o_format_marker">
Concept: Format Markers</a></h2>
<h2><a class="anchor" name="sec_o_format_classes">
Formatting with Classes/Operators</a></h2>
<h2><a class="anchor" name="sec_o_format_functions">
Formatting with Functions</a></h2>
<h2><a class="anchor" name="sec_o_format_spec">
Concept: Format Specification Characters</a></h2>
A: Every std:: manipulator has a counterpart in iof.<h2><a class="anchor" name="sec_o_format_pers">
Concept: Format Persistence</a></h2>
<h2><a class="anchor" name="sec_o_exc_safety">
Exception Safety</a></h2>
<hr size="1"><address style="align: right;"><small>Generated on Sun Oct 15 20:32:35 2006 for IOF Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
