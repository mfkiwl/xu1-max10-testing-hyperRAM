This component is intended to be placed into an SOPC Builder system.  It
receives incoming packets into an Avalon ST sink interface.  This component is
monitored and controlled through an Avalon MM slave interface.

//
// prbs_packet_checker
//
// This component is designed to verify sequenced packets of variable length
// filled with pseudo random data.  The packets are received on an Avalon ST
// sink interface.  These packets are expected to be generated by the
// prbs_packet_generator on the transmitting end of the data path.
//
// The packets are verified with this format:
//
//  |-------------------------------------------------------|
//  |    PRBS Packet Length     |   Seq LSB   |   Seq MSB   |
//  |-------------------------------------------------------|
//  |             PRBS Data Word 0 (MSB first)              |
//  |-------------------------------------------------------|
//  |                                                       |
//  |                         . . .                         |
//  |                                                       |
//  |-------------------------------------------------------|
//  |             PRBS Data Word N (MSB first)              |
//  |-------------------------------------------------------|
//
//  PRBS Packet Length - is the length of the packet data not including this
//      length field.
//
//  Sequence Number - is the packet sequence number which begins at ZERO when
//      the peripheral is enabled and then incremented for each subsequent
//      packet.
//                  
//  Sequence LSB - is the least significant byte of the sequence number
//
//  Sequence MSB - is the most significant byte of the sequence number
//
//  PRBS Data Word - is the pseudo random data pattern that fills the packet.
//      When the peripheral receives a new packet, it extracts PRBS data word 0
//		and then proceeds to compute the expected PRBS pattern for each
//		subsequent PRBS word.  The PRBS data words are received most
//		significant byte first, and it is perfectly legal to receive partial
//		PRBS data words, depending on the packet length.  Packet lengths less
//		than three will contain no PRBS data at all, and only packets of length
//		7 or greater will contain enough PRBS data for verification by this
//		peripheral.
// 
//  ---------------------------------------------------------------------------
//  Packet Verification
//  ---------------------------------------------------------------------------
//	
//	Depending on the packet length there are three possible conditions that
//	this peripheral will verify.
//	
//	First, the packet length is always verified, since the length field must be
//	received as the first two bytes of the packet, the length is always
//	verified.  Length of ZERO up to 0xFFFF are allowed.  Packets with length of
//	ZERO will in fact be Avalon ST packets of length 2, for the length of the
//	two length bytes.  For all other packet lengths greater than ZERO, the
//	Avalon ST packet length is expected to be the length indicated by the
//	length field, plus two for the length field.
//	
//	Second, if the packet length is 1, then the LSB of the sequence number is
//	verified to align with our internal packet sequence count.  And if the
//	packet length is two or greater, then the entire 16-bit sequence number is
//	verified to align with our internal packet sequence count.
//	
//	Third, if the packet length is 7 or greater, then the PRBS data word 0 is
//	used to initialize the PRBS data verification logic and all subsequent full
//	or partial PRBS data words are verified to the extent possible.
//
//	Error counts for each of the three possible errors detected above are
//	accumulated in error count registers within this peripheral.
//	
//  ---------------------------------------------------------------------------
//  Register Map
//  ---------------------------------------------------------------------------
//  
//  The slave interface for the prbs_packet_checker is broken up into six
//  32-bit registers with the following layout:
//  
//  Register 0 - Status Register
//      Bit 0 - R/W - GO control and status bit.  Set this bit to 1 to enable
//                  the packet checker, and clear it to disable it.  Note that
//                  once cleared, the packet checker will stop at the end of
//					the current packet being received.  Care should be taken
//					not to stop it in mid packet reception.  Instead you should
//					stop the packet generation source first, allow all packets
//					to be received by the checker, and then stop the checker.
//      
//  Register 1 - Length Error Count
//      Bits [31:0] - R/WC - count of length errors detected since last clear.
//                  
//  Register 2 - Sequence Error Count
//      Bits [31:0] - R/WC - count of sequence errors detected since last clear.
//                  
//  Register 3 - Data Error Count
//      Bits [31:0] - R/WC - count of data errors detected since last clear.
//                  
//  Register 4 - Byte Count
//      Bits [31:0] - R/WC - count of payload bytes received since last clear.
//                  
//  Register 5 - Packet Count
//      Bits [31:0] - R/WC - count of packets received since last clear.
//                  
//  Note: writing to any one of the counter register bytes will clear all
//	counters simultaneously.
//
//  R - Readable
//  W - Writeable
//  WC - Clear on Write
//
