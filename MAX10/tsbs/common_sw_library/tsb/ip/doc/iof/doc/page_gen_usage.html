<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IOF Library: General usage</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="main.html">main</a></div>
<h1><a class="anchor" name="page_gen_usage">General usage</a></h1>Table of contents:<ul>
<li><a class="el" href="page_gen_usage.html#sec_header">Which header file to include</a></li><li><a class="el" href="page_gen_usage.html#sec_output">Send formatted data to a stream (formatted output)</a></li><li><a class="el" href="page_gen_usage.html#sec_operator">Make your class usable by iof: with operator&lt;&lt;(stream&amp;)</a></li><li><a class="el" href="page_gen_usage.html#sec_fsc_oo">The format specification characters are "object-oriented"</a></li><li><a class="el" href="page_gen_usage.html#sec_fsc_as_fill">Fill characters</a></li><li><a class="el" href="page_gen_usage.html#sec_fsc_order">Format specification can happen in any order</a></li><li><a class="el" href="page_gen_usage.html#sec_input">Read formatted data from a stream (formatted input)</a></li><li><a class="el" href="page_gen_usage.html#sec_unformatted">Remaining objects are output "unformatted"</a></li><li><a class="el" href="page_gen_usage.html#sec_restore">Format state of stream automatically restored</a></li><li><a class="el" href="page_gen_usage.html#sec_unused_markers">Notifies you if unused format markers</a></li><li><a class="el" href="page_gen_usage.html#sec_save">Save a format state of a stream for future use</a></li><li><a class="el" href="page_gen_usage.html#sec_except_safety">Automatically restore the format state when unformatted I/O</a></li><li><a class="el" href="page_gen_usage.html#sec_dyn_fmt">Format specifications "refactored"</a></li><li><a class="el" href="page_gen_usage.html#sec_consume_marker">Objects that don't consume format markers</a></li><li><a class="el" href="page_gen_usage.html#sec_input_text">Verify that text in format string is matched verbatim by input stream</a></li><li><a class="el" href="page_gen_usage.html#sec_input_err">Exception provides info about cause of error on input</a></li><li><a class="el" href="page_gen_usage.html#sec_validity">Get validity state of input stream</a></li><li><a class="el" href="page_gen_usage.html#sec_skip_marker">Skip some patterns on input</a></li><li><a class="el" href="page_gen_usage.html#sec_skippast">Define skip patterns at runtime</a></li><li><a class="el" href="page_gen_usage.html#sec_fn_syntax">If you prefer function call syntax rather than operator syntax</a></li><li><a class="el" href="page_gen_usage.html#sec_persist">Persistent Formatting: factoring out common format specs</a></li><li><a class="el" href="page_gen_usage.html#sec_flush">Flush the stream from format string</a></li><li><a class="el" href="page_gen_usage.html#sec_stringizer">Stringizer: output to a string directly</a></li><li><a class="el" href="page_gen_usage.html#sec_diff_printf">Differences with C's printf format markers</a></li></ul>
<h2><a class="anchor" name="sec_header">
Which header file to include</a></h2>
<ul>
<li>One header file includes all others: <code><a class="el" href="io_8hpp.html">iof/io.hpp</a></code> </li><li>Slightly better compilation performance is possible in cases where you just use <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>: all you need is <code><a class="el" href="fmtr_8hpp.html">iof/fmtr.hpp</a></code> </li><li>All iof functionality is defined within a namespace called 'iof'</li></ul>
<p>
See the <a href="files.html">Files</a> section for a list of all headers that can be included individually.<h2><a class="anchor" name="sec_output">
Send formatted data to a stream (formatted output)</a></h2>
Send an instance of <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> to a stream, followed by the objects to output and format:<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(format_string) &lt;&lt; obj1 &lt;&lt; obj2 ...;
</pre></div><p>
The format_string is a character string just like that of C's printf: a mixture of ordinary text and <em>format</em> <em>markers</em> (aka placeholders, format tags, etc), one format marker per object to output.<p>
A format marker starts with '' and ends with either 's' or 'S' regardless of the type of the object being output (contrary to C's printf family of functions, there is no need to specify the type of object being output, as the C++ compiler knows it and doesn't make mistakes -- so it's one less thing to remember)<p>
A format marker may contain <em>format</em> <em>specification</em> <em>characters</em> (FSC) in between the opening '' and closing 's' or 'S'. These characters set the format state of the stream before the corresponding object is sent to it. The full set of FSC is here.<p>
Note that the FSC are always combined with the format state that the stream had when the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> was created, so the "base format state" is always known (typically, the default adopted by the stream) for each format marker.<p>
Note finally that if you want a '' sign in a format string you double it (as with printf): <code><a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>("%s%%") &lt;&lt; percentage;</code><h2><a class="anchor" name="sec_operator">
Make your class usable by iof: with operator&lt;&lt;(stream&amp;)</a></h2>
There is no special requirement on the type of the objects following the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>, except that they must have the usual<p>
<div class="fragment"><pre class="fragment">std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, T);
</pre></div><p>
defined for themselves. I.e., if you can output an instance of your class to an STL stream, then you can use it in formatted output.<p>
Note that 'T' is the type of the object or a (usually const) reference of the object's type. All fundamental types (bool, short, int, etc) already have this. E.g.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="io_8hpp.html">iof/io.hpp</a>"</span>

<span class="keyword">class </span>Time {
    Time(<span class="keywordtype">int</span> hr, <span class="keywordtype">int</span> min, <span class="keywordtype">int</span> sec)
        : hr(hr), min(min), sec(sec) {}
    <span class="keywordtype">int</span> hr, min, sec;
    
    <span class="keyword">friend</span> std::ostream&amp; 
        operator&lt;&lt;(std::ostream&amp;, <span class="keyword">const</span> Time&amp;);
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, <span class="keyword">const</span> Time&amp; t) {
    <span class="keywordflow">return</span> out &lt;&lt; t.hr &lt;&lt; t.min &lt;&lt; t.sec;
}
<span class="keywordtype">int</span> main() {
    std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%02s"</span>) &lt;&lt; Time(1,34,36);
}
</pre></div><p>
would print "01:34:36" to std::cout.<h2><a class="anchor" name="sec_fsc_oo">
The format specification characters are "object-oriented"</a></h2>
Note that some FSC apply to the whole object being output, whereas others only set format state to be used by the object being output. E.g.:<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"10f.4s"</span>) &lt;&lt; obj; 
</pre></div><p>
If obj is a plain float, that float will be printed in "fixed precision" notation with 4 digits of precision ('f.4'), in a field 10 chars wide. But if obj is an instance of a class that has operator&lt;&lt;(std::ostream&amp;) defined, that whole object will be fit in a field 10 chars wide, and <em>all</em> <em>floats</em> sent to the stream by this object will appear in fixed-point notation with 4 digits precision (unless, of course, the object's operator&lt;&lt; overrides this).<p>
It is straighforward to know if an FSC applies to a whole object or to the members of an object: if the FSC concerns a "fundamental type", such as float (notation, precision, etc), int (base, sign, etc), bool (alpha or not), etc, then the FSC will apply to each member of the object (unless naturally the object is itself a fundamental type). If the FSC is a "generic" concept (e.g., alignment, width), it applies to the whole object.<h2><a class="anchor" name="sec_fsc_as_fill">
Fill characters</a></h2>
Any character between a format marker's opening '' and closing 's' (or 'S') is deemed an FSC *if* it is understood by <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>. If not, it is used a fill character. This means you can use any character as a fill character, unlike with printf.<p>
If you need a fill character that is a reserved character, you must "escape" it by preceding it with the format string escape character '!':<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%10fs"</span>) &lt;&lt; 1.234;
</pre></div><p>
will print a floating-point number in fixed-point notation in a field of 10 chars wide, i.e. "   1.234", whereas<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%10!fs"</span>) &lt;&lt; 1.234;
</pre></div><p>
will print it in the stream's default notation (general) with 'f' as the fill character, ie "ffff1.234".<h2><a class="anchor" name="sec_fsc_order">
Format specification can happen in any order</a></h2>
The FSC in a format marker may specify the output or input format in any order, e.g. alignment, width, notation, etc. The order does not matter because the formatting is done via state flags on the stream.<h2><a class="anchor" name="sec_input">
Read formatted data from a stream (formatted input)</a></h2>
Insert an instance of <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> between the stream and the objects being read to:<p>
<div class="fragment"><pre class="fragment">std::cin &gt;&gt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(format_string) &gt;&gt; obj1 &gt;&gt; obj2 ...;
</pre></div><p>
The format_string and <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> have the same characterics as for formatted output.<h2><a class="anchor" name="sec_unformatted">
Remaining objects are output "unformatted"</a></h2>
If there are more objects than there are format markers, then the remaining objects are output unformatted (and therefore concatenated).<h2><a class="anchor" name="sec_restore">
Format state of stream automatically restored</a></h2>
The format state of stream is automatically restored by <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> destructor: the stream's format state is restored to what it was when the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> was created. This way, your formatting never "bleeds" out into other (and most often unrelated) sections of your program/library.<h2><a class="anchor" name="sec_unused_markers">
Notifies you if unused format markers</a></h2>
Unused format markers are considered a programmer error by an <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>: if there are N format markers in the format string, there must be at least N objects following the <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a> instance. E.g. the following will fail:<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%s"</span>);
</pre></div><p>
In a debug build the failure will be a failed assertion, in release build an <a class="el" href="classiof_1_1too__many__markers.html">iof::too_many_markers</a> exception gets thrown. This exception is necessary since the format string is processed at run-time.<p>
You can change this behavior with compiler "defines": <code>EXTRA_MARKERS_NO_ASSERT</code> will <em>not</em> assert, and <code>EXTRA_MARKERS_NO_THROW</code> will <em>not</em> throw an <a class="el" href="classiof_1_1too__many__markers.html">iof::too_many_markers</a> exception (which derives from std::exception).<h2><a class="anchor" name="sec_save">
Save a format state of a stream for future use</a></h2>
This is provided by the <a class="el" href="structiof_1_1stream__fmt.html">iof::stream_fmt</a> class, whose constructor takes a stream:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="structiof_1_1stream__fmt.html">iof::stream_fmt</a> fmt(std::cout);
std::ofstream yourStream('tmpFile.txt');
fmt.applyTo(yourStream);
assert(<a class="code" href="structiof_1_1stream__fmt.html">iof::stream_fmt</a>(yourStream) == <a class="code" href="structiof_1_1stream__fmt.html">iof::stream_fmt</a>(std::cout));
</pre></div><p>
Note how the format state can be "applied" to another stream, and how format states can be compared. Application overwrites rather than merges.<h2><a class="anchor" name="sec_except_safety">
Automatically restore the format state when unformatted I/O</a></h2>
During input or output, what if an exception occurs? If the output or input is via <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>, you need not worry since the format state is restored to its original state. But if you don't need formatted output or input, you no longer have that benefit, except if you use <a class="el" href="classiof_1_1fmt__guard.html">iof::fmt_guard</a>:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> f() {

    <span class="comment">// format state of std::cout saved on next line:</span>
    <a class="code" href="classiof_1_1fmt__guard.html">iof::fmt_guard</a> guard(std::cout); 

    <span class="comment">// now do some output, assume exception gets thrown:</span>
    std::cout &lt;&lt; ...; 
    <span class="comment">// uh oh, what if some of the objects you output did some stream</span>
    <span class="comment">// formatting? Thanks to iof::fmt_guard, no problem:</span>
    
} <span class="comment">// format state of std::cout automatically restored here</span>
</pre></div><h2><a class="anchor" name="sec_dyn_fmt">
Format specifications "refactored"</a></h2>
If the format specification comes from an external source (user, database, etc), you would normally (as with printf) have to create the format string yourself, then use the format string in an <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>. With <a class="el" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a>, this is not necessary:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a> hex(<span class="stringliteral">"#0x4"</span>); <span class="comment">// 0xnnnn format</span>
std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"Hi %s\n"</span>) &lt;&lt; hex &lt;&lt; obj1;
std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"Hi %s\n"</span>) &lt;&lt; hex(obj1); <span class="comment">// same as above</span>
</pre></div><p>
Note that <a class="el" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a> does not "consume" a format marker, since it does not make sense to send an <a class="el" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a> to a stream without an associated object to output. I.e.,<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a> fs1(...), fs2(...), fs3(...); <span class="comment">// several format specs</span>
std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"Hi %s: %s\n"</span>) 
          &lt;&lt; fs1 &lt;&lt; fs2 &lt;&lt; fs3 &lt;&lt; obj1 &lt;&lt; obj2;
</pre></div><p>
Note how there are only two format markers in this example's format string: fs1, fs2 and fs3 will all be combined logically to format obj1, whereas obj2 has not format specification.<p>
Note also that <a class="el" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a> objects are cumulative: fs1 could specify what to do for floating point values, where fs2 could specify what to do for integer values, and fs3 could specify the alignment/width. If fs2 also specifies width, then the width given in fs3 will prevail since it will be processed after fs2.<h2><a class="anchor" name="sec_consume_marker">
Objects that don't consume format markers</a></h2>
Some objects don't "consume" format markers: <a class="el" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a> and any std manipulator. This is because they operate on the stream state for the next* object output/input. E.g.<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%s = %s"</span>) &lt;&lt; 
          &lt;&lt; <a class="code" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a>(<span class="stringliteral">"..."</span>) &lt;&lt; std::setprecision(5) 
          &lt;&lt; obj1 &lt;&lt; obj2;
</pre></div><p>
where there are only two format markers in the format string, but there are four objects sent to the stream: the first is an <a class="el" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a> and the second a std manipulator, so they both affect the output of obj1. The output of obj2 is unaffected by either since formatting does not persist beyond a marker (unless the marker is closed with 'S' instead of 's').<h2><a class="anchor" name="sec_input_text">
Verify that text in format string is matched verbatim by input stream</a></h2>
<div class="fragment"><pre class="fragment">std::string name;
std::cin &gt;&gt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"hi %s"</span>) &gt;&gt; name;
</pre></div><p>
expects the std::cin to have exactly the characters 'hi ' followed by more characters, which will be put into name. A basic pattern matching capability is provied to skip certain sequences of characters, see iof::skip (which does not attempt to provide a full pattern matching capability -- consider using a good regexp library for this).<h2><a class="anchor" name="sec_input_err">
Exception provides info about cause of error on input</a></h2>
Since reading from a stream is much more likely to produce exceptions than when writing to it, any exception thrown by the stream is caught and a replacement exception is generated, with more information, such as which was the active format marker when the error occurred (1 would imply first one, etc).<h2><a class="anchor" name="sec_validity">
Get validity state of input stream</a></h2>
A typical input streaming involves a loop until some error condition occurs. The <a class="el" href="structiof_1_1validity.html">iof::validity</a> class contains information about the validity state of a stream. It is "filled" with the state of the stream, and automatically converts to a boolean, allowing you to do the following:<p>
<div class="fragment"><pre class="fragment">std::string val1;
<span class="keywordtype">float</span> val2;
<a class="code" href="structiof_1_1validity.html">iof::validity</a> ok;
<span class="keywordflow">while</span> (stream &gt;&gt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%s, %s"</span>) &gt;&gt; val1 &gt;&gt; val2 &gt;&gt; ok)
    ... get more data into stream (e.g. by reading stdin) ...
</pre></div><p>
The loop will be exited only when the <a class="el" href="structiof_1_1validity.html">iof::validity</a> evaluates to false (or when an exception gets thrown, e.g. pipe closed etc).<h2><a class="anchor" name="sec_skip_marker">
Skip some patterns on input</a></h2>
The STL stream ignore() methods are exposed via "skip markers", which start with '%[' and end with ']'. Any characters in between, known as the "skip specification characters" (SSC), specify what to skip. This does not attempt to provide a full pattern matching capability -- consider doing straight input to a string and then using a good regexp library to filter out the un/desired patterns.<p>
The complete set of "skip_past specification characters" (SSC) is here.<h2><a class="anchor" name="sec_skippast">
Define skip patterns at runtime</a></h2>
The <a class="el" href="classiof_1_1skip__past.html">iof::skip_past</a> class allows you to define skip patterns at runtime. A skip pattern occupies a format marker, not a skip marker:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">float</span> value=0;
std::cin &gt;&gt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%s%s"</span>) &gt;&gt; <a class="code" href="classiof_1_1skip__past.html">iof::skip_past</a>(10) &gt;&gt; value;
</pre></div><p>
In the above, the first format marker corresponds to the skipper, which will skip some characters from the stream; the the second format marker indicates what to input. You can think of a skip_past as being a proper "dump spot" for data from the stream, but you don't care about the data.<h2><a class="anchor" name="sec_fn_syntax">
If you prefer function call syntax rather than operator syntax</a></h2>
If for some reason you don't like the operator notation, iof provides function wrappers that this for you:<p>
<ul>
<li>iof::prints and iof::scans (the 's' at the end stands for 'stream version of the printf/scanf) do generic output and input (resp.) for any stream derived from std::ostream or std::istream. E.g. iof::prints(stream, format_string, arg1, ...); is implemented as stream &lt;&lt; iof::fmtr(format_string) &lt;&lt; arg1 &lt;&lt; ...;</li></ul>
<p>
<ul>
<li>iof::coutf, iof::cerrf and iof::cinf (the 'f' at the end stands for 'function version of the stream') give their arguments to the stream via an <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>. In fact, those functions just call iof::prints or iof::scans with the appropriate stream, and just pass on to it all arguments.</li></ul>
<p>
<ul>
<li>iof::tostr just calls iof::prints with a std::ostringstream and returns the str() of it.</li></ul>
<p>
They can each take up to 10 arguments, which means there can be at most 10 format markers in the format string. If some of the arguments are <a class="el" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a> objects, there will be fewer format markers. Note that in the rare case that the limitation of 10 is inconvenient (which would only happen if for some reason the function call cannot be broken into two parts -- if so I would like to hear from you so I can educate myself), creating a wrapper for N&gt;10 is trivial, just look at the corresponding header file (<a class="el" href="coutf_8hpp.html">iof/coutf.hpp</a> for iof::coutf, etc), and do a copy-paste-edit of the N=10 overload.<h2><a class="anchor" name="sec_persist">
Persistent Formatting: factoring out common format specs</a></h2>
For readabiity and simplicity, it is often desirable to factor out common format specs. One way of doing this is via <a class="el" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a> objects, but another is via "persistent formatting", which is toggled on when a format marker ends with 'S' instead of 's'.<p>
With persistent formatting, the following<p>
<div class="fragment"><pre class="fragment">stream &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%5.2s %5.2s %5.2s %10.2s %10.2s %10.2s\n"</span>) 
       &lt;&lt; ...;
</pre></div><p>
can be written: <div class="fragment"><pre class="fragment">stream &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%5.2S %s %s %10S %s %s\n"</span>) &lt;&lt; ...;
</pre></div><p>
The mechanism is very simple:<p>
<ul>
<li>a format marker that ends with 'S' causes subsequent format markers to combine with it rather than with the stream's format state at entry;</li><li>like <a class="el" href="classiof_1_1fmt__spec.html">iof::fmt_spec</a> output, persistent formatting is cumulative, ie a persistent format marker will combine its FSC with those of the previous persistent format marker (if any -- if not, with the stream's format state at entry);</li><li>you don't need to worry about what happens to text between format markers: persistent formatting, as with non-persistent formatting, is not active while the text of the format string is being output or input.</li></ul>
<h2><a class="anchor" name="sec_flush">
Flush the stream from format string</a></h2>
Flushing a stream is very a common operation. Often, it is done after the final carriage return of a formatted output is sent to a stream, to ensure the message is visible immediately, so it is done by sending a std::endl manipulator to the stream. But with <a class="el" href="classiof_1_1fmtr.html">iof::fmtr</a>, the carriage return is easy to do ('\n'), but what about the flush? Sending a std::flush manipulator is not really "in line" with iof, and requiring that you call stream.flush() is not really nice.<p>
Therefore, the '\f', normally interpreted as a form feed character, is "overloaded" such that when it appears in a format string, it causes flush() to be called on the stream instead of being sent to the stream. E.g.<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"header: %s\nfooter: %s\n\f"</span>) 
          &lt;&lt; header &lt;&lt; footer;
</pre></div><p>
is the same as<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <span class="stringliteral">"header: "</span> &lt;&lt; header &lt;&lt; <span class="stringliteral">"\nfooter: "</span>  
          &lt;&lt; footer &lt;&lt; std::endl;
</pre></div><p>
Note that to output a 'form feed' character to a stream, take it out of the format string and put a format marker where it would be:<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%s"</span>) &lt;&lt; <span class="charliteral">'\f'</span>;
</pre></div><h2><a class="anchor" name="sec_stringizer">
Stringizer: output to a string directly</a></h2>
If a string is to be created, then <a class="el" href="classiof_1_1stringizer.html">iof::stringizer</a> (or the iof::tostr() function if you prefer function syntax rather than operator syntax) is convenient:<p>
<div class="fragment"><pre class="fragment">std::string msg = <a class="code" href="classiof_1_1stringizer.html">iof::stringizer</a>(format_string) &amp; obj1 &amp; obj2 &amp; ...;
</pre></div><p>
Note that '&lt;&lt;' can be used instead of '&amp;', but the latter seems more natural since stringizer is not really a stream (though it does contain one).<p>
Note also that <a class="el" href="classiof_1_1stringizer.html">iof::stringizer</a> is a good way to allow for a format string created at runtime (eg input by user, database, etc), since it checks that all format markers have been used only when it is converted to a string. You would count how many format markers are in the format string (TODO: add this function to library), then loop that many times, giving one more arg every time:<p>
<div class="fragment"><pre class="fragment">std::string f()
{
    std::string userFmtString;
    ... put stuff in userFmtString ...
    size_t numMarkers = iof::countMarkers(userFmtString); <span class="comment">// TODO; for now, you do it</span>
    <a class="code" href="classiof_1_1stringizer.html">iof::stringizer</a> ss(format_string);
    
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii=0; ii&lt;numMarkers; ++ii)
        .. get next obj from somewhere (user input?) ...
        ss &lt;&lt; obj; <span class="comment">// consume one more marker</span>
        
    <span class="keywordflow">return</span> ss; <span class="comment">// ss gets converted to a string</span>
}
</pre></div><h2><a class="anchor" name="sec_diff_printf">
Differences with C's printf format markers</a></h2>
<ul>
<li>In C++, there is no need to specify the type of the object output or input, so all format markers end with 's' (or 'S' to make the formatting persist for subsequent markers). The printf 'f', 'F', etc that close a format marker become FSC in iof.</li><li>FSC in printf/scanf that are not FSC in iof:<ul>
<li>'u' (unsigned): not needed, since the compiler already knows whether a fundamental type is unsigned</li><li>'c' (char): same thing</li><li>'p' (pointer): same thing</li><li>'i' (same as 'd'): 'd' seems to be the de facto standard, I have seen 'i' used once in my whole life</li><li>'n': not possible with STL streams, without extending the stream.</li><li>'*': to specify the width at runtime, use iof::width (TODO): <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"%s"</span>) &lt;&lt; iof::width(width) &lt;&lt; obj;
</pre></div></li></ul>
</li><li>Some FSC apply to the whole object: alignment, etc. The FSC that are particular to a type apply to items within an object (fixed point, etc)</li><li>There are extra FSC: alignment, etc </li></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun Oct 15 23:55:35 2006 for IOF Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
