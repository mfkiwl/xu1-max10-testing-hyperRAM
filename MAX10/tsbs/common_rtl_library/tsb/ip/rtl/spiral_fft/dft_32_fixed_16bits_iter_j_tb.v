/*
 * This source file contains a Verilog description of an IP core
 * automatically generated by the SPIRAL HDL Generator.
 *
 * This product includes a hardware design developed by Carnegie Mellon University.
 *
 * Copyright (c) 2005-2011 by Peter A. Milder for the SPIRAL Project,
 * Carnegie Mellon University
 *
 * For more information, see the SPIRAL project website at:
 *   http://www.spiral.net
 *
 * This design is provided for internal, non-commercial research use only
 * and is not for redistribution, with or without modifications.
 * 
 * You may not use the name "Carnegie Mellon University" or derivations
 * thereof to endorse or promote products derived from this software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS OR BE ERROR-FREE AND ANY
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * TITLE, OR NON-INFRINGEMENT.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * BE LIABLE FOR ANY DAMAGES, INCLUDING BUT NOT LIMITED TO DIRECT, INDIRECT,
 * SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN
 * ANY WAY CONNECTED WITH THIS SOFTWARE (WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT OR OTHERWISE).
 *
 */

/* Portions of this design are protected by US Patent no. 8,321,823
 * (assignee: Carnegie Mellon University).
 */
 
 /*
 DFT Size = 32
direction = forward
data type = 16 bit fixed point, scaled
architecture = iterative reuse
radix = 2
streaming width = 4
data ordering = natural input / natural output
BRAM budget = -1

*/

//   Input/output stream: 4 complex words per cycle
//   Throughput: one transform every 106 cycles
//   Latency: 117 cycles

//   Resources required:
//     8 multipliers (16 x 16 bit)
//     12 adders (16 x 16 bit)
//     2 adders (5 x 5 bit)
//     8 RAMs (16 words, 32 bits per word)
//     4 ROMs (32 words, 16 bits per word)

// Generated on Sat Jul 20 22:09:16 EDT 2019

// Latency: 117 clock cycles
// Throughput: 1 transform every 106 cycles


// We use an interleaved complex data format.  X0 represents the
// real portion of the first input, and X1 represents the imaginary
// portion.  The X variables are system inputs and the Y variables
// are system outputs.

// The design uses a system of flag signals to indicate the
// beginning of the input and output data streams.  The 'next'
// input (asserted high), is used to instruct the system that the
// input stream will begin on the following cycle.

// This system has a 'gap' of 106 cycles.  This means that
// 106 cycles must elapse between the beginning of the input
// vectors.

// The output signal 'next_out' (also asserted high) indicates
// that the output vector will begin streaming out of the system
 // on the following cycle.

// The system has a latency of 117 cycles.  This means that
// the 'next_out' will be asserted 117 cycles after the user
// asserts 'next'.

// The simple testbench below will demonstrate the timing for loading
// and unloading data vectors.
// The system reset signal is asserted high.

// Please note: when simulating floating point code, you must include
// Xilinx's DSP slice simulation module.


module dft_testbench();
   reg clk, reset, next;
   wire next_out;
   integer i, j, k, l, m;
   reg [15:0] counter;
   reg [15:0] in [7:0];
   wire [15:0] X0;
   wire [15:0] Y0;
   wire [15:0] X1;
   wire [15:0] Y1;
   wire [15:0] X2;
   wire [15:0] Y2;
   wire [15:0] X3;
   wire [15:0] Y3;
   wire [15:0] X4;
   wire [15:0] Y4;
   wire [15:0] X5;
   wire [15:0] Y5;
   wire [15:0] X6;
   wire [15:0] Y6;
   wire [15:0] X7;
   wire [15:0] Y7;
   reg clrCnt;
   assign X0 = in[0];
   assign X1 = in[1];
   assign X2 = in[2];
   assign X3 = in[3];
   assign X4 = in[4];
   assign X5 = in[5];
   assign X6 = in[6];
   assign X7 = in[7];

   initial clk = 0;

   always #10000 clk = ~clk;


   // Instantiate top-level module of core 'X' signals are system inputs
   // and 'Y' signals are system outputs
   dft_top dft_top_instance (.clk(clk), .reset(reset), .next(next), .next_out(next_out),
    .X0(X0), .Y0(Y0),
    .X1(X1), .Y1(Y1),
    .X2(X2), .Y2(Y2),
    .X3(X3), .Y3(Y3),
    .X4(X4), .Y4(Y4),
    .X5(X5), .Y5(Y5),
    .X6(X6), .Y6(Y6),
    .X7(X7), .Y7(Y7));

   // You can use this counter to verify that the gap and latency are as expected.
   always @(posedge clk) begin
      if (clrCnt) counter <= 0;
      else counter <= counter+1;
   end


   initial begin
      @(posedge clk);
      @(posedge clk);

      // On the next cycle, begin loading input vector.
      next <= 1;
      clrCnt <= 1;
      @(posedge clk);
      clrCnt <= 0;
      next <= 0;

      // The 32 complex data points enter the system over 8 cycles
      for (j=0; j < 7; j = j+1) begin
          // Input: 4 complex words per cycle
         for (k=0; k < 8; k = k+1) begin
            in[k] <= j*8 + k;
         end
         @(posedge clk);
      end
      j = 7;
      for (k=0; k < 8; k = k+1) begin
         in[k] <= j*8 + k;
      end


      @(posedge clk);
      // Wait until the next data vector can be entered
      while (counter < 104)
        @(posedge clk);

      // On the next cycle, we will start the next data vector
      next <= 1;
      clrCnt <= 1;
      @(posedge clk);
      clrCnt <= 0;
      next <= 0;

      // Start entering next input vector
      for (j=0; j < 7; j = j+1) begin
         // Input 8 words per cycle
         for (k=0; k < 8; k = k+1) begin
            in[k] <= 64 + j*8 + k;
          end
          @(posedge clk);
       end
       j = 7;
       for (k=0; k < 8; k = k+1) begin
          in[k] <= 64 + j*8 + k;
       end
   end


   initial begin
      // set initial values
      in[0] <= 0;
      in[1] <= 0;
      in[2] <= 0;
      in[3] <= 0;
      in[4] <= 0;
      in[5] <= 0;
      in[6] <= 0;
      in[7] <= 0;
      next <= 0;
      reset <= 0;

      @(posedge clk);
      reset <= 1;
      @(posedge clk);
      reset <= 0;
      @(posedge clk);
      @(posedge clk);
      // Wait until next_out goes high, then wait one clock cycle and begin receiving data
      @(posedge next_out);
      @(posedge clk); #1;
      $display("--- begin output 1---");

      for (m=0; m < 7; m=m+1) begin
         $display("%x", Y0);
         $display("%x", Y1);
         $display("%x", Y2);
         $display("%x", Y3);
         $display("%x", Y4);
         $display("%x", Y5);
         $display("%x", Y6);
         $display("%x", Y7);
         @(posedge clk); #1;
      end
      $display("%x", Y0);
      $display("%x", Y1);
      $display("%x", Y2);
      $display("%x", Y3);
      $display("%x", Y4);
      $display("%x", Y5);
      $display("%x", Y6);
      $display("%x", Y7);
      // Wait until next_out goes high, then wait one clock cycle and begin receiving data
      @(posedge next_out);
      @(posedge clk); #1;
      $display("--- begin output 2---");

      for (m=0; m < 7; m=m+1) begin
         $display("%x", Y0);
         $display("%x", Y1);
         $display("%x", Y2);
         $display("%x", Y3);
         $display("%x", Y4);
         $display("%x", Y5);
         $display("%x", Y6);
         $display("%x", Y7);
         @(posedge clk); #1;
      end
      $display("%x", Y0);
      $display("%x", Y1);
      $display("%x", Y2);
      $display("%x", Y3);
      $display("%x", Y4);
      $display("%x", Y5);
      $display("%x", Y6);
      $display("%x", Y7);
      $finish;
   end
endmodule

// Latency: 117
// Gap: 106
// module_name_is:dft_top
module dft_top(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3,
   X4, Y4,
   X5, Y5,
   X6, Y6,
   X7, Y7);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   wire [15:0] t0_0;
   wire [15:0] t0_1;
   wire [15:0] t0_2;
   wire [15:0] t0_3;
   wire [15:0] t0_4;
   wire [15:0] t0_5;
   wire [15:0] t0_6;
   wire [15:0] t0_7;
   wire next_0;
   wire [15:0] t1_0;
   wire [15:0] t1_1;
   wire [15:0] t1_2;
   wire [15:0] t1_3;
   wire [15:0] t1_4;
   wire [15:0] t1_5;
   wire [15:0] t1_6;
   wire [15:0] t1_7;
   wire next_1;
   wire [15:0] t2_0;
   wire [15:0] t2_1;
   wire [15:0] t2_2;
   wire [15:0] t2_3;
   wire [15:0] t2_4;
   wire [15:0] t2_5;
   wire [15:0] t2_6;
   wire [15:0] t2_7;
   wire next_2;
   assign t0_0 = X0;
   assign Y0 = t2_0;
   assign t0_1 = X1;
   assign Y1 = t2_1;
   assign t0_2 = X2;
   assign Y2 = t2_2;
   assign t0_3 = X3;
   assign Y3 = t2_3;
   assign t0_4 = X4;
   assign Y4 = t2_4;
   assign t0_5 = X5;
   assign Y5 = t2_5;
   assign t0_6 = X6;
   assign Y6 = t2_6;
   assign t0_7 = X7;
   assign Y7 = t2_7;
   assign next_0 = next;
   assign next_out = next_2;

// latency=11, gap=8
   rc56678 stage0(.clk(clk), .reset(reset), .next(next_0), .next_out(next_1),
    .X0(t0_0), .Y0(t1_0),
    .X1(t0_1), .Y1(t1_1),
    .X2(t0_2), .Y2(t1_2),
    .X3(t0_3), .Y3(t1_3),
    .X4(t0_4), .Y4(t1_4),
    .X5(t0_5), .Y5(t1_5),
    .X6(t0_6), .Y6(t1_6),
    .X7(t0_7), .Y7(t1_7));


// latency=106, gap=106
   ICompose_57162 IComposeInst57613(.next(next_1), .clk(clk), .reset(reset), .next_out(next_2),
       .X0(t1_0), .Y0(t2_0),
       .X1(t1_1), .Y1(t2_1),
       .X2(t1_2), .Y2(t2_2),
       .X3(t1_3), .Y3(t2_3),
       .X4(t1_4), .Y4(t2_4),
       .X5(t1_5), .Y5(t2_5),
       .X6(t1_6), .Y6(t2_6),
       .X7(t1_7), .Y7(t2_7));


endmodule

// Latency: 11
// Gap: 8
module rc56678(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3,
   X4, Y4,
   X5, Y5,
   X6, Y6,
   X7, Y7);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   wire [31:0] t2;
   wire [31:0] s2;
   assign t2 = {X4, X5};
   wire [31:0] t3;
   wire [31:0] s3;
   assign t3 = {X6, X7};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];
   assign Y4 = s2[31:16];
   assign Y5 = s2[15:0];
   assign Y6 = s3[31:16];
   assign Y7 = s3[15:0];

   perm56676 instPerm57614(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
    .x2(t2), .y2(s2),
    .x3(t3), .y3(s3),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 11
// Gap: 8
module perm56676(clk, next, reset, next_out,
   x0, y0,
   x1, y1,
   x2, y2,
   x3, y3);
   parameter numBanks = 4;
   parameter logBanks = 2;
   parameter depth = 8;
   parameter logDepth = 3;
   parameter width = 32;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input [width-1:0]  x2;
   output [width-1:0]  y2;
   wire [width-1:0]  ybuff2;
   input [width-1:0]  x3;
   output [width-1:0]  y3;
   wire [width-1:0]  ybuff3;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;
   wire [logBanks-1:0] inBank2, outBank2;
   wire [logDepth-1:0] inAddr2, outAddr2;
   wire [logBanks-1:0] outBank_a2;
   wire [logDepth-1:0] outAddr_a2;
   wire [logDepth+logBanks-1:0] addr2, addr2b, addr2c;
   wire [logBanks-1:0] inBank3, outBank3;
   wire [logDepth-1:0] inAddr3, outAddr3;
   wire [logBanks-1:0] outBank_a3;
   wire [logDepth-1:0] outAddr_a3;
   wire [logDepth+logBanks-1:0] addr3, addr3b, addr3c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 2'd0};
   assign    addr0b = {outCount, 2'd0};
   assign    addr0c = {outCount_for_rd_addr, 2'd0};
   assign    addr1 = {inCount, 2'd1};
   assign    addr1b = {outCount, 2'd1};
   assign    addr1c = {outCount_for_rd_addr, 2'd1};
   assign    addr2 = {inCount, 2'd2};
   assign    addr2b = {outCount, 2'd2};
   assign    addr2c = {outCount_for_rd_addr, 2'd2};
   assign    addr3 = {inCount, 2'd3};
   assign    addr3b = {outCount, 2'd3};
   assign    addr3c = {outCount_for_rd_addr, 2'd3};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_0_2, w_0_3, w_1_0, w_1_1, w_1_2, w_1_3, w_2_0, w_2_1, w_2_2, w_2_3;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    reg [width-1:0] z_0_2;
    reg [width-1:0] z_0_3;
    wire [width-1:0] z_1_0, z_1_1, z_1_2, z_1_3, z_2_0, z_2_1, z_2_2, z_2_3;

    wire [logDepth-1:0] u_0_0, u_0_1, u_0_2, u_0_3, u_1_0, u_1_1, u_1_2, u_1_3, u_2_0, u_2_1, u_2_2, u_2_3;

    reg inFlip1, outFlip1;
    always @(posedge clk) begin
        inFlip1 <= inFlip0;
        outFlip1 <= outFlip0;
    end

   assign inBank0[0] = addr0[4] ^ addr0[1];
   assign inBank0[1] = addr0[3] ^ addr0[0];
   assign inAddr0[0] = addr0[2];
   assign inAddr0[1] = addr0[1];
   assign inAddr0[2] = addr0[0];
   assign outBank0[0] = addr0b[3] ^ addr0b[0];
   assign outBank0[1] = addr0b[4] ^ addr0b[1];
   assign outAddr0[0] = addr0b[2];
   assign outAddr0[1] = addr0b[3];
   assign outAddr0[2] = addr0b[4];
   assign outBank_a0[0] = addr0c[3] ^ addr0c[0];
   assign outBank_a0[1] = addr0c[4] ^ addr0c[1];
   assign outAddr_a0[0] = addr0c[2];
   assign outAddr_a0[1] = addr0c[3];
   assign outAddr_a0[2] = addr0c[4];

   assign inBank1[0] = addr1[4] ^ addr1[1];
   assign inBank1[1] = addr1[3] ^ addr1[0];
   assign inAddr1[0] = addr1[2];
   assign inAddr1[1] = addr1[1];
   assign inAddr1[2] = addr1[0];
   assign outBank1[0] = addr1b[3] ^ addr1b[0];
   assign outBank1[1] = addr1b[4] ^ addr1b[1];
   assign outAddr1[0] = addr1b[2];
   assign outAddr1[1] = addr1b[3];
   assign outAddr1[2] = addr1b[4];
   assign outBank_a1[0] = addr1c[3] ^ addr1c[0];
   assign outBank_a1[1] = addr1c[4] ^ addr1c[1];
   assign outAddr_a1[0] = addr1c[2];
   assign outAddr_a1[1] = addr1c[3];
   assign outAddr_a1[2] = addr1c[4];

   assign inBank2[0] = addr2[4] ^ addr2[1];
   assign inBank2[1] = addr2[3] ^ addr2[0];
   assign inAddr2[0] = addr2[2];
   assign inAddr2[1] = addr2[1];
   assign inAddr2[2] = addr2[0];
   assign outBank2[0] = addr2b[3] ^ addr2b[0];
   assign outBank2[1] = addr2b[4] ^ addr2b[1];
   assign outAddr2[0] = addr2b[2];
   assign outAddr2[1] = addr2b[3];
   assign outAddr2[2] = addr2b[4];
   assign outBank_a2[0] = addr2c[3] ^ addr2c[0];
   assign outBank_a2[1] = addr2c[4] ^ addr2c[1];
   assign outAddr_a2[0] = addr2c[2];
   assign outAddr_a2[1] = addr2c[3];
   assign outAddr_a2[2] = addr2c[4];

   assign inBank3[0] = addr3[4] ^ addr3[1];
   assign inBank3[1] = addr3[3] ^ addr3[0];
   assign inAddr3[0] = addr3[2];
   assign inAddr3[1] = addr3[1];
   assign inAddr3[2] = addr3[0];
   assign outBank3[0] = addr3b[3] ^ addr3b[0];
   assign outBank3[1] = addr3b[4] ^ addr3b[1];
   assign outAddr3[0] = addr3b[2];
   assign outAddr3[1] = addr3b[3];
   assign outAddr3[2] = addr3b[4];
   assign outBank_a3[0] = addr3c[3] ^ addr3c[0];
   assign outBank_a3[1] = addr3c[4] ^ addr3c[1];
   assign outAddr_a3[0] = addr3c[2];
   assign outAddr_a3[1] = addr3c[3];
   assign outAddr_a3[2] = addr3c[4];

   shiftRegFIFO #(7, 1) shiftFIFO_57617(.X(next), .Y(next0), .clk(clk));


   shiftRegFIFO #(4, 1) shiftFIFO_57620(.X(next0), .Y(next_out), .clk(clk));


   memArray32_56676 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip1), .outFlip(outFlip1), .next(next), .reset(reset),
        .x0(w_2_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_2_0[logDepth-1:0]),
        .outAddr0(u_2_0), 
        .x1(w_2_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_2_1[logDepth-1:0]),
        .outAddr1(u_2_1), 
        .x2(w_2_2[width+logDepth-1:logDepth]), .y2(ybuff2),
        .inAddr2(w_2_2[logDepth-1:0]),
        .outAddr2(u_2_2), 
        .x3(w_2_3[width+logDepth-1:logDepth]), .y3(ybuff3),
        .inAddr3(w_2_3[logDepth-1:0]),
        .outAddr3(u_2_3), 
        .clk(clk));

    reg resetOutCountRd2_8;
    reg resetOutCountRd2_9;

    always @(posedge clk) begin
        if (reset == 1) begin
            resetOutCountRd2_8 <= 0;
            resetOutCountRd2_9 <= 0;
        end
        else begin
            resetOutCountRd2_8 <= (inCount == 7) ? 1'b1 : 1'b0;
            resetOutCountRd2_9 <= resetOutCountRd2_8;
            if (resetOutCountRd2_9 == 1'b1)
                outCount_for_rd_data <= 0;
            else
                outCount_for_rd_data <= outCount_for_rd_data+1;
        end
    end
   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
      z_0_2 <= 0;
      z_0_3 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 6)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
      z_0_2 <= ybuff2;
      z_0_3 <= ybuff3;
         if (inCount == 6) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 7) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 6)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_2 = {x1, inAddr1};
    assign w_0_1 = {x2, inAddr2};
    assign w_0_3 = {x3, inAddr3};
    assign y0 = z_2_0;
    assign y1 = z_2_1;
    assign y2 = z_2_2;
    assign y3 = z_2_3;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    assign u_0_2 = outAddr_a2;
    assign u_0_3 = outAddr_a3;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[2];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    switch #(logDepth+width) in_sw_0_1(.x0(w_0_2), .x1(w_0_3), .y0(w_1_2), .y1(w_1_3), .ctrl(wr_ctrl_st_0));
    reg [width+logDepth-1:0] w_1_0_pipe;
    reg [width+logDepth-1:0] w_1_1_pipe;
    reg [width+logDepth-1:0] w_1_2_pipe;
    reg [width+logDepth-1:0] w_1_3_pipe;

    always @(posedge clk) begin
        w_1_0_pipe <= w_1_0;
        w_1_1_pipe <= w_1_1;
        w_1_2_pipe <= w_1_2;
        w_1_3_pipe <= w_1_3;
    end

    wire wr_ctrl_st_1;
    reg wr_ctrl_st_1_1;
    always @(posedge clk) begin
        wr_ctrl_st_1_1 <= inCount[1];
    end
    assign wr_ctrl_st_1 = wr_ctrl_st_1_1;

    switch #(logDepth+width) in_sw_1_0(.x0(w_1_0_pipe), .x1(w_1_2_pipe), .y0(w_2_0), .y1(w_2_2), .ctrl(wr_ctrl_st_1));
    switch #(logDepth+width) in_sw_1_1(.x0(w_1_1_pipe), .x1(w_1_3_pipe), .y0(w_2_1), .y1(w_2_3), .ctrl(wr_ctrl_st_1));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[2];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_2), .y0(z_1_0), .y1(z_1_2), .ctrl(rdd_ctrl_st_0));
    switch #(width) out_sw_0_1(.x0(z_0_1), .x1(z_0_3), .y0(z_1_1), .y1(z_1_3), .ctrl(rdd_ctrl_st_0));
    reg [width-1:0] z_1_0_pipe;
    reg [width-1:0] z_1_1_pipe;
    reg [width-1:0] z_1_2_pipe;
    reg [width-1:0] z_1_3_pipe;

    always @(posedge clk) begin
        z_1_0_pipe <= z_1_0;
        z_1_1_pipe <= z_1_1;
        z_1_2_pipe <= z_1_2;
        z_1_3_pipe <= z_1_3;
    end

    wire rdd_ctrl_st_1;
    reg rdd_ctrl_st_1_1;
    always @(posedge clk) begin
        rdd_ctrl_st_1_1 <= outCount_for_rd_data[1];

    end
    assign rdd_ctrl_st_1 = rdd_ctrl_st_1_1;

    switch #(width) out_sw_1_0(.x0(z_1_0_pipe), .x1(z_1_1_pipe), .y0(z_2_0), .y1(z_2_1), .ctrl(rdd_ctrl_st_1));
    switch #(width) out_sw_1_1(.x0(z_1_2_pipe), .x1(z_1_3_pipe), .y0(z_2_2), .y1(z_2_3), .ctrl(rdd_ctrl_st_1));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[2];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_2), .y0(u_1_0), .y1(u_1_2), .ctrl(rda_ctrl_st_0));
    switch #(logDepth) rdaddr_sw_0_1(.x0(u_0_1), .x1(u_0_3), .y0(u_1_1), .y1(u_1_3), .ctrl(rda_ctrl_st_0));
    reg [logDepth-1:0] u_1_0_pipe;
    reg [logDepth-1:0] u_1_1_pipe;
    reg [logDepth-1:0] u_1_2_pipe;
    reg [logDepth-1:0] u_1_3_pipe;

    always @(posedge clk) begin
        u_1_0_pipe <= u_1_0;
        u_1_1_pipe <= u_1_1;
        u_1_2_pipe <= u_1_2;
        u_1_3_pipe <= u_1_3;
    end

    wire rda_ctrl_st_1;
    reg rda_ctrl_st_1_1;
    always @(posedge clk) begin
        rda_ctrl_st_1_1 <= outCount_for_rd_addr[1];

    end
    assign rda_ctrl_st_1 = rda_ctrl_st_1_1;

    switch #(logDepth) rdaddr_sw_1_0(.x0(u_1_0_pipe), .x1(u_1_1_pipe), .y0(u_2_0), .y1(u_2_1), .ctrl(rda_ctrl_st_1));
    switch #(logDepth) rdaddr_sw_1_1(.x0(u_1_2_pipe), .x1(u_1_3_pipe), .y0(u_2_2), .y1(u_2_3), .ctrl(rda_ctrl_st_1));
endmodule

module memArray32_56676(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                x2, y2,
                inAddr2,
                outAddr2,
                x3, y3,
                inAddr3,
                outAddr3,
                clk, inFlip, outFlip);

   parameter numBanks = 4;
   parameter logBanks = 2;
   parameter depth = 8;
   parameter logDepth = 3;
   parameter width = 32;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   input [width-1:0]   x2;
   output [width-1:0]  y2;
   input [logDepth-1:0] inAddr2, outAddr2;
   input [width-1:0]   x3;
   output [width-1:0]  y3;
   input [logDepth-1:0] inAddr3, outAddr3;
   shiftRegFIFO #(8, 1) shiftFIFO_57623(.X(next), .Y(next0), .clk(clk));


   memMod_dist #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod_dist #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
   memMod_dist #(depth*2, width, logDepth+1) 
     memMod2(.in(x2), .out(y2), .inAddr({inFlip, inAddr2}),
	   .outAddr({outFlip, outAddr2}), .writeSel(1'b1), .clk(clk));   
   memMod_dist #(depth*2, width, logDepth+1) 
     memMod3(.in(x3), .out(y3), .inAddr({inFlip, inAddr3}),
	   .outAddr({outFlip, outAddr3}), .writeSel(1'b1), .clk(clk));   
endmodule

module shiftRegFIFO(X, Y, clk);
   parameter depth=1, width=1;

   output [width-1:0] Y;
   input  [width-1:0] X;
   input              clk;

   reg [width-1:0]    mem [depth-1:0];
   integer            index;

   assign Y = mem[depth-1];

   always @ (posedge clk) begin
      for(index=1;index<depth;index=index+1) begin
         mem[index] <= mem[index-1];
      end
      mem[0]<=X;
   end
endmodule


module memMod(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is block

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 



module memMod_dist(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is distributed

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 

module switch(ctrl, x0, x1, y0, y1);
    parameter width = 16;
    input [width-1:0] x0, x1;
    output [width-1:0] y0, y1;
    input ctrl;
    assign y0 = (ctrl == 0) ? x0 : x1;
    assign y1 = (ctrl == 0) ? x1 : x0;
endmodule

// Latency: 106
// Gap: 106
module ICompose_57162(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3,
      X4, Y4,
      X5, Y5,
      X6, Y6,
      X7, Y7);

   output next_out;
   reg next_out;
   input clk, reset, next;

   reg [4:0] cycle_count;
   reg [3:0] count;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   reg [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   reg int_next;
   reg state;
   wire [15:0] t0; 
   reg [15:0] s0;
   wire [15:0] t1; 
   reg [15:0] s1;
   wire [15:0] t2; 
   reg [15:0] s2;
   wire [15:0] t3; 
   reg [15:0] s3;
   wire [15:0] t4; 
   reg [15:0] s4;
   wire [15:0] t5; 
   reg [15:0] s5;
   wire [15:0] t6; 
   reg [15:0] s6;
   wire [15:0] t7; 
   reg [15:0] s7;

   reg [1:0] iri_state;
   wire int_next_out;
   reg [3:0] i1;

   statementList57160 instList57624 (.clk(clk), .reset(reset), .next(int_next), .next_out(int_next_out),
      .i1_in(i1),
    .X0(s0), .Y0(t0),
    .X1(s1), .Y1(t1),
    .X2(s2), .Y2(t2),
    .X3(s3), .Y3(t3),
    .X4(s4), .Y4(t4),
    .X5(s5), .Y5(t5),
    .X6(s6), .Y6(t6),
    .X7(s7), .Y7(t7));

   always @(posedge clk) begin
      if (reset == 1) begin
         int_next <= 0;
         i1 <= 4;
         cycle_count <= 0;
         next_out <= 0;
         iri_state <= 0;
         Y0 <= 0;
         Y1 <= 0;
         Y2 <= 0;
         Y3 <= 0;
         Y4 <= 0;
         Y5 <= 0;
         Y6 <= 0;
         Y7 <= 0;
      end
      else begin
         Y0 <= t0;
         Y1 <= t1;
         Y2 <= t2;
         Y3 <= t3;
         Y4 <= t4;
         Y5 <= t5;
         Y6 <= t6;
         Y7 <= t7;
         next_out <= 0;
         case (iri_state)
            0: begin
               i1 <= 4;
               cycle_count <= 0;
               if (next == 1) begin
                  int_next <= 1;
                  iri_state <= 1;
                  
               end
               else begin
                  int_next <= 0;
                  iri_state <= 0;
               end
            end
            1: begin
               int_next <= 0;
               cycle_count <= cycle_count + 1;
               i1 <= i1;
               if (cycle_count < 19)
                  iri_state <= 1;
               else
                  iri_state <= 2;
            end
            2: begin
               cycle_count <= 0;
               i1 <= i1 - 1;
               if (i1 > 0) begin
                  iri_state <= 1;
                  int_next <= 1;
               end
               else begin
                  iri_state <= 0;
                  next_out <= 1;
                  int_next <= 0;
               end
            end
         endcase               
      end
   end

   always @(posedge clk) begin
      if (reset == 1) begin
         state <= 0;
         count <= 0;
         s0 <= 0;
         s1 <= 0;
         s2 <= 0;
         s3 <= 0;
         s4 <= 0;
         s5 <= 0;
         s6 <= 0;
         s7 <= 0;
      end      
      else begin
         case (state)
            0: begin
               count <= 0;
               if (next == 1) begin
                  state <= 1;
                  count <= 0;
                  s0 <= X0; 
                  s1 <= X1; 
                  s2 <= X2; 
                  s3 <= X3; 
                  s4 <= X4; 
                  s5 <= X5; 
                  s6 <= X6; 
                  s7 <= X7; 
               end
               else begin
                  state <= 0;
                  count <= 0;
                  s0 <= t0; 
                  s1 <= t1; 
                  s2 <= t2; 
                  s3 <= t3; 
                  s4 <= t4; 
                  s5 <= t5; 
                  s6 <= t6; 
                  s7 <= t7; 
               end               
            end
            1: begin
               count <= count + 1;
               if (count < 8) begin
                  s0 <= X0; 
                  s1 <= X1; 
                  s2 <= X2; 
                  s3 <= X3; 
                  s4 <= X4; 
                  s5 <= X5; 
                  s6 <= X6; 
                  s7 <= X7; 
                  state <= 1;                    
               end
               else begin
                  s0 <= t0; 
                  s1 <= t1; 
                  s2 <= t2; 
                  s3 <= t3; 
                  s4 <= t4; 
                  s5 <= t5; 
                  s6 <= t6; 
                  s7 <= t7; 
                  state <= 0;
               end
            end
         endcase               
      end
   end
endmodule

// Latency: 20
// Gap: 8
// module_name_is:statementList57160
module statementList57160(clk, reset, next, next_out,
   i1_in,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3,
   X4, Y4,
   X5, Y5,
   X6, Y6,
   X7, Y7);

   output next_out;
   input clk, reset, next;

   input [3:0] i1_in;
   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   wire [15:0] t0_0;
   wire [15:0] t0_1;
   wire [15:0] t0_2;
   wire [15:0] t0_3;
   wire [15:0] t0_4;
   wire [15:0] t0_5;
   wire [15:0] t0_6;
   wire [15:0] t0_7;
   wire next_0;
   wire [15:0] t1_0;
   wire [15:0] t1_1;
   wire [15:0] t1_2;
   wire [15:0] t1_3;
   wire [15:0] t1_4;
   wire [15:0] t1_5;
   wire [15:0] t1_6;
   wire [15:0] t1_7;
   wire next_1;
   wire [15:0] t2_0;
   wire [15:0] t2_1;
   wire [15:0] t2_2;
   wire [15:0] t2_3;
   wire [15:0] t2_4;
   wire [15:0] t2_5;
   wire [15:0] t2_6;
   wire [15:0] t2_7;
   wire next_2;
   wire [15:0] t3_0;
   wire [15:0] t3_1;
   wire [15:0] t3_2;
   wire [15:0] t3_3;
   wire [15:0] t3_4;
   wire [15:0] t3_5;
   wire [15:0] t3_6;
   wire [15:0] t3_7;
   wire next_3;
   wire [3:0] i1;
   wire [3:0] i1_0;
   assign t0_0 = X0;
   assign Y0 = t3_0;
   assign t0_1 = X1;
   assign Y1 = t3_1;
   assign t0_2 = X2;
   assign Y2 = t3_2;
   assign t0_3 = X3;
   assign Y3 = t3_3;
   assign t0_4 = X4;
   assign Y4 = t3_4;
   assign t0_5 = X5;
   assign Y5 = t3_5;
   assign t0_6 = X6;
   assign Y6 = t3_6;
   assign t0_7 = X7;
   assign Y7 = t3_7;
   assign next_0 = next;
   assign next_out = next_3;

   assign i1_0 = i1_in;

// latency=11, gap=8
   DirSum_56999 DirSumInst57627(.next(next_0), .clk(clk), .reset(reset), .next_out(next_1),
.i1(i1_0),
       .X0(t0_0), .Y0(t1_0),
       .X1(t0_1), .Y1(t1_1),
       .X2(t0_2), .Y2(t1_2),
       .X3(t0_3), .Y3(t1_3),
       .X4(t0_4), .Y4(t1_4),
       .X5(t0_5), .Y5(t1_5),
       .X6(t0_6), .Y6(t1_6),
       .X7(t0_7), .Y7(t1_7));


// latency=2, gap=8
   codeBlock57001 codeBlockIsnt57628(.clk(clk), .reset(reset), .next_in(next_1), .next_out(next_2),
       .X0_in(t1_0), .Y0(t2_0),
       .X1_in(t1_1), .Y1(t2_1),
       .X2_in(t1_2), .Y2(t2_2),
       .X3_in(t1_3), .Y3(t2_3),
       .X4_in(t1_4), .Y4(t2_4),
       .X5_in(t1_5), .Y5(t2_5),
       .X6_in(t1_6), .Y6(t2_6),
       .X7_in(t1_7), .Y7(t2_7));


// latency=7, gap=8
   rc57158 instrc57629(.clk(clk), .reset(reset), .next(next_2), .next_out(next_3),
    .X0(t2_0), .Y0(t3_0),
    .X1(t2_1), .Y1(t3_1),
    .X2(t2_2), .Y2(t3_2),
    .X3(t2_3), .Y3(t3_3),
    .X4(t2_4), .Y4(t3_4),
    .X5(t2_5), .Y5(t3_5),
    .X6(t2_6), .Y6(t3_6),
    .X7(t2_7), .Y7(t3_7));


endmodule

// Latency: 11
// Gap: 8
module DirSum_56999(clk, reset, next, next_out,
      i1,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3,
      X4, Y4,
      X5, Y5,
      X6, Y6,
      X7, Y7);

   output next_out;
   input clk, reset, next;

   input [3:0] i1;
   reg [2:0] i2;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   always @(posedge clk) begin
      if (reset == 1) begin
         i2 <= 0;
      end
      else begin
         if (next == 1)
            i2 <= 0;
         else if (i2 == 7)
            i2 <= 0;
         else
            i2 <= i2 + 1;
      end
   end

   codeBlock56680 codeBlockIsnt57630(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i2_in(i2),
.i1_in(i1),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3),
       .X4_in(X4), .Y4(Y4),
       .X5_in(X5), .Y5(Y5),
       .X6_in(X6), .Y6(Y6),
       .X7_in(X7), .Y7(Y7));

endmodule

module D2_56963(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [4:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h0;
      1: out3 <= 16'hf384;
      2: out3 <= 16'he782;
      3: out3 <= 16'hdc72;
      4: out3 <= 16'hd2bf;
      5: out3 <= 16'hcac9;
      6: out3 <= 16'hc4df;
      7: out3 <= 16'hc13b;
      8: out3 <= 16'hc000;
      9: out3 <= 16'hc13b;
      10: out3 <= 16'hc4df;
      11: out3 <= 16'hcac9;
      12: out3 <= 16'hd2bf;
      13: out3 <= 16'hdc72;
      14: out3 <= 16'he782;
      15: out3 <= 16'hf384;
      16: out3 <= 16'h0;
      17: out3 <= 16'he782;
      18: out3 <= 16'hd2bf;
      19: out3 <= 16'hc4df;
      20: out3 <= 16'hc000;
      21: out3 <= 16'hc4df;
      22: out3 <= 16'hd2bf;
      23: out3 <= 16'he782;
      24: out3 <= 16'h0;
      25: out3 <= 16'h187e;
      26: out3 <= 16'h2d41;
      27: out3 <= 16'h3b21;
      28: out3 <= 16'h4000;
      29: out3 <= 16'h3b21;
      30: out3 <= 16'h2d41;
      31: out3 <= 16'h187e;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



module D1_56997(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [4:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h4000;
      1: out3 <= 16'h3ec5;
      2: out3 <= 16'h3b21;
      3: out3 <= 16'h3537;
      4: out3 <= 16'h2d41;
      5: out3 <= 16'h238e;
      6: out3 <= 16'h187e;
      7: out3 <= 16'hc7c;
      8: out3 <= 16'h0;
      9: out3 <= 16'hf384;
      10: out3 <= 16'he782;
      11: out3 <= 16'hdc72;
      12: out3 <= 16'hd2bf;
      13: out3 <= 16'hcac9;
      14: out3 <= 16'hc4df;
      15: out3 <= 16'hc13b;
      16: out3 <= 16'h4000;
      17: out3 <= 16'h3b21;
      18: out3 <= 16'h2d41;
      19: out3 <= 16'h187e;
      20: out3 <= 16'h0;
      21: out3 <= 16'he782;
      22: out3 <= 16'hd2bf;
      23: out3 <= 16'hc4df;
      24: out3 <= 16'hc000;
      25: out3 <= 16'hc4df;
      26: out3 <= 16'hd2bf;
      27: out3 <= 16'he782;
      28: out3 <= 16'h0;
      29: out3 <= 16'h187e;
      30: out3 <= 16'h2d41;
      31: out3 <= 16'h3b21;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "distributed"
endmodule



// Latency: 11
// Gap: 1
module codeBlock56680(clk, reset, next_in, next_out,
   i2_in,
   i1_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3,
   X4_in, Y4,
   X5_in, Y5,
   X6_in, Y6,
   X7_in, Y7);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [2:0] i2_in;
   reg [2:0] i2;
   input [3:0] i1_in;
   reg [3:0] i1;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   shiftRegFIFO #(10, 1) shiftFIFO_57633(.X(next), .Y(next_out), .clk(clk));


   wire  [4:0] a113;
   wire  [3:0] a115;
   wire  [4:0] a116;
   wire signed [15:0] a136;
   wire signed [15:0] a137;
   wire signed [15:0] a140;
   wire signed [15:0] a141;
   wire  [5:0] a114;
   wire  [5:0] a126;
   reg  [4:0] tm27;
   reg signed [15:0] tm28;
   reg signed [15:0] tm35;
   reg signed [15:0] tm57;
   reg signed [15:0] tm64;
   reg signed [15:0] tm85;
   reg signed [15:0] tm95;
   reg signed [15:0] tm105;
   reg signed [15:0] tm115;
   reg  [5:0] a117;
   wire  [4:0] a118;
   reg  [5:0] a127;
   wire  [4:0] a128;
   reg signed [15:0] tm29;
   reg signed [15:0] tm36;
   reg signed [15:0] tm58;
   reg signed [15:0] tm65;
   reg signed [15:0] tm86;
   reg signed [15:0] tm96;
   reg signed [15:0] tm106;
   reg signed [15:0] tm116;
   wire  [5:0] a119;
   wire  [5:0] a129;
   reg signed [15:0] tm30;
   reg signed [15:0] tm37;
   reg signed [15:0] tm59;
   reg signed [15:0] tm66;
   reg signed [15:0] tm87;
   reg signed [15:0] tm97;
   reg signed [15:0] tm107;
   reg signed [15:0] tm117;
   reg signed [15:0] tm31;
   reg signed [15:0] tm38;
   reg signed [15:0] tm60;
   reg signed [15:0] tm67;
   reg signed [15:0] tm88;
   reg signed [15:0] tm98;
   reg signed [15:0] tm108;
   reg signed [15:0] tm118;
   reg signed [15:0] tm32;
   reg signed [15:0] tm39;
   reg signed [15:0] tm61;
   reg signed [15:0] tm68;
   reg signed [15:0] tm89;
   reg signed [15:0] tm99;
   reg signed [15:0] tm109;
   reg signed [15:0] tm119;
   wire signed [15:0] tm5;
   wire signed [15:0] a120;
   wire signed [15:0] tm6;
   wire signed [15:0] a122;
   wire signed [15:0] tm9;
   wire signed [15:0] a130;
   wire signed [15:0] tm10;
   wire signed [15:0] a132;
   reg signed [15:0] tm33;
   reg signed [15:0] tm40;
   reg signed [15:0] tm62;
   reg signed [15:0] tm69;
   reg signed [15:0] tm90;
   reg signed [15:0] tm100;
   reg signed [15:0] tm110;
   reg signed [15:0] tm120;
   reg signed [15:0] tm11;
   reg signed [15:0] tm12;
   reg signed [15:0] tm15;
   reg signed [15:0] tm16;
   reg signed [15:0] tm34;
   reg signed [15:0] tm41;
   reg signed [15:0] tm63;
   reg signed [15:0] tm70;
   reg signed [15:0] tm91;
   reg signed [15:0] tm101;
   reg signed [15:0] tm111;
   reg signed [15:0] tm121;
   reg signed [15:0] tm92;
   reg signed [15:0] tm102;
   reg signed [15:0] tm112;
   reg signed [15:0] tm122;
   wire signed [15:0] a121;
   wire signed [15:0] a123;
   wire signed [15:0] a124;
   wire signed [15:0] a125;
   wire signed [15:0] a131;
   wire signed [15:0] a133;
   wire signed [15:0] a134;
   wire signed [15:0] a135;
   reg signed [15:0] tm93;
   reg signed [15:0] tm103;
   reg signed [15:0] tm113;
   reg signed [15:0] tm123;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   wire signed [15:0] Y4;
   wire signed [15:0] Y5;
   wire signed [15:0] Y6;
   wire signed [15:0] Y7;
   reg signed [15:0] tm94;
   reg signed [15:0] tm104;
   reg signed [15:0] tm114;
   reg signed [15:0] tm124;

   wire [0:0] tm1;
   assign tm1 = 1'h1;
   wire [3:0] tm2;
   assign tm2 = 4'hf;
   wire [4:0] tm4;
   assign tm4 = 5'h10;
   wire [1:0] tm7;
   assign tm7 = 2'h3;

   assign a113 = i2 << 2;
   assign a115 = tm2 << i1;
   assign a116 = {a115, tm1[0:0]};
   assign a136 = X2;
   assign a137 = X3;
   assign a140 = X6;
   assign a141 = X7;
   assign a118 = {a117[0:0], a117[4:1]};
   assign a128 = {a127[0:0], a127[4:1]};
   assign a120 = tm5;
   assign a122 = tm6;
   assign a130 = tm9;
   assign a132 = tm10;
   assign Y0 = tm94;
   assign Y1 = tm104;
   assign Y4 = tm114;
   assign Y5 = tm124;

   D2_56963 instD2inst0_56963(.addr(a119[4:0]), .out(tm6), .clk(clk));

   D2_56963 instD2inst1_56963(.addr(a129[4:0]), .out(tm10), .clk(clk));

   D1_56997 instD1inst0_56997(.addr(a119[4:0]), .out(tm5), .clk(clk));

   D1_56997 instD1inst1_56997(.addr(a129[4:0]), .out(tm9), .clk(clk));

    addfxp #(6, 1) add56699(.a({1'b0, a113}), .b({5'b0, tm1}), .clk(clk), .q(a114));    // 0
    addfxp #(6, 1) add56826(.a({1'b0, a113}), .b({4'b0, tm7}), .clk(clk), .q(a126));    // 0
    subfxp #(6, 1) sub56731(.a({1'b0, a118}), .b({1'b0, tm4}), .clk(clk), .q(a119));    // 2
    subfxp #(6, 1) sub56846(.a({1'b0, a128}), .b({1'b0, tm4}), .clk(clk), .q(a129));    // 2
    multfix #(16, 2) m56753(.a(tm11), .b(tm34), .clk(clk), .q_sc(a121), .q_unsc(), .rst(reset));
    multfix #(16, 2) m56775(.a(tm12), .b(tm41), .clk(clk), .q_sc(a123), .q_unsc(), .rst(reset));
    multfix #(16, 2) m56793(.a(tm12), .b(tm34), .clk(clk), .q_sc(a124), .q_unsc(), .rst(reset));
    multfix #(16, 2) m56804(.a(tm11), .b(tm41), .clk(clk), .q_sc(a125), .q_unsc(), .rst(reset));
    multfix #(16, 2) m56868(.a(tm15), .b(tm63), .clk(clk), .q_sc(a131), .q_unsc(), .rst(reset));
    multfix #(16, 2) m56890(.a(tm16), .b(tm70), .clk(clk), .q_sc(a133), .q_unsc(), .rst(reset));
    multfix #(16, 2) m56908(.a(tm16), .b(tm63), .clk(clk), .q_sc(a134), .q_unsc(), .rst(reset));
    multfix #(16, 2) m56919(.a(tm15), .b(tm70), .clk(clk), .q_sc(a135), .q_unsc(), .rst(reset));
    subfxp #(16, 1) sub56782(.a(a121), .b(a123), .clk(clk), .q(Y2));    // 9
    addfxp #(16, 1) add56811(.a(a124), .b(a125), .clk(clk), .q(Y3));    // 9
    subfxp #(16, 1) sub56897(.a(a131), .b(a133), .clk(clk), .q(Y6));    // 9
    addfxp #(16, 1) add56926(.a(a134), .b(a135), .clk(clk), .q(Y7));    // 9


   always @(posedge clk) begin
      if (reset == 1) begin
         tm11 <= 0;
         tm34 <= 0;
         tm12 <= 0;
         tm41 <= 0;
         tm12 <= 0;
         tm34 <= 0;
         tm11 <= 0;
         tm41 <= 0;
         tm15 <= 0;
         tm63 <= 0;
         tm16 <= 0;
         tm70 <= 0;
         tm16 <= 0;
         tm63 <= 0;
         tm15 <= 0;
         tm70 <= 0;
      end
      else begin
         i2 <= i2_in;
         i1 <= i1_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         X4 <= X4_in;
         X5 <= X5_in;
         X6 <= X6_in;
         X7 <= X7_in;
         next <= next_in;
         tm27 <= a116;
         tm28 <= a136;
         tm35 <= a137;
         tm57 <= a140;
         tm64 <= a141;
         tm85 <= X0;
         tm95 <= X1;
         tm105 <= X4;
         tm115 <= X5;
         a117 <= (a114 & tm27);
         a127 <= (a126 & tm27);
         tm29 <= tm28;
         tm36 <= tm35;
         tm58 <= tm57;
         tm65 <= tm64;
         tm86 <= tm85;
         tm96 <= tm95;
         tm106 <= tm105;
         tm116 <= tm115;
         tm30 <= tm29;
         tm37 <= tm36;
         tm59 <= tm58;
         tm66 <= tm65;
         tm87 <= tm86;
         tm97 <= tm96;
         tm107 <= tm106;
         tm117 <= tm116;
         tm31 <= tm30;
         tm38 <= tm37;
         tm60 <= tm59;
         tm67 <= tm66;
         tm88 <= tm87;
         tm98 <= tm97;
         tm108 <= tm107;
         tm118 <= tm117;
         tm32 <= tm31;
         tm39 <= tm38;
         tm61 <= tm60;
         tm68 <= tm67;
         tm89 <= tm88;
         tm99 <= tm98;
         tm109 <= tm108;
         tm119 <= tm118;
         tm33 <= tm32;
         tm40 <= tm39;
         tm62 <= tm61;
         tm69 <= tm68;
         tm90 <= tm89;
         tm100 <= tm99;
         tm110 <= tm109;
         tm120 <= tm119;
         tm11 <= a120;
         tm12 <= a122;
         tm15 <= a130;
         tm16 <= a132;
         tm34 <= tm33;
         tm41 <= tm40;
         tm63 <= tm62;
         tm70 <= tm69;
         tm91 <= tm90;
         tm101 <= tm100;
         tm111 <= tm110;
         tm121 <= tm120;
         tm92 <= tm91;
         tm102 <= tm101;
         tm112 <= tm111;
         tm122 <= tm121;
         tm93 <= tm92;
         tm103 <= tm102;
         tm113 <= tm112;
         tm123 <= tm122;
         tm94 <= tm93;
         tm104 <= tm103;
         tm114 <= tm113;
         tm124 <= tm123;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock57001(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3,
   X4_in, Y4,
   X5_in, Y5,
   X6_in, Y6,
   X7_in, Y7);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   shiftRegFIFO #(1, 1) shiftFIFO_57636(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a17;
   wire signed [15:0] a18;
   wire signed [15:0] a19;
   wire signed [15:0] a20;
   wire signed [15:0] a25;
   wire signed [15:0] a26;
   wire signed [15:0] a27;
   wire signed [15:0] a28;
   wire signed [16:0] tm19;
   wire signed [16:0] tm20;
   wire signed [16:0] tm21;
   wire signed [16:0] tm22;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   wire signed [16:0] tm23;
   wire signed [16:0] tm24;
   wire signed [16:0] tm25;
   wire signed [16:0] tm26;
   wire signed [15:0] Y4;
   wire signed [15:0] Y5;
   wire signed [15:0] Y6;
   wire signed [15:0] Y7;
   wire signed [15:0] t49;
   wire signed [15:0] t50;
   wire signed [15:0] t51;
   wire signed [15:0] t52;
   wire signed [15:0] t53;
   wire signed [15:0] t54;
   wire signed [15:0] t55;
   wire signed [15:0] t56;


   assign a17 = X0;
   assign a18 = X2;
   assign a19 = X1;
   assign a20 = X3;
   assign a25 = X4;
   assign a26 = X6;
   assign a27 = X5;
   assign a28 = X7;
   assign Y0 = t49;
   assign Y1 = t50;
   assign Y2 = t51;
   assign Y3 = t52;
   assign Y4 = t53;
   assign Y5 = t54;
   assign Y6 = t55;
   assign Y7 = t56;
   assign t49 = tm19[16:1];
   assign t50 = tm20[16:1];
   assign t51 = tm21[16:1];
   assign t52 = tm22[16:1];
   assign t53 = tm23[16:1];
   assign t54 = tm24[16:1];
   assign t55 = tm25[16:1];
   assign t56 = tm26[16:1];

    addfxp #(17, 1) add57013(.a({{1{a17[15]}}, a17}), .b({{1{a18[15]}}, a18}), .clk(clk), .q(tm19));    // 0
    addfxp #(17, 1) add57028(.a({{1{a19[15]}}, a19}), .b({{1{a20[15]}}, a20}), .clk(clk), .q(tm20));    // 0
    subfxp #(17, 1) sub57043(.a({{1{a17[15]}}, a17}), .b({{1{a18[15]}}, a18}), .clk(clk), .q(tm21));    // 0
    subfxp #(17, 1) sub57058(.a({{1{a19[15]}}, a19}), .b({{1{a20[15]}}, a20}), .clk(clk), .q(tm22));    // 0
    addfxp #(17, 1) add57089(.a({{1{a25[15]}}, a25}), .b({{1{a26[15]}}, a26}), .clk(clk), .q(tm23));    // 0
    addfxp #(17, 1) add57104(.a({{1{a27[15]}}, a27}), .b({{1{a28[15]}}, a28}), .clk(clk), .q(tm24));    // 0
    subfxp #(17, 1) sub57119(.a({{1{a25[15]}}, a25}), .b({{1{a26[15]}}, a26}), .clk(clk), .q(tm25));    // 0
    subfxp #(17, 1) sub57134(.a({{1{a27[15]}}, a27}), .b({{1{a28[15]}}, a28}), .clk(clk), .q(tm26));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         X4 <= X4_in;
         X5 <= X5_in;
         X6 <= X6_in;
         X7 <= X7_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 7
// Gap: 8
module rc57158(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3,
   X4, Y4,
   X5, Y5,
   X6, Y6,
   X7, Y7);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3,
      X4,
      X5,
      X6,
      X7;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3,
      Y4,
      Y5,
      Y6,
      Y7;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   wire [31:0] t2;
   wire [31:0] s2;
   assign t2 = {X4, X5};
   wire [31:0] t3;
   wire [31:0] s3;
   assign t3 = {X6, X7};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];
   assign Y4 = s2[31:16];
   assign Y5 = s2[15:0];
   assign Y6 = s3[31:16];
   assign Y7 = s3[15:0];

   perm57156 instPerm57637(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
    .x2(t2), .y2(s2),
    .x3(t3), .y3(s3),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

// Latency: 7
// Gap: 8
module perm57156(clk, next, reset, next_out,
   x0, y0,
   x1, y1,
   x2, y2,
   x3, y3);
   parameter numBanks = 4;
   parameter logBanks = 2;
   parameter depth = 8;
   parameter logDepth = 3;
   parameter width = 32;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input [width-1:0]  x2;
   output [width-1:0]  y2;
   wire [width-1:0]  ybuff2;
   input [width-1:0]  x3;
   output [width-1:0]  y3;
   wire [width-1:0]  ybuff3;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;
   wire [logBanks-1:0] inBank2, outBank2;
   wire [logDepth-1:0] inAddr2, outAddr2;
   wire [logBanks-1:0] outBank_a2;
   wire [logDepth-1:0] outAddr_a2;
   wire [logDepth+logBanks-1:0] addr2, addr2b, addr2c;
   wire [logBanks-1:0] inBank3, outBank3;
   wire [logDepth-1:0] inAddr3, outAddr3;
   wire [logBanks-1:0] outBank_a3;
   wire [logDepth-1:0] outAddr_a3;
   wire [logDepth+logBanks-1:0] addr3, addr3b, addr3c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 2'd0};
   assign    addr0b = {outCount, 2'd0};
   assign    addr0c = {outCount_for_rd_addr, 2'd0};
   assign    addr1 = {inCount, 2'd1};
   assign    addr1b = {outCount, 2'd1};
   assign    addr1c = {outCount_for_rd_addr, 2'd1};
   assign    addr2 = {inCount, 2'd2};
   assign    addr2b = {outCount, 2'd2};
   assign    addr2c = {outCount_for_rd_addr, 2'd2};
   assign    addr3 = {inCount, 2'd3};
   assign    addr3b = {outCount, 2'd3};
   assign    addr3c = {outCount_for_rd_addr, 2'd3};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_0_2, w_0_3, w_1_0, w_1_1, w_1_2, w_1_3;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    reg [width-1:0] z_0_2;
    reg [width-1:0] z_0_3;
    wire [width-1:0] z_1_0, z_1_1, z_1_2, z_1_3;

    wire [logDepth-1:0] u_0_0, u_0_1, u_0_2, u_0_3, u_1_0, u_1_1, u_1_2, u_1_3;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[1];
   assign inBank0[1] = addr0[2] ^ addr0[0];
   assign inAddr0[0] = addr0[3];
   assign inAddr0[1] = addr0[4];
   assign inAddr0[2] = addr0[0];
   assign outBank0[0] = addr0b[0];
   assign outBank0[1] = addr0b[4] ^ addr0b[1];
   assign outAddr0[0] = addr0b[2];
   assign outAddr0[1] = addr0b[3];
   assign outAddr0[2] = addr0b[4];
   assign outBank_a0[0] = addr0c[0];
   assign outBank_a0[1] = addr0c[4] ^ addr0c[1];
   assign outAddr_a0[0] = addr0c[2];
   assign outAddr_a0[1] = addr0c[3];
   assign outAddr_a0[2] = addr0c[4];

   assign inBank1[0] = addr1[1];
   assign inBank1[1] = addr1[2] ^ addr1[0];
   assign inAddr1[0] = addr1[3];
   assign inAddr1[1] = addr1[4];
   assign inAddr1[2] = addr1[0];
   assign outBank1[0] = addr1b[0];
   assign outBank1[1] = addr1b[4] ^ addr1b[1];
   assign outAddr1[0] = addr1b[2];
   assign outAddr1[1] = addr1b[3];
   assign outAddr1[2] = addr1b[4];
   assign outBank_a1[0] = addr1c[0];
   assign outBank_a1[1] = addr1c[4] ^ addr1c[1];
   assign outAddr_a1[0] = addr1c[2];
   assign outAddr_a1[1] = addr1c[3];
   assign outAddr_a1[2] = addr1c[4];

   assign inBank2[0] = addr2[1];
   assign inBank2[1] = addr2[2] ^ addr2[0];
   assign inAddr2[0] = addr2[3];
   assign inAddr2[1] = addr2[4];
   assign inAddr2[2] = addr2[0];
   assign outBank2[0] = addr2b[0];
   assign outBank2[1] = addr2b[4] ^ addr2b[1];
   assign outAddr2[0] = addr2b[2];
   assign outAddr2[1] = addr2b[3];
   assign outAddr2[2] = addr2b[4];
   assign outBank_a2[0] = addr2c[0];
   assign outBank_a2[1] = addr2c[4] ^ addr2c[1];
   assign outAddr_a2[0] = addr2c[2];
   assign outAddr_a2[1] = addr2c[3];
   assign outAddr_a2[2] = addr2c[4];

   assign inBank3[0] = addr3[1];
   assign inBank3[1] = addr3[2] ^ addr3[0];
   assign inAddr3[0] = addr3[3];
   assign inAddr3[1] = addr3[4];
   assign inAddr3[2] = addr3[0];
   assign outBank3[0] = addr3b[0];
   assign outBank3[1] = addr3b[4] ^ addr3b[1];
   assign outAddr3[0] = addr3b[2];
   assign outAddr3[1] = addr3b[3];
   assign outAddr3[2] = addr3b[4];
   assign outBank_a3[0] = addr3c[0];
   assign outBank_a3[1] = addr3c[4] ^ addr3c[1];
   assign outAddr_a3[0] = addr3c[2];
   assign outAddr_a3[1] = addr3c[3];
   assign outAddr_a3[2] = addr3c[4];

   shiftRegFIFO #(5, 1) shiftFIFO_57640(.X(next), .Y(next0), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_57643(.X(next0), .Y(next_out), .clk(clk));


   memArray32_57156 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .x2(w_1_2[width+logDepth-1:logDepth]), .y2(ybuff2),
        .inAddr2(w_1_2[logDepth-1:0]),
        .outAddr2(u_1_2), 
        .x3(w_1_3[width+logDepth-1:logDepth]), .y3(ybuff3),
        .inAddr3(w_1_3[logDepth-1:0]),
        .outAddr3(u_1_3), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
      z_0_2 <= 0;
      z_0_3 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 4)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 6)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
      z_0_2 <= ybuff2;
      z_0_3 <= ybuff3;
         if (inCount == 4) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 7) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 4)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_2 = {x1, inAddr1};
    assign w_0_1 = {x2, inAddr2};
    assign w_0_3 = {x3, inAddr3};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign y2 = z_1_2;
    assign y3 = z_1_3;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    assign u_0_2 = outAddr_a2;
    assign u_0_3 = outAddr_a3;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[0];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_2), .y0(w_1_0), .y1(w_1_2), .ctrl(wr_ctrl_st_0));
    switch #(logDepth+width) in_sw_0_1(.x0(w_0_1), .x1(w_0_3), .y0(w_1_1), .y1(w_1_3), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[2];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_2), .y0(z_1_0), .y1(z_1_2), .ctrl(rdd_ctrl_st_0));
    switch #(width) out_sw_0_1(.x0(z_0_1), .x1(z_0_3), .y0(z_1_1), .y1(z_1_3), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[2];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_2), .y0(u_1_0), .y1(u_1_2), .ctrl(rda_ctrl_st_0));
    switch #(logDepth) rdaddr_sw_0_1(.x0(u_0_1), .x1(u_0_3), .y0(u_1_1), .y1(u_1_3), .ctrl(rda_ctrl_st_0));
endmodule

module memArray32_57156(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                x2, y2,
                inAddr2,
                outAddr2,
                x3, y3,
                inAddr3,
                outAddr3,
                clk, inFlip, outFlip);

   parameter numBanks = 4;
   parameter logBanks = 2;
   parameter depth = 8;
   parameter logDepth = 3;
   parameter width = 32;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   input [width-1:0]   x2;
   output [width-1:0]  y2;
   input [logDepth-1:0] inAddr2, outAddr2;
   input [width-1:0]   x3;
   output [width-1:0]  y3;
   input [logDepth-1:0] inAddr3, outAddr3;
   shiftRegFIFO #(8, 1) shiftFIFO_57646(.X(next), .Y(next0), .clk(clk));


   memMod_dist #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod_dist #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
   memMod_dist #(depth*2, width, logDepth+1) 
     memMod2(.in(x2), .out(y2), .inAddr({inFlip, inAddr2}),
	   .outAddr({outFlip, outAddr2}), .writeSel(1'b1), .clk(clk));   
   memMod_dist #(depth*2, width, logDepth+1) 
     memMod3(.in(x3), .out(y3), .inAddr({inFlip, inAddr3}),
	   .outAddr({outFlip, outAddr3}), .writeSel(1'b1), .clk(clk));   
endmodule



						module multfix(clk, rst, a, b, q_sc, q_unsc);
						   parameter WIDTH=35, CYCLES=6;

						   input signed [WIDTH-1:0]    a,b;
						   output [WIDTH-1:0]          q_sc;
						   output [WIDTH-1:0]              q_unsc;

						   input                       clk, rst;
						   
						   reg signed [2*WIDTH-1:0]    q[CYCLES-1:0];
						   wire signed [2*WIDTH-1:0]   res;   
						   integer                     i;

						   assign                      res = q[CYCLES-1];   
						   
						   assign                      q_unsc = res[WIDTH-1:0];
						   assign                      q_sc = {res[2*WIDTH-1], res[2*WIDTH-4:WIDTH-2]};
						      
						   always @(posedge clk) begin
						      q[0] <= a * b;
						      for (i = 1; i < CYCLES; i=i+1) begin
						         q[i] <= q[i-1];
						      end
						   end
						                  
						endmodule 
module addfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a+b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
   
endmodule

module subfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a-b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
  
endmodule
