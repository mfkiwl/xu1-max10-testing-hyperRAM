/*
 * esper_internal.c
 *
 *  Created on: Dec 15, 2016
 *      Author: bryerton
 */

#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <esper.h>
#include "io.h"
#include "mod_sys.h"
#include "includes.h"

static tESPERNodeInfo g_node_info;
static tESPERAttr*	g_attrs;
static tESPERModule* g_modules;
static tESPERVar*	g_vars;
static tESPERModuleSystem g_mod_sys_ctx;
static uint32_t g_write_count;
static tStorage* g_storage;

static tStorage _defaultStorage;

static eESPERError CreateVar(tESPERMID mid, const char* key, ESPER_TYPE type, ESPER_OPTIONS options,uint32_t num_elements, VarHandler fnHandler, void* data, volatile void* io);
static eESPERError WriteVar(tESPERMID mid, tESPERVID vid, ESPER_TYPE type, uint32_t offset, uint32_t* num_elements, const void* buff, uint32_t* buff_len);
static const void* ReadVar(tESPERMID mid, tESPERVID vid, ESPER_TYPE type, uint32_t offset, uint32_t* num_elements, uint32_t* buf_len);

static eESPERError CreateAttr(tESPERMID mid, tESPERVID vid, const char* key, ESPER_TYPE type, uint32_t num_elements, void* data);
static uint32_t ReadAttr(tESPERMID mid, tESPERVID vid, tESPERAID aid, ESPER_TYPE type, uint32_t element, void* buff, uint32_t buff_len);
static tESPERModule* GetModuleById(tESPERMID mid);
static tESPERVar* GetVarById(tESPERMID mid, tESPERVID vid);
static tESPERAttr* GetAttrById(tESPERMID mid, tESPERVID vid, tESPERAID aid);
static void IOShadowUpdate(tESPERMID mid, tESPERVID vid, tESPERVar* var);

static const void* DefaultVarHandler(tESPERMID mid, const char* key, eESPERRequest request, uint32_t offset, uint32_t* num_elements, void* ctx);

static const void* defaultStorageLoad(tESPERMID mid, const char* key, void* ctx) {
	return 0;
}

static const void* defaultStorageSave(tESPERMID mid, const char* key, void* ctx) {
	return 0;
}

#ifdef ESPER_DEBUG
const char* get_debug_level_str(uint8_t level) {
	switch(level) {
	case ESPER_DEBUG_LEVEL_CRIT:
		return "CRIT";
	case ESPER_DEBUG_LEVEL_WARN:
		return "WARN";
	case ESPER_DEBUG_LEVEL_INFO:
	default:
		return "INFO";
	}
}

void esper_log(uint8_t level, const char* file, const char* func, int32_t line, const char* msg, ...) {
	char debug_string[320];

	if(level <= ESPER_DEBUG_LEVEL) {
		va_list args;
		va_start(args, msg);
		vsnprintf(debug_string, sizeof(debug_string), msg , args);
		va_end(args);

		printf("[%u] %s: %s [%s:%s:%ld]\n", ESPER_GetUptime(), get_debug_level_str(level), debug_string, file, func, line);
	}
}
#endif

eESPERError ESPER_Init(const char* name, tESPERModule* modules, tESPERVar* vars, tESPERAttr* attrs, uint32_t num_modules, uint32_t num_vars, uint32_t num_attrs, tStorage* storage) {
	// Perform any initialization needed

	g_modules = modules;
	if(!g_modules) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "No Modules Allocated");
		return ESPER_ERR_ALLOC_FAIL;
	}

	g_vars = vars;
	if(!g_vars) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "No Vars Allocated");
		return ESPER_ERR_ALLOC_FAIL;
	}

	g_attrs = attrs;
	if(!g_attrs) {
		if(num_attrs) {
			ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "No Attributes Allocated");
		} else {
			ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "No Attributes Allocated");
		}
		return ESPER_ERR_ALLOC_FAIL;
	}

	g_node_info.max_modules = num_modules;
	g_node_info.max_vars = num_vars;
	g_node_info.max_attrs = num_attrs;
	g_node_info.last_modified = 0;
	g_node_info.write_count = 0;

	ESPER_LOG(ESPER_DEBUG_LEVEL_INFO, "Num Modules: %u", num_modules);
	ESPER_LOG(ESPER_DEBUG_LEVEL_INFO, "Num Variables: %u", num_vars);
	ESPER_LOG(ESPER_DEBUG_LEVEL_INFO, "Num Attributes: %u", num_attrs);

	if(!storage) {
		_defaultStorage.ModuleHandler = 0;
		_defaultStorage.Load = defaultStorageLoad;
		_defaultStorage.Save = defaultStorageSave;
		g_storage = &_defaultStorage;
		ESPER_LOG(ESPER_DEBUG_LEVEL_INFO, "No Storage Module Loaded");
	} else {
		g_storage = storage;
	}

	ESPER_CreateModule(ESPER_MODULE_SYSTEM, ESPER_MODULE_SYSTEM, 0, SystemModuleHandler, SystemModuleInit(name, &g_mod_sys_ctx));

	if(g_storage->ModuleHandler ) {
		ESPER_CreateModule(ESPER_MODULE_STORAGE, ESPER_MODULE_STORAGE, 0, g_storage->ModuleHandler, (void*)g_storage);
	}

	return ESPER_ERR_OK;
}

eESPERError ESPER_CreateModule(const char* key, const char* group, tESPERGID gid, ModuleHandler fnHandler, void* ctx) {
	tESPERModule* module;
	tESPERMID mid;

	if(!key) return ESPER_ERR_NULL_PTR;
	if(!fnHandler) return ESPER_ERR_NULL_PTR;
	if(!(g_node_info.num_modules < g_node_info.max_modules)) return ESPER_ERR_ALLOC_FAIL;

	// TODO: Add check if module with key already exists!
	mid = g_node_info.num_modules++;
	module = &g_modules[mid];
	module->info.num_vars = 0;
	module->info.last_modified = 0;
	module->info.write_count = 0;
	module->vars = 0;
	module->ctx = ctx;

	module->info.group_id  = gid;
	module->Handler = fnHandler;
	strlcpy(module->info.group_key, group, ESPER_KEY_LEN);
	strlcpy(module->info.key, key, ESPER_KEY_LEN);

	ESPER_LOG(ESPER_DEBUG_LEVEL_INFO, "Module %s created", key);

	return module->Handler(mid, gid, ESPER_MOD_STATE_INIT, 0, ctx);
}


tESPERMID ESPER_GetNumModules(void) {
	return g_node_info.num_modules;
}


tESPERVID ESPER_GetNumModuleVars(tESPERMID mid) {
	tESPERModule* module;

	module = GetModuleById(mid);
	if(!module) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Module %u not found", mid);
		return 0;
	}

	return module->info.num_vars;
}

tESPERNodeInfo* ESPER_GetNodeInfo(tESPERNodeInfo* info, eESPERError* err) {
	assert(info != 0);

	if(!info) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "Null Pointer Passed");
		if(err) {
			*err = ESPER_ERR_NULL_PTR;
		}
		return 0;
	}


	if(err) { *err = ESPER_ERR_OK; }

	memcpy(info, &g_node_info, sizeof(tESPERNodeInfo));

	return info;
}

tESPERModuleInfo* ESPER_GetModuleInfo(tESPERMID mid, tESPERModuleInfo* info, eESPERError *err) {
	tESPERModule* module;

	assert(info != 0);

	if(!info) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "Null Pointer Passed");
		if(err) {
			*err = ESPER_ERR_NULL_PTR;
		}
		return 0;
	}

	module = GetModuleById(mid);
	if(!module) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Module %u not found", mid);
		if(err) {
			*err = ESPER_ERR_MID_NOT_FOUND;
		}
		return 0;
	}


	if(err) { *err = ESPER_ERR_OK; }

	memcpy(info, &module->info, sizeof(tESPERModuleInfo));

	return info;
}

tESPERVarInfo* ESPER_GetVarInfo(tESPERMID mid, tESPERVID vid, tESPERVarInfo* info, eESPERError* err) {
	tESPERModule* module;
	tESPERVar* var;

	assert(info != 0);

	if(!info) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "Null Pointer Passed");
		if(err) {
			*err = ESPER_ERR_NULL_PTR;
		}
		return 0;
	}

	module = GetModuleById(mid);
	if(!module) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Module %u not found", mid);
		if(err) {
			*err = ESPER_ERR_MID_NOT_FOUND;
		}
		return 0;
	}

	var = GetVarById(mid, vid);
	if(!var) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Variable %u not found in Module %u", vid, mid);
		if(err) {
			*err = ESPER_ERR_VID_NOT_FOUND;
		}
		return 0;
	}


	if(err) { *err = ESPER_ERR_OK; }

	memcpy(info, &var->info, sizeof(tESPERVarInfo));

	return info;
}

tESPERAttrInfo* ESPER_GetAttrInfo(tESPERMID mid, tESPERVID vid, tESPERAID aid, tESPERAttrInfo* info, eESPERError *err) {
	tESPERModule* module;
	tESPERVar* var;
	tESPERAttr* attr;

	assert(info != 0);

	if(!info) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "Null Pointer Passed");
		if(err) {
			*err = ESPER_ERR_NULL_PTR;
		}
		return 0;
	}

	module = GetModuleById(mid);
	if(!module) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Module %u not found", mid);
		if(err) {
			*err = ESPER_ERR_MID_NOT_FOUND;
		}
		return 0;
	}

	var = GetVarById(mid, vid);
	if(!var) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Variable %u not found in Module %u", vid, mid);
		if(err) {
			*err = ESPER_ERR_VID_NOT_FOUND;
		}
		return 0;
	}

	attr = GetAttrById(mid, vid, aid);
	if(!attr) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Attribute %u not found in Variable %u Module %u", aid, vid, mid);
		if(err) {
			*err = ESPER_ERR_AID_NOT_FOUND;
		}
		return 0;
	}

	if(err) { *err = ESPER_ERR_OK; }

	memcpy(info, &attr->info, sizeof(tESPERAttrInfo));

	return info;
}

volatile ESPER_TIMESTAMP ESPER_GetUptime(void) {
	return OSTimeGet() / OS_TICKS_PER_SEC;
}

eESPERError ESPER_Update(void) {
	tESPERModule* module;
	tESPERMID n;
	uint32_t k;
	ESPER_TIMESTAMP ts;

	// Make all modules share the same update timestamp
	// if a module needs more exacting time diff, it can call ESPER_GetUptime() directly
	ts = ESPER_GetUptime();
	for(n=0; n < ESPER_GetNumModules(); n++) {
		module = GetModuleById(n);
		if(!module) {
			ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "Module %u not found", n);
			return ESPER_ERR_NULL_PTR;
		}
		// This is potentially very very slow, if you had a lot of modules/variables
		for(k=0; k<module->info.num_vars;k++) {
			IOShadowUpdate( n, k, &module->vars[k]);
		}
		module->Handler(n, module->info.group_id, ESPER_MOD_STATE_UPDATE, ts, module->ctx);
	}

	return ESPER_ERR_OK;
}


eESPERError ESPER_Start(void) {
	tESPERModule* module;
	tESPERMID n;

	for(n=0; n < ESPER_GetNumModules(); n++) {
		module = GetModuleById(n);
		if(!module) {
			ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "Module %u not found", n);
			return ESPER_ERR_NULL_PTR;
		}
		ESPER_LOG(ESPER_DEBUG_LEVEL_INFO, "Module %u Starting...", n);
		module->Handler(n, module->info.group_id, ESPER_MOD_STATE_START, 0, module->ctx);
		ESPER_LOG(ESPER_DEBUG_LEVEL_INFO, "Module %u Started.", n);
	}

	return ESPER_ERR_OK;
}

char* ESPER_GetTypeString(ESPER_TYPE type) {
	switch(type) {
	case ESPER_TYPE_NULL:
		return "NULL";
	case ESPER_TYPE_UINT8:
		return "UINT8";
	case ESPER_TYPE_UINT16:
		return "UINT16";
	case ESPER_TYPE_UINT32:
		return "UINT32";
	case ESPER_TYPE_UINT64:
		return "UINT64";
	case ESPER_TYPE_SINT8:
		return "INT8";
	case ESPER_TYPE_SINT16:
		return "INT16";
	case ESPER_TYPE_SINT32:
		return "INT32";
	case ESPER_TYPE_SINT64:
		return "INT64";
	case ESPER_TYPE_FLOAT32:
		return "FLOAT32";
	case ESPER_TYPE_FLOAT64:
		return "FLOAT64";
	case ESPER_TYPE_ASCII:
		return "ASCII";
	case ESPER_TYPE_BOOL:
		return "BOOL";
	default:
		return "UNKNOWN";
	}
}

uint32_t GetESPERTypeSize(ESPER_TYPE type) {
	switch(type) {
	case ESPER_TYPE_NULL:
		return 0;
	case ESPER_TYPE_UINT8:
		return sizeof(uint8_t);
	case ESPER_TYPE_UINT16:
		return sizeof(uint16_t);
	case ESPER_TYPE_UINT32:
		return sizeof(uint32_t);
	case ESPER_TYPE_UINT64:
		return sizeof(uint64_t);
	case ESPER_TYPE_SINT8:
		return sizeof(int8_t);
	case ESPER_TYPE_SINT16:
		return sizeof(int16_t);
	case ESPER_TYPE_SINT32:
		return sizeof(int32_t);
	case ESPER_TYPE_SINT64:
		return sizeof(int64_t);
	case ESPER_TYPE_FLOAT32:
		return sizeof(float);
	case ESPER_TYPE_FLOAT64:
		return sizeof(double);
	case ESPER_TYPE_ASCII:
		return sizeof(char);
	case ESPER_TYPE_BOOL:
		return sizeof(uint8_t);
	default:
		return 0;
	}
}

char* ESPER_GetErrorString(eESPERError err) {
	switch(err) {
	case ESPER_ERR_OK:
		return "None";
	case ESPER_ERR_ALLOC_FAIL:
		return "Memory Alloc Failed";
	case ESPER_ERR_NULL_PTR:
		return "Null Pointer Used";
	case ESPER_ERR_READ_ONLY:
		return "Read Only";
	case ESPER_ERR_WRITE_ONLY:
		return "Write Only";
	case ESPER_ERR_OUT_OF_RANGE:
		return "Out of Range";
	case ESPER_ERR_VALIDATION_FAIL:
		return "Validation Failed";
	case ESPER_ERR_TYPE_MISMATCH:
		return "ESPER_TYPE mismatch";
	case ESPER_ERR_KEY_NOT_FOUND:
		return "Key Not Found";
	case ESPER_ERR_MID_NOT_FOUND:
		return "Module ID Not Found";
	case ESPER_ERR_VID_NOT_FOUND:
		return "Variable ID Not Found";
	case ESPER_ERR_AID_NOT_FOUND:
		return "Attribute ID Not Found";
	case ESPER_ERR_LOCKED:
		return "Locked";
	case ESPER_ERR_INVALID_STATE:
		return "Invalid State";
	case ESPER_ERR_UNKNOWN:
	default:
		return "Unknown Error";
	}
}

tESPERMID ESPER_GetModuleIdByKey(const char* key, eESPERError* err) {
	tESPERMID mid;

	assert(key != 0);

	if(!key) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "Null Pointer Passed");
		if(err) {
			*err = ESPER_ERR_NULL_PTR;
		}
		return ESPER_INVALID_MID;
	}


	for(mid=0; mid < g_node_info.num_modules; mid++) {
		if(strncmp(g_modules[mid].info.key, key, ESPER_KEY_LEN) == 0) {
			if(err) { *err = ESPER_ERR_OK; }
			return mid;
		}
	}

	if(err) {
		*err = ESPER_ERR_KEY_NOT_FOUND;
	}

	ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Module %s not found", key);

	return ESPER_INVALID_MID;
}

tESPERVID ESPER_GetVarIdByKey(tESPERMID mid, const char* key, eESPERError* err) {
	tESPERModule* module;
	tESPERVID vid;

	assert(key != 0);

	if(!key) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "Null Pointer Passed");
		if(err) {
			*err = ESPER_ERR_NULL_PTR;
		}
		return ESPER_INVALID_MID;
	}

	module = GetModuleById(mid);
	if(!module) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Module %u not found", mid);
		if(err) {
			*err = ESPER_ERR_MID_NOT_FOUND;
		}
		return ESPER_INVALID_MID;
	}

	for(vid=0; vid < module->info.num_vars; vid++) {
		if(strncmp(module->vars[vid].info.key, key, ESPER_KEY_LEN) == 0) {
			if(err) { *err = ESPER_ERR_OK; }
			return vid;
		}
	}

	if(err) {
		*err = ESPER_ERR_KEY_NOT_FOUND;
	}

	ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Variable %u not found in Module %u", vid, mid);

	return ESPER_INVALID_VID;
}

tESPERAID ESPER_GetAttrIdByKey(tESPERMID mid, tESPERVID vid, const char* key, eESPERError* err) {
	tESPERVar* var;
	tESPERAID aid;

	assert(key != 0);

	if(!key) {
		ESPER_LOG(ESPER_DEBUG_LEVEL_CRIT, "Null Pointer Passed");
		if(err) {
			*err = ESPER_ERR_NULL_PTR;
		}
		return ESPER_INVALID_MID;
	}

	var = GetVarById(mid, vid);
	if(!var) {
		if(err) {
			*err = ESPER_ERR_VID_NOT_FOUND;
		}
		return ESPER_INVALID_AID;
	}

	for(aid=0; aid < var->info.num_attrs; vid++) {
		if(strncmp(var->attrs[aid].info.key, key, ESPER_KEY_LEN) == 0) {
			if(err) { *err = ESPER_ERR_OK; }
			return aid;
		}
	}

	if(err) {
		*err = ESPER_ERR_KEY_NOT_FOUND;
	}

	ESPER_LOG(ESPER_DEBUG_LEVEL_WARN, "Attribute %u not found in Variable %u Module %u", aid, vid, mid);

	return ESPER_INVALID_AID;
}


eESPERError ESPER_CreateVarNull (tESPERMID mid, const char* key, ESPER_OPTIONS options, uint32_t num_elements, VarHandler fnHandler)	{ return CreateVar(mid, key, ESPER_TYPE_NULL, options, num_elements, fnHandler, 0, 0); }
eESPERError ESPER_CreateVarBool (tESPERMID mid, const char* key, ESPER_OPTIONS options, uint32_t num_elements, uint8_t* data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_BOOL, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarASCII(tESPERMID mid, const char* key, ESPER_OPTIONS options, uint32_t num_elements, char* data, volatile void* io, VarHandler fnHandler) 				{ return CreateVar(mid, key, ESPER_TYPE_ASCII, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarUInt8 (tESPERMID mid, const char* key, ESPER_OPTIONS options, uint32_t num_elements, uint8_t*  data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_UINT8, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarUInt16(tESPERMID mid, const char* key, ESPER_OPTIONS options, uint32_t num_elements, uint16_t* data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_UINT16, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarUInt32(tESPERMID mid, const char* key, ESPER_OPTIONS options, uint32_t num_elements, uint32_t* data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_UINT32, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarUInt64(tESPERMID mid, const char* key, ESPER_OPTIONS options, uint32_t num_elements, uint64_t* data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_UINT64, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarSInt8 (tESPERMID mid, const char* key, ESPER_OPTIONS options, int32_t num_elements, int8_t*  data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_SINT8, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarSInt16(tESPERMID mid, const char* key, ESPER_OPTIONS options, int32_t num_elements, int16_t* data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_SINT16, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarSInt32(tESPERMID mid, const char* key, ESPER_OPTIONS options, int32_t num_elements, int32_t* data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_SINT32, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarSInt64(tESPERMID mid, const char* key, ESPER_OPTIONS options, int32_t num_elements, int64_t* data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_SINT64, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarFloat32(tESPERMID mid, const char* key, ESPER_OPTIONS options, uint32_t num_elements, float* data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_FLOAT32, options, num_elements, fnHandler, data, io); }
eESPERError ESPER_CreateVarFloat64(tESPERMID mid, const char* key, ESPER_OPTIONS options, uint32_t num_elements, double* data, volatile void* io, VarHandler fnHandler) 			{ return CreateVar(mid, key, ESPER_TYPE_FLOAT64, options, num_elements, fnHandler, data, io); }

eESPERError ESPER_CreateVarByFunc(tESPERMID mid, const char* key, ESPER_TYPE type, ESPER_OPTIONS options, uint32_t num_elements, VarHandler fnHandler, void* ctx)
{ return CreateVar(mid, key, type, options, num_elements, fnHandler, ctx, 0); }

eESPERError  ESPER_CreateAttrASCII(tESPERMID mid, tESPERVID vid, const char* key, uint32_t num_elements, char* data) {
	return CreateAttr(mid, vid, key, ESPER_TYPE_ASCII, num_elements, data);
}

eESPERError ESPER_WriteVarNull(tESPERMID mid, tESPERVID vid,uint32_t offset) 					{ uint32_t num_elements = 1; return WriteVar(mid, vid, ESPER_TYPE_NULL, offset, &num_elements, 0, 0); }
eESPERError ESPER_WriteVarBool(tESPERMID mid, tESPERVID vid,uint32_t offset, uint8_t data) 		{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_BOOL, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarASCII(tESPERMID mid, tESPERVID vid,uint32_t offset, char data)		{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_ASCII, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarUInt8(tESPERMID mid, tESPERVID vid,uint32_t offset, uint8_t data)		{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_UINT8, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarUInt16(tESPERMID mid, tESPERVID vid,uint32_t offset, uint16_t data)	{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_UINT16, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarUInt32(tESPERMID mid, tESPERVID vid,uint32_t offset, uint32_t data)	{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_UINT32, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarUInt64(tESPERMID mid, tESPERVID vid,uint32_t offset, uint64_t data)	{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_UINT64, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarSInt8(tESPERMID mid, tESPERVID vid,uint32_t offset, int8_t data)		{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_SINT8, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarSInt16(tESPERMID mid, tESPERVID vid,uint32_t offset, int16_t data)	{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_SINT16, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarSInt32(tESPERMID mid, tESPERVID vid,uint32_t offset, int32_t data)	{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_SINT32, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarSInt64(tESPERMID mid, tESPERVID vid,uint32_t offset, int64_t data)	{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_SINT64, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarFloat32(tESPERMID mid, tESPERVID vid,uint32_t offset, float data)		{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_FLOAT32, offset, &num_elements, &data, &len); }
eESPERError ESPER_WriteVarFloat64(tESPERMID mid, tESPERVID vid,uint32_t offset, double data)	{ uint32_t num_elements = 1; uint32_t len = sizeof(data);	return WriteVar(mid, vid, ESPER_TYPE_FLOAT64, offset, &num_elements, &data, &len); }

eESPERError ESPER_WriteVarNullArray(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements) { return WriteVar(mid, vid, ESPER_TYPE_NULL, offset, num_elements, 0, 0); }
eESPERError ESPER_WriteVarBoolArray(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const uint8_t* buff, uint32_t* buff_len)	{ return WriteVar(mid, vid, ESPER_TYPE_BOOL, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarASCIIArray(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const char* buff, uint32_t* buff_len)		{ return WriteVar(mid, vid, ESPER_TYPE_ASCII, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarUInt8Array(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const uint8_t* buff, uint32_t* buff_len)	{ return WriteVar(mid, vid, ESPER_TYPE_UINT8, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarUInt16Array(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const uint16_t* buff, uint32_t* buff_len){ return WriteVar(mid, vid, ESPER_TYPE_UINT16, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarUInt32Array(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const uint32_t* buff, uint32_t* buff_len){ return WriteVar(mid, vid, ESPER_TYPE_UINT32, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarUInt64Array(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const uint64_t* buff, uint32_t* buff_len){ return WriteVar(mid, vid, ESPER_TYPE_UINT64, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarSInt8Array(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const int8_t* buff, uint32_t* buff_len)	{ return WriteVar(mid, vid, ESPER_TYPE_SINT8, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarSInt16Array(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const int16_t* buff, uint32_t* buff_len)	{ return WriteVar(mid, vid, ESPER_TYPE_SINT16, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarSInt32Array(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const int32_t* buff, uint32_t* buff_len)	{ return WriteVar(mid, vid, ESPER_TYPE_SINT32, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarSInt64Array(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const int64_t* buff, uint32_t* buff_len)	{ return WriteVar(mid, vid, ESPER_TYPE_SINT64, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarFloat32Array(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const float* buff, uint32_t* buff_len)	{ return WriteVar(mid, vid, ESPER_TYPE_FLOAT32, offset, num_elements, buff, buff_len); }
eESPERError ESPER_WriteVarFloat64Array(tESPERMID mid, tESPERVID vid, uint32_t offset, uint32_t* num_elements, const double* buff, uint32_t* buff_len)	{ return WriteVar(mid, vid, ESPER_TYPE_FLOAT64, offset, num_elements, buff, buff_len); }

uint8_t ESPER_ReadVarBool(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen; uint8_t data; data = *(uint8_t*)ReadVar(mid, vid, ESPER_TYPE_BOOL, offset, &num_elements, &bytelen); return data; }
char ESPER_ReadVarASCII(tESPERMID mid, tESPERVID vid, uint32_t offset)		{ uint32_t num_elements = 1; uint32_t bytelen; char data;  data = *(char*)ReadVar(mid, vid, ESPER_TYPE_ASCII, offset, &num_elements, &bytelen); return data; }
uint8_t ESPER_ReadVarUInt8(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen; uint8_t data; data = *(uint8_t*)ReadVar(mid, vid, ESPER_TYPE_UINT8, offset, &num_elements, &bytelen); return data; }
uint16_t ESPER_ReadVarUInt16(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen; uint16_t data; data = *(uint16_t*)ReadVar(mid, vid, ESPER_TYPE_UINT16, offset, &num_elements, &bytelen); return data; }
uint32_t ESPER_ReadVarUInt32(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen; uint32_t data;  data = *(uint32_t*)ReadVar(mid, vid, ESPER_TYPE_UINT32, offset, &num_elements, &bytelen); return data; }
uint64_t ESPER_ReadVarUInt64(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen; uint64_t data; data = *(uint64_t*)ReadVar(mid, vid, ESPER_TYPE_UINT64, offset, &num_elements, &bytelen); return data; }
int8_t ESPER_ReadVarSInt8(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen; int8_t data;  data = *(int8_t*)ReadVar(mid, vid, ESPER_TYPE_SINT8, offset, &num_elements, &bytelen); return data; }
int16_t ESPER_ReadVarSInt16(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen; int16_t data;  data = *(int16_t*)ReadVar(mid, vid, ESPER_TYPE_SINT16, offset, &num_elements, &bytelen); return data; }
int32_t ESPER_ReadVarSInt32(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen; int32_t data; data = *(int32_t*)ReadVar(mid, vid, ESPER_TYPE_SINT32, offset, &num_elements, &bytelen); return data; }
int64_t ESPER_ReadVarSInt64(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen; int64_t data; data = *(int64_t*)ReadVar(mid, vid, ESPER_TYPE_SINT64, offset, &num_elements, &bytelen); return data; }
float ESPER_ReadVarFloat32(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen; float data; data = *(float*)ReadVar(mid, vid, ESPER_TYPE_FLOAT32, offset, &num_elements, &bytelen); return data; }
double ESPER_ReadVarFloat64(tESPERMID mid, tESPERVID vid, uint32_t offset)	{ uint32_t num_elements = 1; uint32_t bytelen;  double data; data = *(double*)ReadVar(mid, vid, ESPER_TYPE_FLOAT64, offset, &num_elements, &bytelen); return data; }

const uint8_t* ESPER_ReadVarBoolArray(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)		{ return ReadVar(mid, vid, ESPER_TYPE_BOOL, offset, num_elements, buf_len); }
const char* ESPER_ReadVarASCIIArray(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)			{ return ReadVar(mid, vid, ESPER_TYPE_ASCII, offset, num_elements, buf_len); }
const uint8_t* ESPER_ReadVarUInt8Array(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)		{ return ReadVar(mid, vid, ESPER_TYPE_UINT8, offset, num_elements, buf_len); }
const uint16_t* ESPER_ReadVarUInt16Array(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)	{ return ReadVar(mid, vid, ESPER_TYPE_UINT16, offset, num_elements, buf_len); }
const uint32_t* ESPER_ReadVarUInt32Array(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)	{ return ReadVar(mid, vid, ESPER_TYPE_UINT32, offset, num_elements, buf_len); }
const uint64_t* ESPER_ReadVarUInt64Array(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)	{ return ReadVar(mid, vid, ESPER_TYPE_UINT64, offset, num_elements, buf_len); }
const int8_t* ESPER_ReadVarSInt8Array(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)		{ return ReadVar(mid, vid, ESPER_TYPE_SINT8, offset, num_elements, buf_len); }
const int16_t* ESPER_ReadVarSInt16Array(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)		{ return ReadVar(mid, vid, ESPER_TYPE_SINT16, offset, num_elements, buf_len); }
const int32_t* ESPER_ReadVarSInt32Array(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)		{ return ReadVar(mid, vid, ESPER_TYPE_SINT32, offset, num_elements, buf_len); }
const int64_t* ESPER_ReadVarSInt64Array(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)		{ return ReadVar(mid, vid, ESPER_TYPE_SINT64, offset, num_elements, buf_len); }
const float* ESPER_ReadVarFloat32Array(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)		{ return ReadVar(mid, vid, ESPER_TYPE_FLOAT32, offset, num_elements, buf_len); }
const double* ESPER_ReadVarFloat64Array(tESPERMID mid, tESPERVID vid,  uint32_t offset, uint32_t* num_elements, uint32_t* buf_len)		{ return ReadVar(mid, vid, ESPER_TYPE_FLOAT64, offset, num_elements, buf_len); }


uint8_t ESPER_ReadAttrBool(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element) 	{ uint8_t buff; ReadAttr(mid, vid, aid, ESPER_TYPE_BOOL, element, &buff, sizeof(buff)); return buff; }
char ESPER_ReadAttrASCII(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element) 	{ char buff;	ReadAttr(mid, vid, aid, ESPER_TYPE_ASCII, element, &buff, sizeof(buff)); return buff; }
uint8_t ESPER_ReadAttrUInt8(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element)	{ uint8_t buff;	ReadAttr(mid, vid, aid, ESPER_TYPE_UINT8, element, &buff, sizeof(buff)); return buff; }
uint16_t ESPER_ReadAttrUInt16(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element){ uint16_t buff;ReadAttr(mid, vid, aid, ESPER_TYPE_UINT16, element, &buff, sizeof(buff)); return buff; }
uint32_t ESPER_ReadAttrUInt32(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element){ uint32_t buff;ReadAttr(mid, vid, aid, ESPER_TYPE_UINT32, element, &buff, sizeof(buff)); return buff; }
uint64_t ESPER_ReadAttrUInt64(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element){ uint64_t buff;ReadAttr(mid, vid, aid, ESPER_TYPE_UINT64, element, &buff, sizeof(buff)); return buff; }
int8_t ESPER_ReadAttrSInt8(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element)	{ int8_t buff;	ReadAttr(mid, vid, aid, ESPER_TYPE_SINT8, element, &buff, sizeof(buff)); return buff; }
int16_t ESPER_ReadAttrSInt16(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element)	{ int16_t buff;	ReadAttr(mid, vid, aid, ESPER_TYPE_SINT16, element, &buff, sizeof(buff)); return buff; }
int32_t ESPER_ReadAttrSInt32(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element)	{ int32_t buff;	ReadAttr(mid, vid, aid, ESPER_TYPE_SINT32, element, &buff, sizeof(buff)); return buff; }
int64_t ESPER_ReadAttrSInt64(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element)	{ int64_t buff;	ReadAttr(mid, vid, aid, ESPER_TYPE_SINT64, element, &buff, sizeof(buff)); return buff; }
float ESPER_ReadAttrFloat32(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element)	{ float buff;	ReadAttr(mid, vid, aid, ESPER_TYPE_FLOAT32, element, &buff, sizeof(buff)); return buff; }
double ESPER_ReadAttrFloat64(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element)	{ double buff;	ReadAttr(mid, vid, aid, ESPER_TYPE_FLOAT64, element, &buff, sizeof(buff)); return buff; }
tESPERKeyPairU8* ESPER_ReadAttrKPU8(tESPERMID mid, tESPERVID vid, tESPERAID aid, uint32_t element, tESPERKeyPairU8* data) { ReadAttr(mid, vid, aid, ESPER_TYPE_KPU8, element, data, sizeof(data)); return data; }


static eESPERError CreateVar(tESPERMID mid, const char* key, ESPER_TYPE type, ESPER_OPTIONS options,uint32_t num_elements, VarHandler fnHandler, void* data, volatile void* io) {
	tESPERModule* module;
	tESPERVar* var;

	if(!key) return ESPER_ERR_NULL_PTR;

	module = GetModuleById(mid);
	if(!module) return ESPER_ERR_MID_NOT_FOUND;
	if((g_node_info.num_vars >= g_node_info.max_vars) || (module->info.num_vars == ESPER_INVALID_VID)) return ESPER_ERR_ALLOC_FAIL;

	// TODO: Add check to make sure we are still in 'init' phase of, can't create variables during normal operation!
	// TODO: Add check to make sure key does not exist in vars

	var = &g_vars[g_node_info.num_vars++];
	module->info.num_vars++;
	var->info.last_modified = 0;
	var->info.write_count = 0;
	var->info.status = 0;
	var->info.num_attrs = 0;
	var->attrs = 0;
	var->info.options = options;
	var->info.type = type;
	var->info.num_elements = num_elements;
	var->data = data;
	var->io = io;

	// If we have IO, load it into data by default
	// Loading from DISK/FLASH/NETWORK will occur later, as the Handler may require other variables to exist, but this is safe to do
	if(var->data && var->io) memcpy(var->data, (void*)var->io, num_elements * GetESPERTypeSize(type));

	if(!fnHandler) {
		var->Handler = DefaultVarHandler;
	} else {
		var->Handler = fnHandler;
	}
	strlcpy(var->info.key, key, ESPER_KEY_LEN);

	// Add first var if necessary to module
	if(module->vars == 0) {
		module->vars = var;
	}

	ESPER_LOG(ESPER_DEBUG_LEVEL_INFO, "\tVariable %s created", key);

	return ESPER_ERR_OK;
}

static eESPERError CreateAttr(tESPERMID mid, tESPERVID vid, const char* key, ESPER_TYPE type, uint32_t num_elements, void* data) {
	tESPERModule* module;
	tESPERVar* var;
	tESPERAttr* attr;

	if(!key) return ESPER_ERR_NULL_PTR;

	module = GetModuleById(mid);
	if(!module) return ESPER_ERR_MID_NOT_FOUND;

	var = GetVarById(mid, vid);
	if(!var) return ESPER_ERR_VID_NOT_FOUND;

	if((g_node_info.num_attrs >= g_node_info.max_attrs) || (var->info.num_attrs == ESPER_INVALID_AID)) return ESPER_ERR_ALLOC_FAIL;

	// TODO: Add check to make sure we are still in 'init' phase of, can't create variables during normal operation!
	// TODO: Add check to make sure key does not exist in vars

	attr = &g_attrs[g_node_info.num_attrs++];
	var->info.num_attrs++;
	attr->data = data;
	attr->info.num_elements = num_elements;
	attr->info.type = type;
	strlcpy(attr->info.key, key, ESPER_KEY_LEN);

	// Add first var if necessary to module
	if(var->attrs == 0) {
		var->attrs = attr;
	}

	ESPER_LOG(ESPER_DEBUG_LEVEL_INFO, "\t\tAttribute %s created", key);

	return ESPER_ERR_OK;
}

eESPERError ESPER_TouchVar(tESPERMID mid, tESPERVID vid) {
	tESPERModule* module;
	tESPERVar* var;
	ESPER_TIMESTAMP current_ts;

	module = GetModuleById(mid);
	if(!module) return ESPER_ERR_MID_NOT_FOUND;

	var = GetVarById(mid, vid);
	if(!var) return ESPER_ERR_VID_NOT_FOUND;

	g_write_count++;
	var->info.write_count = g_write_count;
	module->info.write_count = g_write_count;
	g_node_info.write_count = g_write_count;

	current_ts = ESPER_GetUptime();
	var->info.last_modified = current_ts;
	module->info.last_modified = current_ts;
	g_node_info.last_modified = current_ts;

	return ESPER_ERR_OK;
}

static eESPERError WriteVar(tESPERMID mid, tESPERVID vid, ESPER_TYPE type, uint32_t offset, uint32_t* num_elements, const void* buff, uint32_t* buff_len) {
	tESPERModule* module;
	tESPERVar* var;
	ESPER_TIMESTAMP current_ts;
	eESPERError err_code;
	uint32_t var_size;

	module = GetModuleById(mid);
	if(!module) return ESPER_ERR_MID_NOT_FOUND;

	var = GetVarById(mid, vid);
	if(!var) return ESPER_ERR_VID_NOT_FOUND;


	if(type != var->info.type) return ESPER_ERR_TYPE_MISMATCH;
	if(!num_elements) return ESPER_ERR_NULL_PTR;
	if((var->info.options & ESPER_OPTION_WR) == 0) return ESPER_ERR_READ_ONLY;
	if((var->info.status & ESPER_STATUS_LOCKED)) return ESPER_ERR_LOCKED;

	var_size = GetESPERTypeSize(var->info.type);

	// Reduce num_elements to maximimum size, allows for 'give me all you got' requests
	if(*num_elements > var->info.num_elements) *num_elements = var->info.num_elements;

	if((*num_elements + offset) > var->info.num_elements)  { // Bail if attempt is made to write more than is possible to var
		*num_elements = 0;
		return ESPER_ERR_OUT_OF_RANGE;
	}

	if(buff_len) {
		if(*buff_len < var_size * (*num_elements)) {
			*num_elements = 0;
			return ESPER_ERR_BUFF_OVERFLOW;
		} else {
			*buff_len = var_size * (*num_elements);
		}
	}

	if(var->Handler(mid, var->info.key, ESPER_REQUEST_WRITE_PRE, offset, num_elements, module->ctx) == 0) {
		// Only write data if we can, otherwise just 'touch' the var modified
		if(var->data && (*num_elements > 0) && (buff_len)) {
			memcpy(var->data + (offset*var_size) , buff, var_size * (*num_elements));
			// if a IO location is also mapped, write to that as well
			if(var->io) {
				memcpy((void*)var->io + (offset*var_size) , buff, var_size * (*num_elements));
			}
		}
		if(var->Handler(mid, var->info.key, ESPER_REQUEST_WRITE_POST, offset, num_elements, module->ctx) == 0) {
			err_code = ESPER_ERR_OK;
			g_write_count++;
			var->info.write_count = g_write_count;
			module->info.write_count = g_write_count;
			g_node_info.write_count = g_write_count;

			current_ts = ESPER_GetUptime();
			var->info.last_modified = current_ts;
			module->info.last_modified = current_ts;
			g_node_info.last_modified = current_ts;
		}
	}

	return err_code;
}

static void IOShadowUpdate(tESPERMID mid, tESPERVID vid, tESPERVar* var) {
	// look for a FLAG that says always FUNCTION_READ and varHandler is set

	if(var->io) {
		if(memcmp((void*)var->io, var->data, var->info.num_elements * GetESPERTypeSize(var->info.type)) != 0) {
			memcpy(var->data, (void*)var->io, var->info.num_elements * GetESPERTypeSize(var->info.type));
			ESPER_TouchVar(mid,vid);
		}
	}
}

// TODO: There is an assumption here that void* data can contain num_elements * size_of_type
static const void* ReadVar(tESPERMID mid, tESPERVID vid, ESPER_TYPE type, uint32_t offset, uint32_t* num_elements, uint32_t* buf_len) {
	const void* buffer;
	tESPERModule* module;
	tESPERVar* var;
	uint32_t var_size;

	module = GetModuleById(mid);
	if(!module) return 0;

	var = GetVarById(mid, vid);
	if(!var) return 0;

	if(type != var->info.type) return 0;
	if(!num_elements) return 0;
	if((var->info.options & ESPER_OPTION_RD) == 0) return 0;

	var_size = GetESPERTypeSize(var->info.type);

	if((*num_elements + offset) > var->info.num_elements)  { // Bail if attempt is made to read more than is possible from var
		*num_elements = 0;
		if(buf_len) { *buf_len = 0; }
		return 0;
	}

	if(var->Handler(mid, var->info.key, ESPER_REQUEST_READ_PRE, offset, num_elements, module->ctx) == 0) {
		IOShadowUpdate( mid, vid, var);

		// Special case return for strings
		if(type==ESPER_TYPE_ASCII) {
			*num_elements = strlen(var->data + offset);
		}

		if(type==ESPER_TYPE_FLOAT32) {
			printf("vid %s v: %f\n", var->info.key,  *((float*)(var->data + offset)));
		}

		if(buf_len) {
			*buf_len = *num_elements * var_size;
			buffer = var->data + (offset * var_size);
		} else {
			buffer = 0;
		}

		var->Handler(mid, var->info.key, ESPER_REQUEST_READ_POST, offset, num_elements, module->ctx);
	}

	return buffer;
}

static uint32_t ReadAttr(tESPERMID mid, tESPERVID vid, tESPERAID aid, ESPER_TYPE type, uint32_t element, void* buff, uint32_t buff_len) {
	tESPERAttr* attr;

	attr = GetAttrById(mid, vid, aid);
	if(!attr) {
		return 0;
	}

	if(type != attr->info.type) return 0;


	if(element > attr->info.num_elements)  { // Bail if attempt is made to read more than is possible from var
		return 0;
	}

	if(buff_len < GetESPERTypeSize(attr->info.type)) {
		return 0;
	}

	if(!attr->data) {
		return 0;
	}

	// shorten buffer length to size we intend to use
	buff_len = GetESPERTypeSize(attr->info.type);

	memcpy(buff, attr->data + (GetESPERTypeSize(attr->info.type) * element), buff_len);

	return buff_len;
}

static tESPERModule* GetModuleById(tESPERMID mid) {

	if(!(mid < g_node_info.num_modules)) {
		return 0;
	}

	return &g_modules[mid];
}

static tESPERVar* GetVarById(tESPERMID mid, tESPERVID vid) {
	tESPERModule* module;

	module = GetModuleById(mid);
	if(!module) return 0;

	if(!(vid < module->info.num_vars)) return 0;

	return &module->vars[vid];
}

static tESPERAttr* GetAttrById(tESPERMID mid, tESPERVID vid, tESPERAID aid) {
	tESPERVar* var;

	var = GetVarById(mid, vid);
	if(!var) return 0;

	if(!(aid < var->info.num_attrs)) return 0;

	return &var->attrs[aid];
}

static const void* DefaultVarHandler(tESPERMID mid, const char* key, eESPERRequest request, uint32_t offset, uint32_t* num_elements, void* ctx) {
	// Allow everything
	return 0;
}
