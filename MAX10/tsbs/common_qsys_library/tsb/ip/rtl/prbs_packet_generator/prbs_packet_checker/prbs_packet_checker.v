//
// prbs_packet_checker
//
// This component is designed to verify sequenced packets of variable length
// filled with pseudo random data.  The packets are received on an Avalon ST
// sink interface.  These packets are expected to be generated by the
// prbs_packet_generator on the transmitting end of the data path.
//
// The packets are verified with this format:
//
//  |-------------------------------------------------------|
//  |    PRBS Packet Length     |   Seq LSB   |   Seq MSB   |
//  |-------------------------------------------------------|
//  |             PRBS Data Word 0 (MSB first)              |
//  |-------------------------------------------------------|
//  |                                                       |
//  |                         . . .                         |
//  |                                                       |
//  |-------------------------------------------------------|
//  |             PRBS Data Word N (MSB first)              |
//  |-------------------------------------------------------|
//
//  PRBS Packet Length - is the length of the packet data not including this
//      length field.
//
//  Sequence Number - is the packet sequence number which begins at ZERO when
//      the peripheral is enabled and then incremented for each subsequent
//      packet.
//                  
//  Sequence LSB - is the least significant byte of the sequence number
//
//  Sequence MSB - is the most significant byte of the sequence number
//
//  PRBS Data Word - is the pseudo random data pattern that fills the packet.
//      When the peripheral receives a new packet, it extracts PRBS data word 0
//		and then proceeds to compute the expected PRBS pattern for each
//		subsequent PRBS word.  The PRBS data words are received most
//		significant byte first, and it is perfectly legal to receive partial
//		PRBS data words, depending on the packet length.  Packet lengths less
//		than three will contain no PRBS data at all, and only packets of length
//		7 or greater will contain enough PRBS data for verification by this
//		peripheral.
// 
//  ---------------------------------------------------------------------------
//  Packet Verification
//  ---------------------------------------------------------------------------
//	
//	Depending on the packet length there are three possible conditions that
//	this peripheral will verify.
//	
//	First, the packet length is always verified, since the length field must be
//	received as the first two bytes of the packet, the length is always
//	verified.  Length of ZERO up to 0xFFFF are allowed.  Packets with length of
//	ZERO will in fact be Avalon ST packets of length 2, for the length of the
//	two length bytes.  For all other packet lengths greater than ZERO, the
//	Avalon ST packet length is expected to be the length indicated by the
//	length field, plus two for the length field.
//	
//	Second, if the packet length is 1, then the LSB of the sequence number is
//	verified to align with our internal packet sequence count.  And if the
//	packet length is two or greater, then the entire 16-bit sequence number is
//	verified to align with our internal packet sequence count.
//	
//	Third, if the packet length is 7 or greater, then the PRBS data word 0 is
//	used to initialize the PRBS data verification logic and all subsequent full
//	or partial PRBS data words are verified to the extent possible.
//
//	Error counts for each of the three possible errors detected above are
//	accumulated in error count registers within this peripheral.
//	
//  ---------------------------------------------------------------------------
//  Register Map
//  ---------------------------------------------------------------------------
//  
//  The slave interface for the prbs_packet_checker is broken up into six
//  32-bit registers with the following layout:
//  
//  Register 0 - Status Register
//      Bit 0 - R/W - GO control and status bit.  Set this bit to 1 to enable
//                  the packet checker, and clear it to disable it.  Note that
//                  once cleared, the packet checker will stop at the end of
//					the current packet being received.  Care should be taken
//					not to stop it in mid packet reception.  Instead you should
//					stop the packet generation source first, allow all packets
//					to be received by the checker, and then stop the checker.
//      
//  Register 1 - Length Error Count
//      Bits [31:0] - R/WC - count of length errors detected since last clear.
//                  
//  Register 2 - Sequence Error Count
//      Bits [31:0] - R/WC - count of sequence errors detected since last clear.
//                  
//  Register 3 - Data Error Count
//      Bits [31:0] - R/WC - count of data errors detected since last clear.
//                  
//  Register 4 - Byte Count
//      Bits [31:0] - R/WC - count of payload bytes received since last clear.
//                  
//  Register 5 - Packet Count
//      Bits [31:0] - R/WC - count of packets received since last clear.
//                  
//  Note: writing to any one of the counter register bytes will clear all
//	counters simultaneously.
//
//  R - Readable
//  W - Writeable
//  WC - Clear on Write
//

module prbs_packet_checker
(

	// clock interface
	input 			csi_clock_clk,
	input 			csi_clock_reset,
	
	// slave interface
	input			avs_s0_write,
	input			avs_s0_read,
	input	[2:0]	avs_s0_address,
	input	[3:0]	avs_s0_byteenable,
	input	[31:0]	avs_s0_writedata,
	output	[31:0]	avs_s0_readdata,
	
	// sink interface
	input			asi_snk0_valid,
	output			asi_snk0_ready,
	input	[31:0]	asi_snk0_data,
	input	[1:0]	asi_snk0_empty,
	input			asi_snk0_startofpacket,
	input			asi_snk0_endofpacket
);

reg 			go_bit;
reg				running_bit;
reg		[15:0]	payload_prbs_byte_count;
reg		[15:0]	packet_sequence_number;
reg				packet_sequence_number_error;

reg		[31:0]	length_error_count;
reg		[31:0]	sequence_error_count;
reg		[31:0]	data_error_count;
reg		[31:0]	byte_count;
reg 	[31:0]	packet_count;

reg				clear_length_error_count;
reg				clear_sequence_error_count;
reg				clear_data_error_count;
reg				clear_byte_count;
reg 			clear_packet_count;

reg				length_error;
reg		[31:0]	next_value;
reg				saw_sop;
reg				data_error;
reg				allow_stop;

//
// sink control
//
// essentially, if we're enabled, we're ready.
//
assign asi_snk0_ready = running_bit;

//
// slave read mux
//
assign avs_s0_readdata =	(avs_s0_address == 3'h0) ?	({{31{1'b0}}, go_bit}) :
							(avs_s0_address == 3'h1) ?	(length_error_count) :
							(avs_s0_address == 3'h2) ?	(sequence_error_count) :
							(avs_s0_address == 3'h3) ?	(data_error_count) :
							(avs_s0_address == 3'h4) ?	(byte_count) :
							(avs_s0_address == 3'h5) ?	(packet_count) :
														(0);

//
// slave write demux
//
always @ (posedge csi_clock_clk or posedge csi_clock_reset)
begin
	if(csi_clock_reset)
	begin
		go_bit 						<= 0;
		clear_length_error_count	<= 0;
		clear_sequence_error_count	<= 0;
		clear_data_error_count		<= 0;
		clear_byte_count			<= 0;
		clear_packet_count			<= 0;
	end
	else
	begin
		if(avs_s0_write)
		begin
			if(avs_s0_address == 3'h0)
			begin
				if (avs_s0_byteenable[0] == 1'b1)
					go_bit	<= avs_s0_writedata[0];
			end
			else
			begin
				clear_length_error_count	<= 1;
				clear_sequence_error_count	<= 1;
				clear_data_error_count		<= 1;
				clear_byte_count			<= 1;
				clear_packet_count			<= 1;
			end
		end
		else
		begin
			clear_length_error_count	<= 0;
			clear_sequence_error_count	<= 0;
			clear_data_error_count		<= 0;
			clear_byte_count			<= 0;
			clear_packet_count			<= 0;
		end
	end
end

//
// running_bit state machine
//
// this state machine starts the checker immediately when go_bit is asserted
// but it only allows it to stop at the end of a packet.
//
always @ (posedge csi_clock_clk or posedge csi_clock_reset)
begin
	if(csi_clock_reset)
	begin
		running_bit <= 0;
	end
	else
	begin
		if(go_bit)
		begin
			running_bit <= 1;
		end
		else if(running_bit & !go_bit & asi_snk0_valid & asi_snk0_ready & asi_snk0_endofpacket)
		begin
			running_bit	<= 0;
		end
		else if(running_bit & !go_bit & allow_stop)
		begin
			running_bit	<= 0;
		end
		
		if(running_bit & asi_snk0_valid & asi_snk0_ready & asi_snk0_endofpacket)
		begin
			allow_stop <= 1'b1;
		end
		else if(running_bit & asi_snk0_valid & asi_snk0_ready & !asi_snk0_endofpacket)
		begin
			allow_stop <= 1'b0;
		end
		else if(!running_bit)
		begin
			allow_stop <= 1'b0;
		end

	end
end

//
// packet_sequence_number state machine
//
// start the sequence number at ZERO and increment it for each subsequent packet
//
always @ (posedge csi_clock_clk or posedge csi_clock_reset)
begin
	if(csi_clock_reset)
	begin
		packet_sequence_number			<= 0;
		packet_sequence_number_error	<= 0;
	end
	else
	begin
		if(!running_bit)
		begin
			packet_sequence_number	<= 0;
		end
		else if(asi_snk0_startofpacket && asi_snk0_valid && asi_snk0_ready)
		begin
			packet_sequence_number	<= ({asi_snk0_data[7:0], asi_snk0_data[15:8]}) + 1;
		end
		
		if(asi_snk0_startofpacket && asi_snk0_valid && asi_snk0_ready)
		begin
			packet_sequence_number_error <= (packet_sequence_number != ({asi_snk0_data[7:0], asi_snk0_data[15:8]})) ? (1'b1) : (1'b0);
		end
		else
		begin
			packet_sequence_number_error <= (1'b0);
		end
	end
end

//
// byte_count state machine
//
// this keeps a count of the bytes received in the current packet
//
always @ (posedge csi_clock_clk or posedge csi_clock_reset)
begin
	if(csi_clock_reset)
	begin
		byte_count	<= 0;
	end
	else if(clear_byte_count)
	begin
		byte_count	<= 0;
	end
	else if(asi_snk0_valid && asi_snk0_ready)
	begin
		if(asi_snk0_startofpacket)
		begin
			byte_count	<= byte_count + (2 - asi_snk0_empty);
		end
		else if(asi_snk0_endofpacket)
		begin
			byte_count	<= byte_count + (4 - asi_snk0_empty);
		end
		else
		begin
			byte_count	<= byte_count + (4);
		end
	end
end

//
// length error detection state machine
//
always @ (posedge csi_clock_clk or posedge csi_clock_reset)
begin
	if(csi_clock_reset)
	begin
		payload_prbs_byte_count	<= 0;
		length_error	<= 1'b0;
	end
	else if(asi_snk0_valid && asi_snk0_ready)
	begin
		if(asi_snk0_startofpacket && !asi_snk0_endofpacket)
		begin
			payload_prbs_byte_count	<= (asi_snk0_data[31:16]) - (2 - asi_snk0_empty);
			length_error	<= 1'b0;
		end
		else if(!asi_snk0_startofpacket && asi_snk0_endofpacket)
		begin
			length_error	<= ((payload_prbs_byte_count - (4 - asi_snk0_empty)) != 0) ? (1'b1) : (1'b0);
		end
		else if(asi_snk0_startofpacket && asi_snk0_endofpacket)
		begin
			length_error	<=	((asi_snk0_data[31:16]) > 2) ? (1'b1) : 
								(((asi_snk0_data[31:16]) == 2) && (asi_snk0_empty != 0)) ? (1'b1) : 
								(((asi_snk0_data[31:16]) == 1) && (asi_snk0_empty != 1)) ? (1'b1) : 
								(((asi_snk0_data[31:16]) == 0) && (asi_snk0_empty != 2)) ? (1'b1) : 
								(1'b0);
		end
		else
		begin
			payload_prbs_byte_count	<= payload_prbs_byte_count - 4;
			length_error	<= 1'b0;
		end
	end
	else
	begin
		length_error	<= 1'b0;
	end
end

//
// data error detection state machine
//
always @ (posedge csi_clock_clk or posedge csi_clock_reset)
begin
	if(csi_clock_reset)
	begin
		data_error	<= 1'b0;
		saw_sop		<= 1'b0;
		next_value	<= 0;
	end
	else if(asi_snk0_valid && asi_snk0_ready)
	begin
		if(asi_snk0_startofpacket && !asi_snk0_endofpacket)
		begin
			saw_sop		<= 1'b1;
			data_error	<= 1'b0;
		end
		else if(!asi_snk0_startofpacket && asi_snk0_endofpacket)
		begin
			saw_sop		<= 1'b0;

			if(saw_sop)
			begin
				data_error	<= 1'b0;
			end
			else
			begin
				if(asi_snk0_empty == 2'h0)
					data_error	<= (next_value != asi_snk0_data) ? (1'b1) : (1'b0);
				else if(asi_snk0_empty == 2'h1)
					data_error	<= (next_value[31:8] != asi_snk0_data[31:8]) ? (1'b1) : (1'b0);
				else if(asi_snk0_empty == 2'h2)
					data_error	<= (next_value[31:16] != asi_snk0_data[31:16]) ? (1'b1) : (1'b0);
				else if(asi_snk0_empty == 2'h3)
					data_error	<= (next_value[31:24] != asi_snk0_data[31:24]) ? (1'b1) : (1'b0);
			end
		end
		else if(asi_snk0_startofpacket && asi_snk0_endofpacket)
		begin
			saw_sop		<= 1'b0;
			data_error	<= 1'b0;
		end
		else
		begin
			saw_sop		<= 1'b0;
			
			if(saw_sop)
			begin
				next_value <= ((((asi_snk0_data << 5) & 32'hFFFFFFE0) | ((asi_snk0_data >> 27) & 32'h0000001F)) + 32'h33557799);
				data_error	<= 1'b0;
			end
			else
			begin
				next_value <= ((((asi_snk0_data << 5) & 32'hFFFFFFE0) | ((asi_snk0_data >> 27) & 32'h0000001F)) + 32'h33557799);
				data_error	<= (next_value != asi_snk0_data) ? (1'b1) : (1'b0);
			end
		end
	end
	else
	begin
		data_error	<= 1'b0;
	end
end

//
// simple counter state machine
//
// this state machine simply manages the counters
//
always @ (posedge csi_clock_clk or posedge csi_clock_reset)
begin
	if(csi_clock_reset)
	begin
		packet_count			<= 0;
		sequence_error_count	<= 0;
		length_error_count		<= 0;
		data_error_count		<= 0;
	end
	else
	begin
		// packet_count
		if(clear_packet_count)
		begin
			packet_count <= 0;
		end
		else if(go_bit & asi_snk0_valid & asi_snk0_ready & asi_snk0_endofpacket)
		begin
			packet_count <= packet_count + 1;
		end

		// sequence_error_count
		if(clear_sequence_error_count)
		begin
			sequence_error_count <= 0;
		end
		else if(packet_sequence_number_error)
		begin
			sequence_error_count <= sequence_error_count + 1;
		end

		// length_error_count
		if(clear_length_error_count)
		begin
			length_error_count <= 0;
		end
		else if(length_error)
		begin
			length_error_count <= length_error_count + 1;
		end

		// data_error_count
		if(clear_data_error_count)
		begin
			data_error_count <= 0;
		end
		else if(data_error)
		begin
			data_error_count <= data_error_count + 1;
		end
	end
end

endmodule
