///////////////////////////////////////////////////////////////////////////////
// vim:set shiftwidth=3 softtabstop=3 expandtab:
// $Id: rgmii_io.v 1891 2007-07-02 20:41:16Z grg $
//
// Module: rgmii_io.v
// Project: NetFPGA
// Description: Instantiate the IO flops for the rgmii interface for one TEMAC.
//
// See the Xilinx TriMode Ethernet MAC USer Guide (UG138) for details
//
///////////////////////////////////////////////////////////////////////////////


`default_nettype none
module rgmii_io
#(
parameter SYNC_REVERSE_SIGNALS = 1
)
(
     //-----------------------------------------------------------------------
     //-- Pad side signals
     //-----------------------------------------------------------------------

     output [3:0] rgmii_txd,
     output rgmii_tx_ctl,
     output rgmii_txc,

     input  [3:0] rgmii_rxd,
     input  rgmii_rx_ctl,

     //-----------------------------------------------------------------------
     //-- Core side signals
     //-----------------------------------------------------------------------

     input [7:0] gmii_txd_int,      // Internal gmii_txd signal.
     input       gmii_tx_en_int,
     input       gmii_tx_er_int,
     output      gmii_col_int,
     output      gmii_crs_int,

     output reg [7:0] gmii_rxd_reg,   // RGMII double data rate data valid.
     output reg       gmii_rx_dv_reg, // gmii_rx_dv_ibuf registered in IOBs.
     output reg       gmii_rx_er_reg, // gmii_rx_er_ibuf registered in IOBs.


     //-----------------------------------------------------------------------
     //-- Clocks and misc
     //-----------------------------------------------------------------------

     output reg       eth_link_status,
     output reg [1:0] eth_clock_speed,
     output reg       eth_duplex_status,

                                 // FOllowing are generated by DCMs
     input tx_rgmii_clk_int,     // Internal RGMII transmitter clock.
     //input tx_rgmii_clk90_int,   // Internal RGMII transmitter clock w/ 90 deg phase
     input rx_rgmii_clk_int,     // Internal RGMII receiver clock

	 input reverse_clock,
	 input reverse_data,
	 input reverse_control,
	 input reverse_rx_data,
	 input reverse_rx_control,
	 
     input reset
     );


   reg [7:0] gmii_txd_rising;     // gmii_txd signal registered on the rising edge of tx_rgmii_clk_int.
   reg 	     gmii_tx_en_rising;   // gmii_tx_en signal registered on the rising edge of tx_rgmii_clk_int.
   reg 	     rgmii_tx_ctl_rising; // RGMII control signal registered on the rising edge of tx_rgmii_clk_int.
   reg [3:0] gmii_txd_falling;    // gmii_txd signal registered on the falling edge of tx_rgmii_clk_int

   reg 	     rgmii_tx_ctl_falling;// RGMII control signal registered on the falling edge of tx_rgmii_clk_int.

   reg [7:0]  rgmii_rxd_ddr;
   reg 	      rgmii_rx_dv_ddr;    // Inverted version of the rx_rgmii_clk_int signal.
   reg 	      rgmii_rx_ctl_ddr;   // RGMII double data rate data.
   reg [7:0]  rgmii_rxd_reg;      // RGMII double data rate data valid.
   reg 	      rgmii_rx_dv_reg;    // RGMII double data rate control signal.
   reg 	      rgmii_rx_ctl_reg;   // RGMII data. gmii_tx_en signal.

   
   logic reverse_clock_synced;
   logic reverse_data_synced;
   logic reverse_control_synced;
   
  
   //----------------------------------------------------------------
   // Transmit interface
   //----------------------------------------------------------------

   //----------------------------------------------------------------
   // Tx clock.
   // Instantiate a DDR output register.  This is a good way to drive
   // RGMII_TXC since the clock-to-PAD delay will be the same as that
   // for data driven from IOB Ouput flip-flops eg rgmii_rxd[3:0].
   // This is set to produce a 90 degree phase shifted clock w.r.t.
   // gtx_clk_bufg so that the clock edges are centralised within the
   // rgmii_txd[3:0] valid window.
   //----------------------------------------------------------------

   generate	
			if (SYNC_REVERSE_SIGNALS)
			begin
					   doublesync_no_reset
					   sync_reverse_clock(.indata (reverse_clock),
					   .outdata(reverse_clock_synced),
					   .clk    (tx_rgmii_clk_int)
					   );
			end else
			begin
			      assign reverse_clock_synced = reverse_clock;				
			end
	endgenerate
					   
	
	simple_altddio gmii_tx_clk_ddr_iob (	
		.datain_h(reverse_clock_synced ? 0 : 1),
		.datain_l(reverse_clock_synced ? 1 : 0),
		.clk(tx_rgmii_clk_int),
		.dataout(rgmii_txc)
	);
   /*
   
   FDDRRSE gmii_tx_clk_ddr_iob
     (
      .Q (rgmii_txc_obuf),
      .D0(1'b1),
      .D1(1'b0),
      .C0(tx_rgmii_clk90_int),
      .C1(not_tx_rgmii_clk90_int),
      .CE(1'b1),
      .R (1'b0),
      .S (1'b0)
      );

   assign      not_tx_rgmii_clk90_int = ~(tx_rgmii_clk90_int);
  */
   //  drive clock through Output Buffers and onto PADS.
   //OBUF drive_rgmii_txc     (.I(rgmii_txc_obuf),     .O(rgmii_txc));

   
   //-------------------------------------------------------------------
   // RGMII Transmitter Logic :
   // drive TX signals through IOBs onto RGMII interface
   //-------------------------------------------------------------------

   // Encode rgmii ctl signal
	logic rgmii_tx_ctl_int;
	logic not_tx_rgmii_clk_int;
   assign      rgmii_tx_ctl_int = gmii_tx_en_int ^ gmii_tx_er_int;

   // Register all output signals on rising edge of gtx_clk_bufg
   always @ (posedge tx_rgmii_clk_int or posedge reset)
     begin
	if (reset)
          begin
             gmii_txd_rising     <= 8'b0;
             gmii_tx_en_rising   <= 1'b0;
             rgmii_tx_ctl_rising <= 1'b0;
          end
	else
          begin
             gmii_txd_rising     <= gmii_txd_int;
             gmii_tx_en_rising   <= gmii_tx_en_int;
             rgmii_tx_ctl_rising <= rgmii_tx_ctl_int;
          end
     end

   assign not_tx_rgmii_clk_int = ~(tx_rgmii_clk_int);

   // Register falling edge RGMII output signals on rising edge of not_gtx_clk_bufg
   always @ (posedge not_tx_rgmii_clk_int or posedge reset)
     begin
	if (reset)
          begin
             gmii_txd_falling     <= 4'b0;
             rgmii_tx_ctl_falling <= 1'b0;
          end
	else
          begin
	     gmii_txd_falling     <= gmii_txd_rising[7:4];
	     rgmii_tx_ctl_falling <= rgmii_tx_ctl_rising;
          end
     end


   // Instatiate Double Data Rate Output flip-flops to convert output signals into RGMII format.
   
      generate	
			if (SYNC_REVERSE_SIGNALS)
			begin
			   doublesync_no_reset
			   sync_reverse_data(.indata (reverse_data),
			   .outdata(reverse_data_synced),
			   .clk    (tx_rgmii_clk_int)
			   );
		   end else
		   begin
		          assign reverse_data_synced = reverse_data;
		   end
   endgenerate
   
   simple_altddio rgmii_txd_out3 (	
		.datain_h(reverse_data_synced ? gmii_txd_falling[3] : gmii_txd_rising[3]),
		.datain_l(reverse_data_synced ? gmii_txd_rising[3]  : gmii_txd_falling[3]),
		.clk(tx_rgmii_clk_int),
		.dataout(rgmii_txd[3])
	);
	simple_altddio rgmii_txd_out2 (	
		.datain_h(reverse_data_synced ? gmii_txd_falling[2] : gmii_txd_rising[2]),
		.datain_l(reverse_data_synced ? gmii_txd_rising[2] :  gmii_txd_falling[2]),
		.clk(tx_rgmii_clk_int),
		.dataout(rgmii_txd[2])
	);
	   simple_altddio rgmii_txd_out1 (	
		.datain_h(reverse_data_synced ? gmii_txd_falling[1] : gmii_txd_rising[1]),
		.datain_l(reverse_data_synced ? gmii_txd_rising[1]  : gmii_txd_falling[1]),
		.clk(tx_rgmii_clk_int),
		.dataout(rgmii_txd[1])
	);
	simple_altddio rgmii_txd_out0 (	
		.datain_h(reverse_data_synced ? gmii_txd_falling[0] : gmii_txd_rising[0]),
		.datain_l(reverse_data_synced ? gmii_txd_rising[0]  : gmii_txd_falling[0]),
		.clk(tx_rgmii_clk_int),
		.dataout(rgmii_txd[0])
	);
	
	
	    generate	
			if (SYNC_REVERSE_SIGNALS)
			begin
				   doublesync_no_reset
				   sync_reverse_control(.indata (reverse_control),
				   .outdata(reverse_control_synced),
				   .clk    (tx_rgmii_clk_int)
				   );
			end else
			begin
			       assign reverse_control_synced = reverse_control;
			
			end
	    endgenerate
   
	simple_altddio rgmii_tx_ctl_out (	
		.datain_h(reverse_control_synced ? rgmii_tx_ctl_falling : gmii_tx_en_rising),
		.datain_l(reverse_control_synced ? gmii_tx_en_rising    : rgmii_tx_ctl_falling),
		.clk(tx_rgmii_clk_int),
		.dataout(rgmii_tx_ctl)
	);
	
	/*
   FDDRRSE rgmii_txd_out3
     (
      .Q (rgmii_txd_obuf[3]),
      .D0(gmii_txd_rising[3]),
      .D1(gmii_txd_falling[3]),
      .C0(tx_rgmii_clk_int),
      .C1(not_tx_rgmii_clk_int),
      .CE(1'b1),
      .R (reset),
      .S (1'b0)
      );

   FDDRRSE rgmii_txd_out2
     (
      .Q (rgmii_txd_obuf[2]),
      .D0(gmii_txd_rising[2]),
      .D1(gmii_txd_falling[2]),
      .C0(tx_rgmii_clk_int),
      .C1(not_tx_rgmii_clk_int),
      .CE(1'b1),
      .R (reset),
      .S (1'b0)
      );

   FDDRRSE rgmii_txd_out1
     (
      .Q (rgmii_txd_obuf[1]),
      .D0(gmii_txd_rising[1]),
      .D1(gmii_txd_falling[1]),
      .C0(tx_rgmii_clk_int),
      .C1(not_tx_rgmii_clk_int),
      .CE(1'b1),
      .R (reset),
      .S (1'b0)
      );

   FDDRRSE rgmii_txd_out0
     (
      .Q (rgmii_txd_obuf[0]),
      .D0(gmii_txd_rising[0]),
      .D1(gmii_txd_falling[0]),
      .C0(tx_rgmii_clk_int),
      .C1(not_tx_rgmii_clk_int),
      .CE(1'b1),
      .R (reset),
      .S (1'b0)
      );

   FDDRRSE rgmii_tx_ctl_out
     (
      .Q (rgmii_tx_ctl_obuf),
      .D0(gmii_tx_en_rising),
      .D1(rgmii_tx_ctl_falling),
      .C0(tx_rgmii_clk_int),
      .C1(not_tx_rgmii_clk_int),
      .CE(1'b1),
      .R (reset),
      .S (1'b0)
      );

   //  Drive RGMII Tx signals through Output Buffers and onto PADS.
   OBUF drive_rgmii_tx_ctl  (.I(rgmii_tx_ctl_obuf),     .O(rgmii_tx_ctl));

   OBUF drive_rgmii_txd3    (.I(rgmii_txd_obuf[3]),     .O(rgmii_txd[3]));
   OBUF drive_rgmii_txd2    (.I(rgmii_txd_obuf[2]),     .O(rgmii_txd[2]));
   OBUF drive_rgmii_txd1    (.I(rgmii_txd_obuf[1]),     .O(rgmii_txd[1]));
   OBUF drive_rgmii_txd0    (.I(rgmii_txd_obuf[0]),     .O(rgmii_txd[0]));

  */


   //----------------------------------------------------------------
   // Receive interface
   //----------------------------------------------------------------


   //-------------------------------------------------------------------
   // RGMII Receiver Logic : receive RGMII_RX signals through IOBs from
   // RGMII interface and convert to gmii_rx signals.
   //-------------------------------------------------------------------

   //  Drive input RGMII Rx signals from PADS through Input Buffers.
/*
   IBUF drive_rgmii_rx_ctl (.I(rgmii_rx_ctl), .O(rgmii_rx_ctl_ibuf));

   IBUF drive_rgmii_rxd3   (.I(rgmii_rxd[3]), .O(rgmii_rxd_ibuf[3]));
   IBUF drive_rgmii_rxd2   (.I(rgmii_rxd[2]), .O(rgmii_rxd_ibuf[2]));
   IBUF drive_rgmii_rxd1   (.I(rgmii_rxd[1]), .O(rgmii_rxd_ibuf[1]));
   IBUF drive_rgmii_rxd0   (.I(rgmii_rxd[0]), .O(rgmii_rxd_ibuf[0]));
*/
///////////////////
//
//   Copying this section of codes from opencores:
//
//  inData  <= RX_CTL & RD;
//  oRxDV   <= inDataL(4);
//  oRxErr  <= inDataH(4) XOR inDataL(4);
//  oRxData <= inDataH(3 DOWNTO 0) & inDataL(3 DOWNTO 0);
//  eth_ddr_in_1 : ENTITY work.eth_ddr_in
//    PORT MAP (
//      datain    => inData,
//      inclock   => ethIOClk,            -- shift 180~360 degree compared to RXC
//      dataout_h => inDataH,
//      dataout_l => inDataL);


    logic [4:0] rgmii_indatah, rgmii_indatal;

   	altddio_input_5bit 
	altddio_input_5bit_rgmii_rx (
		.datain    ({rgmii_rx_ctl,rgmii_rxd[3:0]}),    //    pad_in.export
		.ck        (rx_rgmii_clk_int),        //        ck.export
		.dataout_h (rgmii_indatal[4:0]), // l-h inversion is intentional, due to altgpio arria 10 behaviour with legacy ports
		.dataout_l (rgmii_indatah[4:0])  // l-h inversion is intentional, due to altgpio arria 10 behaviour with legacy ports
	);
   
   logic reverse_rx_data_synced;
   logic reverse_rx_control_synced;
   
generate	
			if (SYNC_REVERSE_SIGNALS)
			begin
					   doublesync_no_reset
					   sync_reverse_rx_data(.indata (reverse_rx_data),
					   .outdata(reverse_rx_data_synced),
					   .clk    (rx_rgmii_clk_int)
					   );
					   
					   doublesync_no_reset
					   sync_reverse_rx_control(.indata (reverse_rx_control),
					   .outdata(reverse_rx_control_synced),
					   .clk    (rx_rgmii_clk_int)
					   );
		   end else
		   begin
				  assign reverse_rx_control_synced = reverse_rx_control;
				  assign reverse_rx_data_synced = reverse_rx_data;
		   end
endgenerate
 /*
 	altddio_input_1bit altddio_rx_ctl (
		.ck     (rx_rgmii_clk_int),     //     ck.export
		.dout   ({rgmii_indatah[4],rgmii_indatal[4]}),   //   dout.export
		.pad_in (rgmii_rx_ctl)  // pad_in.export
	);

   
 	altddio_input_3bit altddio_rx_ctl (
		.ck     (rx_rgmii_clk_int),     //     ck.export
		.dout   ( {rgmii_indatah[3:0],rgmii_indatal[3:0]}),   //   dout.export
		.pad_in (rgmii_rxd[3:0])  // pad_in.export
	);
*/
   always @(posedge rx_rgmii_clk_int)
   begin
	        gmii_rxd_reg[7:0] <= reverse_rx_data_synced ?  {rgmii_indatal[3:0],rgmii_indatah[3:0]} : {rgmii_indatah[3:0],rgmii_indatal[3:0]};
	        gmii_rx_dv_reg    <= reverse_rx_control_synced ? rgmii_indatah[4] : rgmii_indatal[4];
	        gmii_rx_er_reg    <= rgmii_indatah[4] ^ rgmii_indatal[4];	
   end
   
   
/*
   // Infer Double Data Rate Input flip-flops.
	logic not_rx_rgmii_clk_int;
	
   always @ (posedge rx_rgmii_clk_int or posedge reset)
   begin
      if (reset)
         begin
            rgmii_rxd_ddr[3:0]   <= 4'b0;
            rgmii_rx_dv_ddr      <= 1'b0;
         end
      else
         begin
            rgmii_rxd_ddr[3:0]   <= rgmii_rxd;
            rgmii_rx_dv_ddr      <= rgmii_rx_ctl;
         end
   end

   assign not_rx_rgmii_clk_int = ~(rx_rgmii_clk_int);

   always @ (posedge not_rx_rgmii_clk_int or posedge reset)
   begin
      if (reset)
         begin
            rgmii_rxd_ddr[7:4]    <= 4'b0;
            rgmii_rx_ctl_ddr      <= 1'b0;
         end
      else
         begin
            rgmii_rxd_ddr[7:4]    <= rgmii_rxd;
            rgmii_rx_ctl_ddr      <= rgmii_rx_ctl;
         end
   end
   // Register DDR signals internally to FPGA fabric
   always @ (posedge rx_rgmii_clk_int or posedge reset)
   begin
      if (reset)
         begin
            rgmii_rxd_reg[3:0] <= 4'b0;
            rgmii_rx_dv_reg    <= 1'b0;
         end
      else
         begin
            rgmii_rxd_reg[3:0] <= rgmii_rxd_ddr[3:0];
            rgmii_rx_dv_reg    <= rgmii_rx_dv_ddr;
         end
   end // always @ (posedge rx_rgmii_clk_int or posedge reset)

   always @ (posedge not_rx_rgmii_clk_int or posedge reset)
   begin
      if (reset)
         begin
            rgmii_rxd_reg[7:4] <= 4'b0;
            rgmii_rx_ctl_reg   <= 1'b0;
         end
      else
         begin
            rgmii_rxd_reg[7:4] <= rgmii_rxd_ddr[7:4];
            rgmii_rx_ctl_reg   <= rgmii_rx_ctl_ddr;
         end
   end


   // Register all input signals on rising edge of gmii_rx_clk_bufg to syncronise.
   always @ (posedge rx_rgmii_clk_int or posedge reset)
   begin
       if (reset)
          begin
             gmii_rxd_reg[7:0] <= 8'b0;
             gmii_rx_dv_reg    <= 1'b0;
             gmii_rx_er_reg    <= 1'b0;
          end
       else
          begin
             gmii_rxd_reg[7:0] <= rgmii_rxd_reg[7:0];
             gmii_rx_dv_reg    <= rgmii_rx_dv_reg;
             gmii_rx_er_reg    <= rgmii_rx_ctl_reg ^ rgmii_rx_dv_reg;
          end
   end
*/

   //--------------------------------------------------------------------
   // RGMII Inband Status Registers
   // extract the inband status from received rgmii data
   //--------------------------------------------------------------------

	logic inband_ce;
   // Enable inband status registers during Interframe Gap
   assign inband_ce = !(gmii_rx_dv_reg || gmii_rx_er_reg);

   always @ (posedge rx_rgmii_clk_int or posedge reset)
   begin
      if (reset)
          begin
            eth_link_status         <= 1'b0;
            eth_clock_speed[1:0]    <= 2'b0;
            eth_duplex_status       <= 1'b0;
      end
      else
        if (inband_ce)
            begin
            eth_link_status      <= gmii_rxd_reg[0];
            eth_clock_speed[1:0] <= gmii_rxd_reg[2:1];
            eth_duplex_status    <= gmii_rxd_reg[3];
        end
   end

   assign gmii_col_int = (gmii_tx_en_int | gmii_tx_er_int) & (gmii_rx_dv_reg | gmii_rx_er_reg);
   assign gmii_crs_int = (gmii_tx_en_int | gmii_tx_er_int) | (gmii_rx_dv_reg | gmii_rx_er_reg);

endmodule // rgmii_io
`default_nettype wire