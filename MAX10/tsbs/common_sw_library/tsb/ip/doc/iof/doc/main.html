<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IOF Library: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>IOF Library Documentation</h1>
<p>
<h3 align="center">0.8.0a </h3><h2><a class="anchor" name="overview">
Overview</a></h2>
This is the top level page for the documentation of the <em>iof</em> library. The <em>iof</em> library greatly facilitates formatted output and input with C++ STL streams by using the same strategy as C's printf/scanf family of functions.<p>
Keywords:<ul>
<li>formatted output in C++, formatted input in C++</li><li>formatted I/O in C++, formatted input/output in C++</li><li>like printf, like sprintf, like fprintf, for C++ streams</li><li>like scanf, like sscanf, fscanf, for C++ streams</li><li>printf equivalent in C++</li><li>sprintf, vprintf, fprintf equivalents in C++</li><li>scanf, sscanf, vscanf, fscanf equivalents in C++</li></ul>
<p>
The pages available are:<p>
<ul>
<li><b>This page</b><ul>
<li><a class="el" href="main.html#sec_hello_world">Hello World</a></li><li><a class="el" href="main.html#sec_system_reqs">System Requirements</a></li><li><a class="el" href="main.html#sec_license">License</a></li><li><a class="el" href="main.html#sec_download">Download</a></li><li><a class="el" href="main.html#sec_install">Installation</a></li><li><a class="el" href="main.html#sec_linking">Linking</a></li><li><a class="el" href="main.html#sec_performance">Performance</a></li><li><a class="el" href="main.html#sec_changelog">Change Log</a></li><li><a class="el" href="main.html#sec_contact">Feedback/bug reports/etc</a></li></ul>
</li></ul>
<p>
<ul>
<li><a class="el" href="page_generalities.html">More about the IOF library</a><ul>
<li><a class="el" href="page_generalities.html#sec_why_fmtd_io">Why formatted I/O, why IOF</a></li><li><a class="el" href="page_generalities.html#sec_capabilities">Capabilities</a></li><li><a class="el" href="page_generalities.html#sec_limitations">Limitations</a></li></ul>
</li></ul>
<p>
<ul>
<li><a class="el" href="page_gen_usage.html">General usage</a><ul>
<li><a class="el" href="page_gen_usage.html#sec_header">Which header file to include</a></li><li><a class="el" href="page_gen_usage.html#sec_output">Send formatted data to a stream (formatted output)</a></li><li><a class="el" href="page_gen_usage.html#sec_operator">Make your class usable by iof: with operator&lt;&lt;(stream&amp;)</a></li><li><a class="el" href="page_gen_usage.html#sec_fsc_oo">The format specification characters are "object-oriented"</a></li><li><a class="el" href="page_gen_usage.html#sec_fsc_as_fill">Fill characters</a></li><li><a class="el" href="page_gen_usage.html#sec_fsc_order">Format specification can happen in any order</a></li><li><a class="el" href="page_gen_usage.html#sec_input">Read formatted data from a stream (formatted input)</a></li><li><a class="el" href="page_gen_usage.html#sec_unformatted">Remaining objects are output "unformatted"</a></li><li><a class="el" href="page_gen_usage.html#sec_restore">Format state of stream automatically restored</a></li><li><a class="el" href="page_gen_usage.html#sec_unused_markers">Notifies you if unused format markers</a></li><li><a class="el" href="page_gen_usage.html#sec_save">Save a format state of a stream for future use</a></li><li><a class="el" href="page_gen_usage.html#sec_except_safety">Automatically restore the format state when unformatted I/O</a></li><li><a class="el" href="page_gen_usage.html#sec_dyn_fmt">Format specifications "refactored"</a></li><li><a class="el" href="page_gen_usage.html#sec_consume_marker">Objects that don't consume format markers</a></li><li><a class="el" href="page_gen_usage.html#sec_input_text">Verify that text in format string is matched verbatim by input stream</a></li><li><a class="el" href="page_gen_usage.html#sec_input_err">Exception provides info about cause of error on input</a></li><li><a class="el" href="page_gen_usage.html#sec_validity">Get validity state of input stream</a></li><li><a class="el" href="page_gen_usage.html#sec_skip_marker">Skip some patterns on input</a></li><li><a class="el" href="page_gen_usage.html#sec_skippast">Define skip patterns at runtime</a></li><li><a class="el" href="page_gen_usage.html#sec_fn_syntax">If you prefer function call syntax rather than operator syntax</a></li><li><a class="el" href="page_gen_usage.html#sec_persist">Persistent Formatting: factoring out common format specs</a></li><li><a class="el" href="page_gen_usage.html#sec_flush">Flush the stream from format string</a></li><li><a class="el" href="page_gen_usage.html#sec_stringizer">Stringizer: output to a string directly</a></li><li><a class="el" href="page_gen_usage.html#sec_diff_printf">Differences with C's printf format markers</a></li></ul>
</li></ul>
<h2><a class="anchor" name="sec_hello_world">
Hello World</a></h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="fmtr_8hpp.html">iof/fmtr.hpp</a>"</span>

<span class="keywordtype">int</span> main()
{
    std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"Hello %s\n"</span>) &lt;&lt; <span class="stringliteral">"world"</span>;
}
</pre></div><p>
You much more value out of iof when you start using more complicated format strings, with format specifications. Here is a slightly more realistic example, taken from real code (<em>zz</em> is a floating point value and <em>objName</em> could be any instance of any class that has an <code>operator&lt;&lt;(std::ostream&amp;)</code> defined for it):<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <a class="code" href="classiof_1_1fmtr.html">iof::fmtr</a>(<span class="stringliteral">"Ground is %s '%s' at z=%.2fs\n"</span>) 
          &lt;&lt; (zz&gt;0 ? <span class="stringliteral">"above"</span> : <span class="stringliteral">"under"</span>) &lt;&lt; objName &lt;&lt; zz;
</pre></div><p>
As with C's printf() function, the "structure", or format, of the output, seems clearer than the STL equivalent, which would be something like:<p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <span class="stringliteral">"Ground is "</span> &lt;&lt; (z&gt;0 ? <span class="stringliteral">"above"</span> : <span class="stringliteral">"under"</span>) &lt;&lt; <span class="stringliteral">" '"</span> 
          &lt;&lt; objName &lt;&lt; <span class="stringliteral">"' at z="</span> &lt;&lt; zz &lt;&lt; std::iof::precision(2) 
          &lt;&lt; std::fixed &lt;&lt; zz &lt;&lt; std::endl;
</pre></div><p>
and this would not even include the automatic restoration of the stream format state and the exception safety of this restoration that come for free with <em>iof</em>.<p>
<dl compact><dt><b>Note:</b></dt><dd>If you expect <em>iof</em> format strings to be compatible with printf's, you will be disappointed: printf does not support output of class instances, does not carry stream state with it, and has no notion of exceptions. Because of these important limitations, it would have been a serious detriment to <em>iof</em> to attempt to maintain compatibility with C's printf format strings. Instead, <em>iof</em> applies the same <em>principles</em> as printf and, where possible, the same format specification characters to have the same effect, but properly extended to the case of object oriented output and input.</dd></dl>
<h2><a class="anchor" name="sec_system_reqs">
System Requirements</a></h2>
The extensive test suite was compiled/built with g++ 3.4.2 and VC++.Net 2003 and run on a Windows XP PC. If you can build it with a different compiler (or just different compiler version) please let me know (see <a class="el" href="main.html#sec_contact">Feedback/bug reports/etc</a>).<h2><a class="anchor" name="sec_license">
License</a></h2>
BSD License. Basically you can use for free in any type of application, commercial or non. See the license file in the subversion repository, <a href="http://svn.sourceforge.net/viewcvs.cgi/iof/trunk/ioflib/LICENSE_IOF_1_0.txt?view=markup">http://svn.sourceforge.net/viewcvs.cgi/iof/trunk/ioflib/LICENSE_IOF_1_0.txt?view=markup</a><h2><a class="anchor" name="sec_download">
Download</a></h2>
Download the latest distribution file from SourceForge.net at <a href="http://sourceforge.net/project/showfiles.php?group_id=152971.">http://sourceforge.net/project/showfiles.php?group_id=152971.</a> This will be an archive file named ioflib-<em>ver</em>.tar.gz, where <em>ver</em> will be the version number of the library.<h2><a class="anchor" name="sec_install">
Installation</a></h2>
Extract the contents of the distribution file (that you downloaded) to a folder of your choice. In that folder you will see a new subfolder called ioflib-<em>ver</em> containing the following tree of subfolders:<p>
<div class="fragment"><pre class="fragment">where_you_unpacked
    +---ioflib-0_8_0
        +---doc
        +---include
        ¦   +---iof
        +---test
</pre></div><p>
There are no source files to compile (everything is templates in header files), so the installation just consists in copying the headers to where you want them, as explained next.<h3><a class="anchor" name="ssec_install_unix">
Unix:</a></h3>
Copy the <code>include/iof</code> folder to a location of your choice. You can then add that location to your include path for your compiler. E.g.<p>
<div class="fragment"><pre class="fragment">&gt; cp -r include/iof /usr/local/include
&gt; ls /usr/local/include
iof
&gt; g++ -I /usr/local/includes ...
</pre></div><h3><a class="anchor" name="ssec_install_win">
Windows:</a></h3>
<ul>
<li>Open root of distribution</li><li>Go to the folder named 'include'</li><li>Select the folder named 'iof'</li><li>Drag it to a location of your choice</li><li>You can then add this location to your include path for your compiler</li></ul>
<p>
The 'location of your choice' would probably be somewhere under "My Documents" or in the Vc7 tree etc. The <code>test</code> subfolder may be a good place to look at the compiler switches used for both g++ and Vc7 compilers.<h2><a class="anchor" name="sec_linking">
Linking</a></h2>
Regardless of where you put things, if the folder that <em>contains the iof folder</em> is called <code>YOUR_INCLUDES</code> then all you have to do is tell your compiler to add the folder YOUR_INCLUDES to its inclusion search path. That's because <em>iof</em> was designed so that any <em>iof</em> #include directive has the form <code>#include "iof/an_iof_header.hpp"</code>. Just writing <code>#include "an_iof_header.hpp"</code> will not work (if it does, expect it to not work next time you upgrade iof &lt;g&gt;).<h2><a class="anchor" name="sec_performance">
Performance</a></h2>
How much performance hit can you expect from all this fancy stuff? Not much, about 20% is the worst case scenario: if your program spends the large majority of its time doing formatted output, then it will take about 20% longer with iof than without. But you know as well as I that this is rare and more often the bottleneck is with CPU usage, network access, drive access, user input, poor design, etc. Also, the above hit is not really a fair comparison since <em>iof</em> allows you to not worry about several things that you would have to do manually (e.g. restoring the stream format state after an output), which would further decrease the gap. So it is hardly worth worrying about.<p>
For formatted input, the hit is a little more, 40%, but again applies to a program that is doing purely formatted input and nothing else (no complex computations, no web access, etc), a rare situation. And if you were to code manually some of the features (like validity testing and error messages), the gap would quickly shrink.<p>
The conclusion is that in general the performance cost is negligible. But there are always special cases.<h2><a class="anchor" name="sec_changelog">
Change Log</a></h2>
The major revisions can be summarized as follows:<p>
<table style="margin-left: auto; font-family: helvetica,arial,sans-serif; 
 height: 116px; width: 740px;" border="0" cellpadding="2" cellspacing="2">
<tr>
<td style="vertical-align: top; font-weight: bold; ">Version </td><td style="vertical-align: top; font-weight: bold; ">Changes from previous version  </td></tr>
<tr>
<td>0.7 </td><td>Object-based centering and alignment  </td></tr>
<tr>
<td>0.6 </td><td>Exception safety, better persistence model  </td></tr>
<tr>
<td>0.5 </td><td>First release after branch off from the original "coutf" v1.2 library  </td></tr>
</table>
<h2><a class="anchor" name="sec_contact">
Feedback/bug reports/etc</a></h2>
Please use the bug reporting, feature request and forum facilities at <a href="http://www.sf.net/projects/iof.">http://www.sf.net/projects/iof.</a> You may email me (schoenborno) directly, at users.sf.net. <hr size="1"><address style="align: right;"><small>Generated on Sun Oct 15 23:55:35 2006 for IOF Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
