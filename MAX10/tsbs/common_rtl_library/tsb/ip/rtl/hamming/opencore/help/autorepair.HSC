HelpScribble project file.
9
...
320
1
AutoRepair Tool



TRUE

D:\amamory\temp\reed\builder\new
1
BrowseButtons()
0
TRUE
D:\amamory\temp\reed\builder\new\
FALSE
4
10
Scribble10
AutoRepair




Writing



FALSE
21
{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Arial;}{\f1\fnil Arial;}{\f2\fnil Courier New;}}
{\colortbl ;\red0\green0\blue255;\red255\green0\blue0;\red128\green0\blue0;}
\viewkind4\uc1\pard\cf1\lang1046\b\fs32 AutoRepair\lang1033\f1 
\par \cf0\lang1046\fs22 
\par Goal:
\par \b0\f0\fs20   The goal of AutoRepair tool is to generate automatically VHDL Library of Hamming and Reed-Solomon error corrector codes. \cf2\b bl\'e1-bl\'e1-bl\'e1\cf0\b0 
\par \lang1033\f1 
\par 
\par \lang1046\b\fs22 Authors:\b0\f0\fs20 
\par   Alexandre M. Amory (amamory@inf.ufrgs.br)
\par   Gustavo Neuberger (neuberger@inf.ufrgs.br)
\par 
\par \b\f1\fs22 Collaborations:\b0\f0\fs20 
\par   Fernanda G. Lima (fglima@inf.ufrgs.br)
\par   Ricardo Reis (reis@inf.ufrgs.br)
\par 
\par \b\f1\fs22 HomePage 
\par \b0\strike\f2\fs20 http://www.inf.ufrgs.br/gme/autorepair\cf3\strike0\{link=*! ExecFile("http://www.inf.ufrgs.br/gme/autorepair")\}
\par \cf0\lang1033\f1 
\par \b\fs22 
\par }
20
Scribble20
Reed-Solomon




Writing



FALSE
6
{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Arial;}{\f1\fnil Arial;}}
{\colortbl ;\red0\green0\blue255;}
\viewkind4\uc1\pard\cf1\lang1046\b\fs32 Reed-Solomon\lang1033\f1 
\par \cf0\b0\fs20 
\par 
\par }
30
Scribble30
Hamming SEC




Writing



FALSE
88
{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Arial;}{\f1\fnil Arial;}{\f2\fnil\fcharset0 Courier;}}
{\colortbl ;\red0\green0\blue255;\red0\green0\blue128;\red0\green128\blue128;\red255\green0\blue0;\red128\green0\blue0;}
\viewkind4\uc1\pard\cf1\lang1046\b\fs32 Hamming SEC\lang1033\f1 
\par \cf0\b0\fs20 
\par \b\fs22 DESCRIPTION:\b0\fs20 
\par   This program generates \lang1046\f0 two files. The first one is \lang1033\f1 a \i VHDL package\i0  \lang1046\f0 which implements\lang1033\f1  hamming code for\lang1046\f0  \lang1033\f1 SEC(single error correction)\lang1046\f0 . The second is a \i testbench \i0 to validate the package\lang1033\f1 .\lang1046\f0  The resulting package has two functions, one for encoding and the other for decoding. 
\par 
\par \b\f1\fs22 EXAMPLE\f0  OF PACKAGE\f1 :\b0\f0\fs20 
\par   The resulting package VHDL description for a Hamming SEC of 32 bits has:\lang1033\f1 
\par \lang1046\f0   For Hamming encoding:\lang1033\f1 
\par \tab\cf2 FUNCTION \cf0 hamming_encoder_32bit(data_in:data_ham_32bit) \cf2 RETURN \cf0 parity_ham_32bit;
\par \lang1046\f0\tab\cf3 data_in\cf0  - the raw data to be encoded with hamming code. In this example it should be std_logic_vector(31 downto 0)
\par   For Hamming decoding:
\par \tab\cf2 FUNCTION \cf0 hamming_decoder_32bit(data_parity_in:coded_ham_32bit) \cf2 RETURN \cf0 data_ham_32bit;
\par \tab\cf3\lang1033\f1 data_parity_in\cf0\lang1046\f0  - data + parity bits to be decoded\lang1033\f1 
\par 
\par \lang1046\b\fs22 USING THE HAMMING PACKAGE:\b0\f0\fs20 
\par   Here we present an example of how to use this package. First we present the original 16 bit register description, following by the 
\par Fault-tolerant description which uses the VHDL package generated by AutoRepair.
\par 
\par \b ORIGINAL DESCRIPTION\b0 :
\par \cf2\f2 library \cf0 ieee;
\par \cf2 use \cf0 ieee.std_logic_1164.\cf2 all\cf0 ;
\par 
\par \cf2 entity \cf0 test \cf2 is\cf0 
\par 
\par   \cf2 port \cf0 (
\par     datain   : \cf2 in  \cf0 std_logic_vector(15 \cf2 downto \cf0 0);
\par     clock    : \cf2 in  \cf0 std_logic;
\par     dataout  : \cf2 out \cf0 std_logic_vector(15 \cf2 downto \cf0 0);
\par     error    : \cf2 out \cf0 std_logic_vector(1 \cf2 downto \cf0 0)
\par   );
\par \cf2 end entity\cf0 ;
\par 
\par \cf2 architecture \cf0 test \cf2 of \cf0 test \cf2 is\cf0 
\par   \cf2 signal \cf0 temp   : std_logic_vector(15 \cf2 downto \cf0 0);
\par \cf2 begin\cf0 
\par 
\par   \cf2 process\cf0 (clock)
\par   \cf2 begin\cf0 
\par     \cf2 if\cf0  (clock'event \cf2 and clock\cf0 ='1') \cf2 then\cf0 
\par       temp <= datain;
\par     \cf2 end if\cf0 ;
\par   \cf2 end process\cf0 ;
\par 
\par   dataout <= temp;
\par 
\par \cf2 end architecture\cf0 ;\f0 
\par 
\par \b FAULT-TOLERANT DESCRIPTION\b0 :
\par \cf2\f2 library \cf0 ieee;
\par \cf2 use \cf0 ieee.std_logic_1164.\cf2 all\cf0 ;
\par \cf2 use \cf0 WORK.\cf4 hamm_package_16bit\cf0 .\cf2 all\cf0 ;
\par 
\par \cf2 entity \cf0 test \cf2 is\cf0 
\par 
\par   \cf2 port \cf0 (
\par     datain   : \cf2 in  \cf0 std_logic_vector(15 \cf2 downto \cf0 0);
\par     clock    : \cf2 in  \cf0 std_logic;
\par     dataout  : \cf2 out \cf0 std_logic_vector(15 \cf2 downto \cf0 0);
\par     error    : \cf2 out \cf0 std_logic_vector(1 \cf2 downto \cf0 0)
\par   );
\par \cf2 end entity\cf0 ;
\par 
\par \cf2 architecture \cf0 test \cf2 of \cf0 test \cf2 is\cf0 
\par   \cf2 signal \cf0 temp   : \cf4 coded_ham_16bit\cf0 ;
\par \cf2 begin\cf0 
\par 
\par   \cf2 process\cf0 (clock)
\par   \cf2 begin\cf0 
\par     \cf2 if\cf0  (clock'event \cf2 and clock\cf0 ='1') \cf2 then\cf0 
\par       temp <= datain & \cf4 hamming_encoder_16bit\cf0 (datain);
\par     \cf2 end if\cf0 ;
\par   \cf2 end process\cf0 ;
\par 
\par   dataout <= \cf4 hamming_decoder_16bit\cf0 (temp);
\par 
\par \cf2 end architecture\cf0 ;
\par \lang1033\f1 
\par \lang1046\b\fs22 EXAMPLE OF TESTBENCH:\b0\f0\fs20 
\par   The generated testbench can be used to validate the resulting Hamming description. 
\par   The testbench is a generic VHDL implementation which implements a data channel. This channel uses hamming to protected against unapexted erros. The channel can receive upsets, but the testbench only inject one error per time, which should be corrected by the hamming code. After which fault injection, the testbench compares the input data of the channel against the output data. If it does not match, then there is a error in the hamming package. The figure below illustrate this architecture.
\par 
\par \pard\qc\cf5\{bmc upset.bmp\}\cf0 
\par \pard 
\par   The testbench can run on any VHDL simulator. The simulation run-time can be parametrizable using the generic NPATTERNS. By default, NPATTERNS receives 2**n-1 to test all combinations of input data.\lang1033\f1 
\par 
\par }
40
Scribble40
Hamming SEC/DED




Writing



FALSE
98
{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Arial;}{\f1\fnil Arial;}{\f2\fnil\fcharset0 Courier;}}
{\colortbl ;\red0\green0\blue255;\red0\green0\blue128;\red0\green128\blue128;\red255\green0\blue0;\red128\green0\blue0;}
\viewkind4\uc1\pard\cf1\lang1046\b\fs32 Hamming SEC/DED\lang1033\f1 
\par \cf0\lang1046\fs22 
\par \lang1033 DESCRIPTION:\b0\fs20 
\par   This program generates \lang1046\f0 two files. The first one is \lang1033\f1 a \i VHDL package\i0  \lang1046\f0 which implements\lang1033\f1  hamming code for\lang1046\f0  \lang1033\f1 SEC\lang1046\f0 /DED\lang1033\f1  (single error correction\lang1046\f0 /double error detection\lang1033\f1 )\lang1046\f0 . The second is a \i testbench \i0 to validate the package\lang1033\f1 .\lang1046\f0  The resulting package has two functions, one for encoding and the other for decoding. 
\par 
\par \b\f1\fs22 EXAMPLE\f0  OF PACKAGE\f1 :\b0\f0\fs20 
\par   The resulting package VHDL description for a Hamming SEC/DED of 32 bits has:\lang1033\f1 
\par \lang1046\f0   For Hamming encoding:\lang1033\f1 
\par \tab\cf2 FUNCTION \cf0 hamming_encoder_32bit(data_in:data_ham_32bit) \cf2 RETURN \cf0 parity_ham_32bit;
\par \lang1046\f0\tab\cf3 data_in\cf0  - the raw data to be encoded with hamming code. In this example it should be std_logic_vector(31 downto 0)
\par   For Hamming decoding:\lang1033\f1 
\par \tab\cf2 PROCEDURE \cf0 hamming_decoder_32bit(data_parity_in:coded_ham_32bit;
\par \tab\tab\cf2 SIGNAL \cf0 error_out : \cf2 OUT \cf0 std_logic_vector(1 \cf2 DOWNTO \cf0 0);
\par \tab\tab\cf2 SIGNAL \cf0 decoded : \cf2 OUT \cf0 data_ham_32bit);
\par \lang1046\f0\tab\cf3\lang1033\f1 data_parity_in\cf0\lang1046\f0  - data + parity bits to be decoded\lang1033\f1 
\par \lang1046\f0\tab\cf3\lang1033\f1 error_out\cf0\lang1046\f0  - 2 bit words which sinalize error condition.
\par \tab\tab "00" - no error
\par \tab\tab "01" - one error detected and corrected
\par \tab\tab "11" - 2 error detected. It can not correct the error.\lang1033\f1 
\par \lang1046\f0\tab\cf3\lang1033\f1 decoded\lang1046\f0  \cf0 - the resulting data word corrected.\lang1033\f1 
\par 
\par 
\par \lang1046\b\fs22 USING THE HAMMING PACKAGE:\b0\f0\fs20 
\par   Here we present an example of how to use this package. First we present the original 16 bit register description, following by the 
\par Fault-tolerant description which uses the VHDL package generated by AutoRepair.
\par 
\par \b ORIGINAL DESCRIPTION\b0 :
\par \cf2\f2 library \cf0 ieee;
\par \cf2 use \cf0 ieee.std_logic_1164.\cf2 all\cf0 ;
\par 
\par \cf2 entity \cf0 test \cf2 is\cf0 
\par 
\par   \cf2 port \cf0 (
\par     datain   : \cf2 in  \cf0 std_logic_vector(15 \cf2 downto \cf0 0);
\par     clock    : \cf2 in  \cf0 std_logic;
\par     dataout  : \cf2 out \cf0 std_logic_vector(15 \cf2 downto \cf0 0);
\par     error    : \cf2 out \cf0 std_logic_vector(1 \cf2 downto \cf0 0)
\par   );
\par \cf2 end entity\cf0 ;
\par 
\par \cf2 architecture \cf0 test \cf2 of \cf0 test \cf2 is\cf0 
\par   \cf2 signal \cf0 temp   : std_logic_vector(15 \cf2 downto \cf0 0);
\par \cf2 begin\cf0 
\par 
\par   \cf2 process\cf0 (clock)
\par   \cf2 begin\cf0 
\par     \cf2 if\cf0  (clock'event \cf2 and clock\cf0 ='1') \cf2 then\cf0 
\par       temp <= datain;
\par     \cf2 end if\cf0 ;
\par   \cf2 end process\cf0 ;
\par 
\par   dataout <= temp;
\par 
\par \cf2 end architecture\cf0 ;\f0 
\par 
\par \b FAULT-TOLERANT DESCRIPTION\b0 :
\par \cf2\f2 library \cf0 ieee;
\par \cf2 use \cf0 ieee.std_logic_1164.\cf2 all\cf0 ;
\par \cf2 use \cf0 WORK.\cf4 hamm_package_16bit\cf0 .\cf2 all\cf0 ;
\par 
\par \cf2 entity \cf0 test \cf2 is\cf0 
\par 
\par   \cf2 port \cf0 (
\par     datain   : \cf2 in  \cf0 std_logic_vector(15 \cf2 downto \cf0 0);
\par     clock    : \cf2 in  \cf0 std_logic;
\par     dataout  : \cf2 out \cf0 std_logic_vector(15 \cf2 downto \cf0 0);
\par     error    : \cf2 out \cf0 std_logic_vector(1 \cf2 downto \cf0 0)
\par   );
\par \cf2 end entity\cf0 ;
\par 
\par \cf2 architecture \cf0 test \cf2 of \cf0 test \cf2 is\cf0 
\par   \cf2 signal \cf0 temp   : \cf4 coded_ham_16bit\cf0 ;
\par \cf2 begin\cf0 
\par 
\par   \cf2 process\cf0 (clock)
\par   \cf2 begin\cf0 
\par     \cf2 if\cf0  (clock'event \cf2 and clock\cf0 ='1') \cf2 then\cf0 
\par       temp <= datain & \cf4 hamming_encoder_16bit\cf0 (datain);
\par     \cf2 end if\cf0 ;
\par   \cf2 end process\cf0 ;
\par 
\par   \cf4 hamming_decoder_16bit\cf0 (temp,error,dataout);
\par 
\par \cf2 end architecture\cf0 ;
\par \lang1033\f1 
\par \lang1046\b\fs22 EXAMPLE OF TESTBENCH:\b0\f0\fs20 
\par   The generated testbench can be used to validate the resulting Hamming description. 
\par   The testbench is a generic VHDL implementation which implements a data channel. This channel uses hamming to protected against unapexted erros. The channel can receive upsets, but the testbench only inject one error per time, which should be corrected by the hamming code. After which fault injection, the testbench compares the input data of the channel against the output data. If it does not match, then there is a error in the hamming package. The figure below illustrate this architecture.
\par 
\par \pard\qc\cf5\{bmc upset.bmp\}\cf0 
\par \pard 
\par   The testbench can run on any VHDL simulator. The simulation run-time can be parametrizable using the generic NPATTERNS. By default, NPATTERNS receives 2**n-1 to test all combinations of input data.\lang1033\f1 
\par 
\par 
\par \lang1046\b\f0\fs22 
\par }
0
0
0
4
1 AutoRepair=Scribble10
1 Reed-Solomon=Scribble20
1 Hamming SEC=Scribble30
1 Hamming SEC/DED=Scribble40
8
*InternetLink
-2147483640
Courier New
0
10
....
0
0
0
0
0
0
*ParagraphTitle
-2147483640
Arial
0
11
B...
0
0
0
0
0
0
*PopupLink
-2147483640
Arial
0
8
....
0
0
0
0
0
0
*PopupTopicTitle
16711680
Arial
0
10
B...
0
0
0
0
0
0
*SourceCode
-2147483640
Courier New
0
10
....
0
0
0
0
0
0
*TopicText
-2147483640
Arial
0
10
....
0
0
0
0
0
0
*TopicTitle
16711680
Arial
0
16
B...
0
0
0
0
0
0
code
-2147483640
Courier
0
10
....
0
0
0
0
0
0
